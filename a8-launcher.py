#!/usr/bin/env python3
# Generated by Haxe 3.4.7
# coding: utf-8

from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import sched as a8_PySched
from threading import Thread as python_lib_threading_Thread
import time as python_lib_Time
import shutil as a8_PyShutil2
import os as a8_PyOs2
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import io as python_lib_Io
import json as python_lib_Json
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import subprocess as python_lib_Subprocess
import sys as python_lib_Sys
try:
    import termios as python_lib_Termios
except:
    pass
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
try:
    import tty as python_lib_Tty
except:
    pass
from io import StringIO as python_lib_io_StringIO
from subprocess import Popen as python_lib_subprocess_Popen


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:38
        self.tag = tag
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:39
        self.index = index
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:40
        self.params = params

    def __str__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:45
        if (self.params is None):
            return self.tag
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:48
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")

Enum._hx_class = Enum


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date",)
    _hx_fields = ["date"]
    _hx_methods = ["toString"]
    _hx_statics = ["EPOCH_UTC", "now", "fromTime", "UTC", "datetimeTimestamp", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:34
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:35
        if (day == 0):
            day = 1
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:36
        self.date = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0)

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:83
        m = ((self.date.month - 1) + 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:84
        d = self.date.day
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:85
        h = self.date.hour
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:86
        mi = self.date.minute
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:87
        s = self.date.second
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:88
        return ((((((((((Std.string(self.date.year) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(m)) if ((m < 10)) else ("" + Std.string(m)))))) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(d)) if ((d < 10)) else ("" + Std.string(d)))))) + " ") + HxOverrides.stringOrNull(((("0" + Std.string(h)) if ((h < 10)) else ("" + Std.string(h)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(mi)) if ((mi < 10)) else ("" + Std.string(mi)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(s)) if ((s < 10)) else ("" + Std.string(s))))))

    @staticmethod
    def now():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:98
        d = Date(1970,0,1,0,0,0)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:99
        d.date = python_lib_datetime_Datetime.now()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:100
        return d

    @staticmethod
    def fromTime(t):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:105
        d = Date(1970,0,1,0,0,0)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:106
        d.date = python_lib_datetime_Datetime.fromtimestamp((t / 1000.0))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:107
        return d

    @staticmethod
    def UTC(year,month,day,hour,_hx_min,sec):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:113
        dt = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0,python_lib_datetime_Timezone.utc)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:114
        return Date.datetimeTimestamp(dt,Date.EPOCH_UTC)

    @staticmethod
    def datetimeTimestamp(dt,epoch):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:119
        return ((dt - epoch).total_seconds() * 1000)

    @staticmethod
    def fromString(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:124
        _g = len(s)
        _g1 = _g
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:126
        if (_g1 == 8):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:127
            k = s.split(":")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:128
            d = Date(0,0,0,Std.parseInt((k[0] if 0 < len(k) else None)),Std.parseInt((k[1] if 1 < len(k) else None)),Std.parseInt((k[2] if 2 < len(k) else None)))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:129
            return d
        elif (_g1 == 10):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:131
            k1 = s.split("-")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:132
            return Date(Std.parseInt((k1[0] if 0 < len(k1) else None)),(Std.parseInt((k1[1] if 1 < len(k1) else None)) - 1),Std.parseInt((k1[2] if 2 < len(k1) else None)),0,0,0)
        elif (_g1 == 19):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:134
            k2 = s.split(" ")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:135
            _this = (k2[0] if 0 < len(k2) else None)
            y = _this.split("-")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:136
            _this1 = (k2[1] if 1 < len(k2) else None)
            t = _this1.split(":")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:137
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise _HxException(("Invalid date format : " + ("null" if s is None else s)))

Date._hx_class = Date


class EnumValue:
    _hx_class_name = "EnumValue"
EnumValue._hx_class = EnumValue


class Lambda:
    _hx_class_name = "Lambda"
    __slots__ = ()
    _hx_statics = ["array", "map", "flatten", "flatMap", "iter", "find"]

    @staticmethod
    def array(it):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:45
        a = list()
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:46
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:46
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:47
            a.append(i1)
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:48
        return a

    @staticmethod
    def map(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:71
        l = List()
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:72
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:72
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:73
            l.add(f(x1))
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:74
        return l

    @staticmethod
    def flatten(it):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:98
        l = List()
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:99
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:99
        e = HxOverrides.iterator(it)
        while e.hasNext():
            e1 = e.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:100
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:100
            x = HxOverrides.iterator(e1)
            while x.hasNext():
                x1 = x.next()
                # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:101
                l.add(x1)
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:102
        return l

    @staticmethod
    def flatMap(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:113
        return Lambda.flatten(Lambda.map(it,f))

    @staticmethod
    def iter(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:173
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:174
            f(x1)

    @staticmethod
    def find(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:264
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:264
        v = HxOverrides.iterator(it)
        while v.hasNext():
            v1 = v.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:265
            if f(v1):
                return v1
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:267
        return None
Lambda._hx_class = Lambda


class List:
    _hx_class_name = "List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "iterator"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:33
        self.q = None
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:32
        self.h = None
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:44
        self.length = 0

    def add(self,item):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:53
        x = _List_ListNode(item,None)
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:54
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:58
        self.q = x
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:59
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:59
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def iterator(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:161
        return _List_ListIterator(self.h)

List._hx_class = List


class _List_ListNode:
    _hx_class_name = "_List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:256
        self.item = item
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:257
        self.next = next

_List_ListNode._hx_class = _List_ListNode


class _List_ListIterator:
    _hx_class_name = "_List.ListIterator"
    __slots__ = ("head",)
    _hx_fields = ["head"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,head):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:269
        self.head = head

    def hasNext(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:273
        return (self.head is not None)

    def next(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:277
        val = self.head.item
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:278
        self.head = self.head.next
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:279
        return val

_List_ListIterator._hx_class = _List_ListIterator


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField", "isFunction", "copy"]

    @staticmethod
    def field(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:44
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:49
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def isFunction(f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:86
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return hasattr(f,"func_code")
        else:
            return True

    @staticmethod
    def copy(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:124
        o2 = _hx_AnonObject({})
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:125
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:125
        _g = 0
        _g1 = python_Boot.fields(o)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:126
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:126
            value = Reflect.field(o,f)
            setattr(o2,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:127
        return o2
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def string(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:134
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:147
        if (x is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:148
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:152
                prefix = HxString.substr(x,0,2).lower()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:154
                if (prefix == "0x"):
                    return int(x,16)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:157
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:160
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:162
                if (r is None):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:163
                    r1 = Std.shortenPossibleNumber(x)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:164
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:170
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:177
        r = ""
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:178
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:178
        _g1 = 0
        _g = len(x)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:179
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:180
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:180
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g21 = _g2
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:191
                if (((((((((((_g21 == 57) or ((_g21 == 56))) or ((_g21 == 55))) or ((_g21 == 54))) or ((_g21 == 53))) or ((_g21 == 52))) or ((_g21 == 51))) or ((_g21 == 50))) or ((_g21 == 49))) or ((_g21 == 48))) or ((_g21 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:195
        return r

    @staticmethod
    def parseFloat(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:200
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:204
            if (x is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:205
                r1 = Std.shortenPossibleNumber(x)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:206
                if (r1 != x):
                    return Std.parseFloat(r1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:210
            return Math.NaN
Std._hx_class = Std


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/StringBuf.hx:32
        self.b = python_lib_io_StringIO()

StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["startsWith", "endsWith", "lpad"]

    @staticmethod
    def startsWith(s,start):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:200
        if (len(s) >= len(start)):
            return (HxString.substr(s,0,len(start)) == start)
        else:
            return False

    @staticmethod
    def endsWith(s,end):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:230
        elen = len(end)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:231
        slen = len(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:232
        if (slen >= elen):
            return (HxString.substr(s,(slen - elen),elen) == end)
        else:
            return False

    @staticmethod
    def lpad(s,c,l):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:332
        if (len(c) <= 0):
            return s
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:335
        while (len(s) < l):
            s = (("null" if c is None else c) + ("null" if s is None else s))
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:338
        return s
StringTools._hx_class = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "fullPath", "isDirectory", "createDirectory", "deleteFile", "readDirectory"]

    @staticmethod
    def exists(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:31
        return python_lib_os_Path.exists(path)

    @staticmethod
    def fullPath(relPath):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:56
        return python_lib_os_Path.realpath(relPath)

    @staticmethod
    def isDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:66
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def createDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:70
        python_lib_Os.makedirs(path,511,True)

    @staticmethod
    def deleteFile(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:74
        python_lib_Os.remove(path)

    @staticmethod
    def readDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:82
        return python_lib_Os.listdir(path)
sys_FileSystem._hx_class = sys_FileSystem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["get", "keys"]
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:32
        self.h = dict()

    def get(self,key):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:40
        return self.h.get(key,None)

    def keys(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:54
        return python_HaxeIterator(iter(self.h.keys()))

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:31
        self.checked = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:30
        self.has = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:29
        self.x = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:34
        self.it = it

    def next(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:38
        if (not self.checked):
            self.hasNext()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:39
        self.checked = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:40
        return self.x

    def hasNext(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:44
        if (not self.checked):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:45
            try:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:46
                self.x = self.it.__next__()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:47
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:49
                    self.has = False
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:50
                    self.x = None
                else:
                    raise _hx_e
            # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:52
            self.checked = True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:54
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["environ", "time", "exit", "print", "println", "args", "getEnv", "putEnv", "environment", "sleep", "setTimeLocale", "getCwd", "setCwd", "systemName", "command", "cpuTime", "executablePath", "_programPath", "programPath", "getChar", "stdin", "stdout", "stderr"]

    @staticmethod
    def time():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:42
        return python_lib_Time.time()

    @staticmethod
    def exit(code):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:46
        python_lib_Sys.exit(code)

    @staticmethod
    def print(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:50
        python_Lib.print(v)

    @staticmethod
    def println(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:54
        python_Lib.println(v)

    @staticmethod
    def args():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:58
        argv = python_lib_Sys.argv
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:59
        return argv[1:None]

    @staticmethod
    def getEnv(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:63
        return Sys.environ.h.get(s,None)

    @staticmethod
    def putEnv(s,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:67
        python_lib_Os.putenv(s,v)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:68
        Sys.environ.h[s] = v

    @staticmethod
    def environment():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:72
        return Sys.environ

    @staticmethod
    def sleep(seconds):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:76
        python_lib_Time.sleep(seconds)

    @staticmethod
    def setTimeLocale(loc):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:80
        return False

    @staticmethod
    def getCwd():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:84
        return python_lib_Os.getcwd()

    @staticmethod
    def setCwd(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:88
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:92
        _g = python_lib_Sys.platform
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:93
        x = _g
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:92
        if StringTools.startsWith(x,"linux"):
            return "Linux"
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:92
            _g1 = _g
            _hx_local_0 = len(_g1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:96
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:104
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def cpuTime():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:111
        return python_lib_Timeit.default_timer()

    @staticmethod
    def executablePath():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:115
        return python_internal_ArrayImpl._get(python_lib_Sys.argv, 0)

    @staticmethod
    def programPath():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:121
        return Sys._programPath

    @staticmethod
    def getChar(echo):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:126
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:127
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:128
                fd = python_lib_Sys.stdin.fileno()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:129
                old = python_lib_Termios.tcgetattr(fd)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:131
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_1
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:133
                try:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:134
                    python_lib_Tty.setraw(fd)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:135
                    x = python_lib_Sys.stdin.read(1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:136
                    restore()
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:126
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:139
                    restore()
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:140
                    raise _HxException(e)
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:145
                x1 = _g
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:146
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:128
                fd = python_lib_Sys.stdin.fileno()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:129
                old = python_lib_Termios.tcgetattr(fd)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:131
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_2
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:133
                try:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:134
                    python_lib_Tty.setraw(fd)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:135
                    x = python_lib_Sys.stdin.read(1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:136
                    restore()
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:126
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:139
                    restore()
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:140
                    raise _HxException(e)
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:145
                x1 = _g
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:146
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getch().decode("utf-8"),0)
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:145
                x1 = _g
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:146
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:145
            x1 = _g
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:146
            raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:148
        if echo:
            python_Lib.print("".join(map(chr,[ch])))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:151
        return ch

    @staticmethod
    def stdin():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:155
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

    @staticmethod
    def stdout():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:159
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stdout)

    @staticmethod
    def stderr():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:163
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stderr)
Sys._hx_class = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, [c])

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, [e])
ValueType.TNull = ValueType("TNull", 0, list())
ValueType.TInt = ValueType("TInt", 1, list())
ValueType.TFloat = ValueType("TFloat", 2, list())
ValueType.TBool = ValueType("TBool", 3, list())
ValueType.TObject = ValueType("TObject", 4, list())
ValueType.TFunction = ValueType("TFunction", 5, list())
ValueType.TUnknown = ValueType("TUnknown", 8, list())
ValueType._hx_class = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["typeof"]

    @staticmethod
    def typeof(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Type.hx:178
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown
Type._hx_class = Type


class a8_DateOps:
    _hx_class_name = "a8.DateOps"
    __slots__ = ()
    _hx_statics = ["midnight"]

    @staticmethod
    def midnight():
        # src/a8/DateOps.hx:7
        now = Date.now()
        # src/a8/DateOps.hx:8
        oneSecondBeforeMidnight = Date(now.date.year,(now.date.month - 1),now.date.day,23,59,59)
        # src/a8/DateOps.hx:9
        return Date.fromTime(((python_lib_Time.mktime(oneSecondBeforeMidnight.date.timetuple()) * 1000) + 1000))
a8_DateOps._hx_class = a8_DateOps


class a8_Exception:
    _hx_class_name = "a8.Exception"
    __slots__ = ("message", "causedBy", "callStack", "posInfos")
    _hx_fields = ["message", "causedBy", "callStack", "posInfos"]
    _hx_methods = ["toString", "rethrow"]
    _hx_statics = ["thro"]

    def __init__(self,message,causedBy = None,posInfos = None):
        # src/a8/Exception.hx:19
        self.message = message
        # src/a8/Exception.hx:20
        self.causedBy = a8_OptionOps.toOption(causedBy)
        # src/a8/Exception.hx:21
        self.callStack = haxe_CallStack.callStack()
        # src/a8/Exception.hx:22
        self.posInfos = posInfos

    def toString(self):
        # src/a8/Exception.hx:26
        return ((((((HxOverrides.stringOrNull(self.posInfos.fileName) + ":") + Std.string(self.posInfos.lineNumber)) + " ") + HxOverrides.stringOrNull(self.message)) + "\n") + HxOverrides.stringOrNull(a8_HaxeOps2.asString(self.callStack,"    ")))

    def rethrow(self,context,posInfos = None):
        # src/a8/Exception.hx:35
        raise _HxException(a8_Exception(context,self,posInfos))

    @staticmethod
    def thro(message):
        # src/a8/Exception.hx:10
        raise _HxException(a8_Exception(message,None,_hx_AnonObject({'fileName': "Exception.hx", 'lineNumber': 10, 'className': "a8.Exception", 'methodName': "thro"})))

a8_Exception._hx_class = a8_Exception


class a8_Exec:
    _hx_class_name = "a8.Exec"
    __slots__ = ("args", "cwd", "env", "failOnNonZeroExitCode", "executable")
    _hx_fields = ["args", "cwd", "env", "failOnNonZeroExitCode", "executable"]
    _hx_methods = ["asCommandLine", "execInline", "execCapture"]

    def __init__(self):
        # src/a8/Exec.hx:17
        self.executable = None
        # src/a8/Exec.hx:15
        self.env = None
        # src/a8/Exec.hx:14
        self.cwd = None
        # src/a8/Exec.hx:13
        self.args = None
        # src/a8/Exec.hx:16
        self.failOnNonZeroExitCode = True
        # src/a8/Exec.hx:13
        self.args = []
        # src/a8/Exec.hx:14
        self.cwd = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:15
        self.env = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:17
        self.executable = haxe_ds_Option._hx_None

    def asCommandLine(self):
        # src/a8/Exec.hx:23
        _this = self.args
        return " ".join([python_Boot.toString1(x1,'') for x1 in _this])

    def execInline(self):
        # src/a8/Exec.hx:31
        a8_Logger.trace(("running -- " + HxOverrides.stringOrNull(self.asCommandLine())),_hx_AnonObject({'fileName': "Exec.hx", 'lineNumber': 31, 'className': "a8.Exec", 'methodName': "execInline"}))
        # src/a8/Exec.hx:32
        exitCode = python_lib_Subprocess.call(self.args,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'cwd': a8_OptionOps.getOrElse(self.cwd,None)})))
        # src/a8/Exec.hx:39
        if ((exitCode != 0) and self.failOnNonZeroExitCode):
            a8_Exception.thro(((("non-zero exit code of " + Std.string(exitCode)) + " while executing -- ") + HxOverrides.stringOrNull(self.asCommandLine())))
        # src/a8/Exec.hx:42
        return exitCode

    def execCapture(self):
        # src/a8/Exec.hx:49
        a8_Logger.trace(("running -- " + HxOverrides.stringOrNull(self.asCommandLine())),_hx_AnonObject({'fileName': "Exec.hx", 'lineNumber': 49, 'className': "a8.Exec", 'methodName': "execCapture"}))
        # src/a8/Exec.hx:52
        popen = self.args
        # src/a8/Exec.hx:54
        popen1 = a8_OptionOps.getOrElse(self.executable,(self.args[0] if 0 < len(self.args) else None))
        # src/a8/Exec.hx:56
        popen2 = python_lib_Subprocess.PIPE
        # src/a8/Exec.hx:57
        popen3 = python_lib_Subprocess.PIPE
        # src/a8/Exec.hx:61
        popen4 = a8_OptionOps.getOrElse(self.cwd,None)
        # src/a8/Exec.hx:62
        o = self.env
        popen5 = None
        if (o.index == 0):
            v = o.params[0]
            popen5 = haxe_ds_Option.Some(a8_PyOps.toDict(v))
        else:
            popen5 = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:50
        popen6 = python_lib_subprocess_Popen(popen,None,popen1,None,popen2,popen3,None,False,False,popen4,a8_OptionOps.getOrElse(popen5,None))
        # src/a8/Exec.hx:65
        def _hx_local_0(out):
            pass
        firstIO = _hx_local_0
        # src/a8/Exec.hx:68
        timestampStr = a8_PathOps.timestampStr()
        # src/a8/Exec.hx:70
        stdoutCapture = haxe_io_BytesOutput()
        # src/a8/Exec.hx:71
        stderrCapture = haxe_io_BytesOutput()
        # src/a8/Exec.hx:73
        pipedStdout = a8_Pipe(a8_StreamOps.asInputStream(popen6.stdout),a8_StreamOps2.asOutputStream(stdoutCapture),firstIO)
        # src/a8/Exec.hx:74
        pipedStderr = a8_Pipe(a8_StreamOps.asInputStream(popen6.stderr),a8_StreamOps2.asOutputStream(stderrCapture),firstIO)
        # src/a8/Exec.hx:76
        pipedStdout.run()
        # src/a8/Exec.hx:77
        pipedStderr.run()
        # src/a8/Exec.hx:79
        popen6.wait()
        # src/a8/Exec.hx:81
        result = _hx_AnonObject({'exitCode': popen6.returncode, 'stderr': a8_HaxeOps.asString(stderrCapture.getBytes()), 'stdout': a8_HaxeOps.asString(stdoutCapture.getBytes())})
        # src/a8/Exec.hx:88
        a8_Logger.trace(("" + Std.string(result.exitCode)),_hx_AnonObject({'fileName': "Exec.hx", 'lineNumber': 88, 'className': "a8.Exec", 'methodName': "execCapture"}))
        # src/a8/Exec.hx:89
        if ((result.exitCode != 0) and self.failOnNonZeroExitCode):
            a8_Exception.thro(((("non-zero exit code of " + Std.string(result.exitCode)) + " while executing -- ") + HxOverrides.stringOrNull(self.asCommandLine())))
        # src/a8/Exec.hx:93
        return result

a8_Exec._hx_class = a8_Exec


class a8_PyOps:
    _hx_class_name = "a8.PyOps"
    __slots__ = ()
    _hx_statics = ["toDict", "spawn"]

    @staticmethod
    def toDict(_hx_map):
        # src/a8/PyOps.hx:53
        _hx_dict = dict()
        # src/a8/PyOps.hx:54
        # src/a8/PyOps.hx:54
        k = _hx_map.keys()
        while k.hasNext():
            k1 = k.next()
            # src/a8/PyOps.hx:55
            _hx_dict[k1] = _hx_map.get(k1)
        # src/a8/PyOps.hx:57
        return _hx_dict

    @staticmethod
    def spawn(fn):
        # src/a8/PyOps.hx:62
        th = python_lib_threading_Thread(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'target': fn})))
        # src/a8/PyOps.hx:63
        th.daemon = True
        # src/a8/PyOps.hx:64
        th.start()
        # src/a8/PyOps.hx:66
        return th
a8_PyOps._hx_class = a8_PyOps


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/KwArgs.hx:57
        this1 = python_Lib.anonAsDict(d)
        return this1
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["print", "println", "dictToAnon", "anonToDict", "anonAsDict", "dictAsAnon"]

    @staticmethod
    def print(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:40
        _hx_str = Std.string(v)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:42
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:43
        python_lib_Sys.stdout.flush()

    @staticmethod
    def println(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:50
        _hx_str = Std.string(v)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:52
        python_lib_Sys.stdout.buffer.write((("" + ("null" if _hx_str is None else _hx_str)) + "\n").encode("utf-8", "strict"))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:53
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:60
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:69
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:83
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None

    @staticmethod
    def dictAsAnon(d):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:95
        return _hx_AnonObject(d)
python_Lib._hx_class = python_Lib


class a8_GlobalScheduler:
    _hx_class_name = "a8.GlobalScheduler"
    __slots__ = ()
    _hx_statics = ["scheduler", "schedule", "submit"]

    @staticmethod
    def schedule(delayInSeconds,fn):
        # src/a8/GlobalScheduler.hx:22
        a8_GlobalScheduler.scheduler.enter(delayInSeconds,1.0,fn)

    @staticmethod
    def submit(fn):
        # src/a8/GlobalScheduler.hx:26
        a8_GlobalScheduler.schedule(0,fn)
a8_GlobalScheduler._hx_class = a8_GlobalScheduler


class a8_HaxeOps:
    _hx_class_name = "a8.HaxeOps"
    __slots__ = ()
    _hx_statics = ["asString", "toMap", "isDigit", "isAlpha", "isWhitespace", "isHaxeIdentifierFirstChar", "isHaxeIdentifierSecondChar"]

    @staticmethod
    def asString(_hx_bytes):
        # src/a8/HaxeOps.hx:12
        return _hx_bytes.getString(0,_hx_bytes.length)

    @staticmethod
    def toMap(iterable,keyFn):
        # src/a8/HaxeOps.hx:16
        _hx_map = haxe_ds_StringMap()
        # src/a8/HaxeOps.hx:17
        def _hx_local_0(a):
            # src/a8/HaxeOps.hx:17
            key = keyFn(a)
            _hx_map.h[key] = a
        Lambda.iter(iterable,_hx_local_0)
        # src/a8/HaxeOps.hx:18
        return _hx_map

    @staticmethod
    def isDigit(ch):
        # src/a8/HaxeOps.hx:23
        if ((len(ch) == 1) and ((ch >= "0"))):
            return (ch <= "0")
        else:
            return False

    @staticmethod
    def isAlpha(ch):
        # src/a8/HaxeOps.hx:29
        if (len(ch) == 1):
            if (not (((ch >= "A") and ((ch <= "Z"))))):
                if (ch >= "a"):
                    return (ch <= "z")
                else:
                    return False
            else:
                return True
        else:
            return False

    @staticmethod
    def isWhitespace(ch):
        # src/a8/HaxeOps.hx:37
        ch1 = ch
        # src/a8/HaxeOps.hx:39
        if ((((ch1 == " ") or ((ch1 == "\r"))) or ((ch1 == "\n"))) or ((ch1 == "\t"))):
            return True
        else:
            return False

    @staticmethod
    def isHaxeIdentifierFirstChar(ch):
        # src/a8/HaxeOps.hx:47
        if (len(ch) == 1):
            if (not a8_HaxeOps.isAlpha(ch)):
                return (ch == "_")
            else:
                return True
        else:
            return False

    @staticmethod
    def isHaxeIdentifierSecondChar(ch):
        # src/a8/HaxeOps.hx:56
        if (not a8_HaxeOps.isHaxeIdentifierFirstChar(ch)):
            return a8_HaxeOps.isDigit(ch)
        else:
            return True
a8_HaxeOps._hx_class = a8_HaxeOps


class a8_HaxeOps2:
    _hx_class_name = "a8.HaxeOps2"
    __slots__ = ()
    _hx_statics = ["asString", "toMap"]

    @staticmethod
    def asString(stack,indent = None):
        # src/a8/HaxeOps.hx:67
        if (indent is None):
            indent = ""
        # src/a8/HaxeOps.hx:71
        def _hx_local_0(si):
            # src/a8/HaxeOps.hx:71
            _this1 = Std.string(si)
            return (("null" if indent is None else indent) + ("null" if _this1 is None else _this1))
        # src/a8/HaxeOps.hx:70
        _this = list(map(_hx_local_0,stack))
        s = "\n".join([python_Boot.toString1(x1,'') for x1 in _this])
        # src/a8/HaxeOps.hx:73
        return s

    @staticmethod
    def toMap(iterable):
        # src/a8/HaxeOps.hx:77
        _hx_map = haxe_ds_StringMap()
        # src/a8/HaxeOps.hx:78
        # src/a8/HaxeOps.hx:78
        t = HxOverrides.iterator(iterable)
        while t.hasNext():
            t1 = t.next()
            # src/a8/HaxeOps.hx:79
            _hx_map.h[python_internal_ArrayImpl._get(t1, 0)] = python_internal_ArrayImpl._get(t1, 1)
        # src/a8/HaxeOps.hx:81
        return _hx_map
a8_HaxeOps2._hx_class = a8_HaxeOps2


class a8_Logger:
    _hx_class_name = "a8.Logger"
    __slots__ = ()
    _hx_statics = ["traceEnabled", "trace", "warn"]

    @staticmethod
    def trace(msg,posInfo = None):
        # src/a8/Logger.hx:12
        if a8_Logger.traceEnabled:
            haxe_Log.trace(("TRACE - " + ("null" if msg is None else msg)),posInfo)

    @staticmethod
    def warn(msg,posInfo = None):
        # src/a8/Logger.hx:18
        haxe_Log.trace(("WARN - " + ("null" if msg is None else msg)),posInfo)
a8_Logger._hx_class = a8_Logger


class a8_OptionOps:
    _hx_class_name = "a8.OptionOps"
    __slots__ = ()
    _hx_statics = ["toOption", "nonEmpty", "isEmpty", "getOrError", "getOrElse", "getOrElseFn", "get", "iter"]

    @staticmethod
    def toOption(a):
        # src/a8/OptionOps.hx:14
        if (a is None):
            return haxe_ds_Option._hx_None
        else:
            return haxe_ds_Option.Some(a)

    @staticmethod
    def nonEmpty(o):
        # src/a8/OptionOps.hx:20
        o1 = o.index
        # src/a8/OptionOps.hx:21
        if (o1 == 0):
            return True
        elif (o1 == 1):
            return False
        else:
            pass

    @staticmethod
    def isEmpty(o):
        # src/a8/OptionOps.hx:27
        return (not a8_OptionOps.nonEmpty(o))

    @staticmethod
    def getOrError(o,msg):
        # src/a8/OptionOps.hx:33
        o1 = o.index
        # src/a8/OptionOps.hx:34
        if (o1 == 0):
            # src/a8/OptionOps.hx:34
            i = o.params[0]
            return i
        elif (o1 == 1):
            raise _HxException(a8_Exception(msg,None,_hx_AnonObject({'fileName': "OptionOps.hx", 'lineNumber': 35, 'className': "a8.OptionOps", 'methodName': "getOrError"})))
        else:
            pass

    @staticmethod
    def getOrElse(o,_hx_def):
        # src/a8/OptionOps.hx:41
        o1 = o.index
        # src/a8/OptionOps.hx:42
        if (o1 == 0):
            # src/a8/OptionOps.hx:42
            i = o.params[0]
            return i
        elif (o1 == 1):
            return _hx_def
        else:
            pass

    @staticmethod
    def getOrElseFn(o,_hx_def):
        # src/a8/OptionOps.hx:49
        o1 = o.index
        # src/a8/OptionOps.hx:50
        if (o1 == 0):
            # src/a8/OptionOps.hx:50
            i = o.params[0]
            return i
        elif (o1 == 1):
            return _hx_def()
        else:
            pass

    @staticmethod
    def get(o):
        # src/a8/OptionOps.hx:56
        return a8_OptionOps.getOrError(o,"expected a Some")

    @staticmethod
    def iter(o,fn):
        # src/a8/OptionOps.hx:61
        o1 = o.index
        # src/a8/OptionOps.hx:62
        if (o1 == 0):
            # src/a8/OptionOps.hx:62
            a = o.params[0]
            fn(a)
        elif (o1 == 1):
            pass
        else:
            pass
        # src/a8/OptionOps.hx:60
        return
a8_OptionOps._hx_class = a8_OptionOps


class a8_PathOps:
    _hx_class_name = "a8.PathOps"
    __slots__ = ()
    _hx_statics = ["timestampStr", "path", "symlinkChain", "executablePath", "userHome", "absPath", "name", "programPath", "readText", "readLines", "makeDirectories", "readBytes", "exists", "isAbsolute", "files", "basename", "moveTo", "deleteFile", "entries", "isFile", "isDir", "realPathStr", "writeBytes", "writeText", "parent", "entry", "outputStream", "readProperties"]

    @staticmethod
    def timestampStr():
        # src/a8/PathOps.hx:14
        now = Date.now()
        # src/a8/PathOps.hx:16
        def _hx_local_0(i):
            # src/a8/PathOps.hx:16
            return StringTools.lpad(("" + Std.string(i)),"0",2)
        # src/a8/PathOps.hx:15
        pad = _hx_local_0
        # src/a8/PathOps.hx:18
        return ((((((Std.string(now.date.year) + HxOverrides.stringOrNull(pad((now.date.month - 1)))) + HxOverrides.stringOrNull(pad(now.date.day))) + "_") + HxOverrides.stringOrNull(pad(now.date.hour))) + HxOverrides.stringOrNull(pad(now.date.minute))) + HxOverrides.stringOrNull(pad(now.date.second)))

    @staticmethod
    def path(p):
        # src/a8/PathOps.hx:22
        return haxe_io_Path(p)

    @staticmethod
    def symlinkChain(p):
        # src/a8/PathOps.hx:26
        paths = []
        # src/a8/PathOps.hx:27
        impl = None
        def _hx_local_0(thePath):
            # src/a8/PathOps.hx:28
            # src/a8/PathOps.hx:28
            x = a8_PathOps.absPath(thePath)
            paths.append(x)
            # src/a8/PathOps.hx:29
            if python_lib_os_Path.islink(thePath.toString()):
                # src/a8/PathOps.hx:30
                relativeLink = a8_PyOs2.readlink(thePath.toString())
                # src/a8/PathOps.hx:31
                absoluteLink = (relativeLink if (python_lib_os_Path.isabs(relativeLink)) else python_lib_os_Path.join(a8_PathOps.parent(thePath).toString(),relativeLink))
                # src/a8/PathOps.hx:36
                p1 = a8_PathOps.path(absoluteLink)
                # src/a8/PathOps.hx:37
                impl(p1)
        impl = _hx_local_0
        impl1 = impl
        # src/a8/PathOps.hx:40
        impl1(p)
        # src/a8/PathOps.hx:41
        return paths

    @staticmethod
    def executablePath():
        # src/a8/PathOps.hx:49
        return a8_PlatformOps.instance.executablePath()

    @staticmethod
    def userHome():
        # src/a8/PathOps.hx:53
        return haxe_io_Path(Sys.environment().h.get("HOME",None))

    @staticmethod
    def absPath(p):
        # src/a8/PathOps.hx:57
        return a8_PlatformOps.instance.absPath(p)

    @staticmethod
    def name(p):
        # src/a8/PathOps.hx:62
        if (p.ext is None):
            return p.file
        else:
            return ((HxOverrides.stringOrNull(p.file) + ".") + HxOverrides.stringOrNull(p.ext))

    @staticmethod
    def programPath():
        # src/a8/PathOps.hx:74
        return haxe_io_Path(Sys.programPath())

    @staticmethod
    def readText(path):
        # src/a8/PathOps.hx:78
        return sys_io_File.getContent(path.toString())

    @staticmethod
    def readLines(path):
        # src/a8/PathOps.hx:82
        _this = a8_PathOps.readText(path)
        return _this.split("\n")

    @staticmethod
    def makeDirectories(path):
        # src/a8/PathOps.hx:86
        sys_FileSystem.createDirectory(path.toString())

    @staticmethod
    def readBytes(path):
        # src/a8/PathOps.hx:90
        return sys_io_File.getBytes(path.toString())

    @staticmethod
    def exists(path):
        # src/a8/PathOps.hx:94
        return sys_FileSystem.exists(path.toString())

    @staticmethod
    def isAbsolute(path):
        # src/a8/PathOps.hx:98
        return haxe_io_Path.isAbsolute(path.toString())

    @staticmethod
    def files(parentDir):
        # src/a8/PathOps.hx:103
        def _hx_local_1():
            # src/a8/PathOps.hx:105
            def _hx_local_0(e):
                # src/a8/PathOps.hx:105
                return a8_PathOps.isFile(e)
            # src/a8/PathOps.hx:103
            return list(filter(_hx_local_0,a8_PathOps.entries(parentDir)))
        return _hx_local_1()

    @staticmethod
    def basename(path):
        # src/a8/PathOps.hx:113
        suffix = ("" if ((path.ext is None)) else ("." + HxOverrides.stringOrNull(path.ext)))
        # src/a8/PathOps.hx:114
        return (HxOverrides.stringOrNull(path.file) + ("null" if suffix is None else suffix))

    @staticmethod
    def moveTo(source,target):
        # src/a8/PathOps.hx:118
        a8_PlatformOps.instance.moveTo(source,target)

    @staticmethod
    def deleteFile(source):
        # src/a8/PathOps.hx:122
        if a8_PathOps.exists(source):
            sys_FileSystem.deleteFile(source.toString())

    @staticmethod
    def entries(parentDir):
        # src/a8/PathOps.hx:128
        sep = ("" if (parentDir.backslash) else "/")
        # src/a8/PathOps.hx:130
        if a8_PathOps.exists(parentDir):
            # src/a8/PathOps.hx:131
            def _hx_local_1():
                # src/a8/PathOps.hx:134
                def _hx_local_0(e):
                    # src/a8/PathOps.hx:134
                    return haxe_io_Path(((HxOverrides.stringOrNull(parentDir.toString()) + ("null" if sep is None else sep)) + ("null" if e is None else e)))
                # src/a8/PathOps.hx:131
                return list(map(_hx_local_0,sys_FileSystem.readDirectory(a8_PathOps.realPathStr(parentDir))))
            return _hx_local_1()
        else:
            return []

    @staticmethod
    def isFile(path):
        # src/a8/PathOps.hx:141
        return a8_PlatformOps.instance.isFile(path)

    @staticmethod
    def isDir(path):
        # src/a8/PathOps.hx:145
        return sys_FileSystem.isDirectory(path.toString())

    @staticmethod
    def realPathStr(path):
        # src/a8/PathOps.hx:149
        return sys_FileSystem.fullPath(path.toString())

    @staticmethod
    def writeBytes(path,_hx_bytes):
        # src/a8/PathOps.hx:153
        sys_io_File.saveBytes(path.toString(),_hx_bytes)

    @staticmethod
    def writeText(path,text):
        # src/a8/PathOps.hx:157
        sys_io_File.saveContent(path.toString(),text)

    @staticmethod
    def parent(path):
        # src/a8/PathOps.hx:161
        _g = path.dir
        # src/a8/PathOps.hx:1
        if (_g is None):
            if a8_PathOps.isAbsolute(path):
                return None
            else:
                return haxe_io_Path(sys_FileSystem.fullPath("."))
        else:
            # src/a8/PathOps.hx:168
            d = _g
            # src/a8/PathOps.hx:169
            return haxe_io_Path(d)

    @staticmethod
    def entry(dir,name):
        # src/a8/PathOps.hx:174
        separator = ("" if (dir.backslash) else "/")
        # src/a8/PathOps.hx:175
        return haxe_io_Path(((HxOverrides.stringOrNull(dir.toString()) + ("null" if separator is None else separator)) + ("null" if name is None else name)))

    @staticmethod
    def outputStream(p):
        # src/a8/PathOps.hx:179
        return a8_StreamOps.fileOutputStream(a8_PathOps.realPathStr(p))

    @staticmethod
    def readProperties(p,failOnNotFound = None):
        # src/a8/PathOps.hx:183
        rf = a8_OptionOps.getOrElse(a8_OptionOps.toOption(failOnNotFound),False)
        # src/a8/PathOps.hx:184
        exists = a8_PathOps.exists(p)
        # src/a8/PathOps.hx:186
        if ((not exists) and (not rf)):
            return haxe_ds_StringMap()
        else:
            # src/a8/PathOps.hx:189
            def _hx_local_1():
                # src/a8/PathOps.hx:190
                def _hx_local_0(line):
                    # src/a8/PathOps.hx:191
                    a = line.split("=")
                    # src/a8/PathOps.hx:193
                    if (len(a) == 2):
                        # src/a8/PathOps.hx:194
                        this1 = [(a[0] if 0 < len(a) else None), (a[1] if 1 < len(a) else None)]
                        return [this1]
                    else:
                        return []
                # src/a8/PathOps.hx:189
                return a8_HaxeOps2.toMap(Lambda.flatMap(a8_PathOps.readLines(p),_hx_local_0))
            return _hx_local_1()
a8_PathOps._hx_class = a8_PathOps


class a8_AbstractPlatform:
    _hx_class_name = "a8.AbstractPlatform"
    __slots__ = ()
    _hx_methods = ["isFile", "spawn", "moveTo"]

    def isFile(self,path):
        # src/a8/Platform.hx:42
        e = sys_FileSystem.exists(path.toString())
        # src/a8/Platform.hx:43
        d = sys_FileSystem.isDirectory(path.toString())
        # src/a8/Platform.hx:44
        if e:
            return (not d)
        else:
            return False

    def spawn(self,threadName,fn):
        # src/a8/Platform.hx:48
        raise _HxException(a8_Exception("TODO ??? implement me",None,_hx_AnonObject({'fileName': "Platform.hx", 'lineNumber': 48, 'className': "a8.AbstractPlatform", 'methodName': "spawn"})))

    def moveTo(self,source,target):
        # src/a8/Platform.hx:52
        raise _HxException(a8_Exception("TODO ??? implement me",None,_hx_AnonObject({'fileName': "Platform.hx", 'lineNumber': 52, 'className': "a8.AbstractPlatform", 'methodName': "moveTo"})))

a8_AbstractPlatform._hx_class = a8_AbstractPlatform


class a8_Platform:
    _hx_class_name = "a8.Platform"
    __slots__ = ()
    _hx_methods = ["executablePath", "isFile", "spawn", "moveTo", "absPath"]
a8_Platform._hx_class = a8_Platform


class a8_PythonPlatform(a8_AbstractPlatform):
    _hx_class_name = "a8.PythonPlatform"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["absPath", "executablePath", "isFile", "spawn", "moveTo"]
    _hx_statics = []
    _hx_super = a8_AbstractPlatform


    def __init__(self):
        pass

    def absPath(self,path):
        # src/a8/Platform.hx:77
        return a8_PathOps.path(python_lib_os_Path.normpath(python_lib_os_Path.abspath(path.toString())))

    def executablePath(self):
        # src/a8/Platform.hx:81
        return haxe_io_Path(python_internal_ArrayImpl._get(python_lib_Sys.argv, 0))

    def isFile(self,path):
        # src/a8/Platform.hx:85
        return python_lib_os_Path.isfile(path.toString())

    def spawn(self,threadName,fn):
        # src/a8/Platform.hx:89
        th = python_lib_threading_Thread(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'target': fn})))
        # src/a8/Platform.hx:90
        th.start()

    def moveTo(self,source,target):
        # src/a8/Platform.hx:94
        a8_PyShutil2.move(source.toString(),target.toString())

a8_PythonPlatform._hx_class = a8_PythonPlatform


class a8_PlatformOps:
    _hx_class_name = "a8.PlatformOps"
    __slots__ = ()
    _hx_statics = ["instance"]
a8_PlatformOps._hx_class = a8_PlatformOps


class a8_StreamOps:
    _hx_class_name = "a8.StreamOps"
    __slots__ = ()
    _hx_statics = ["asInputStream", "asOutputStream", "fileOutputStream"]

    @staticmethod
    def asInputStream(fileIO):
        # src/a8/StreamOps.hx:12
        return a8_FileIOInputStream(fileIO)

    @staticmethod
    def asOutputStream(io):
        # src/a8/StreamOps.hx:16
        return a8_TextIOBaseOutputStream(io)

    @staticmethod
    def fileOutputStream(filename):
        # src/a8/StreamOps.hx:20
        return a8_StreamOps.asOutputStream(python_lib_Io.open(filename,"wt"))
a8_StreamOps._hx_class = a8_StreamOps


class a8_StreamOps2:
    _hx_class_name = "a8.StreamOps2"
    __slots__ = ()
    _hx_statics = ["asOutputStream"]

    @staticmethod
    def asOutputStream(output):
        # src/a8/StreamOps.hx:28
        return a8_OutputOutputStream(output)
a8_StreamOps2._hx_class = a8_StreamOps2


class a8_OutputStream:
    _hx_class_name = "a8.OutputStream"
    __slots__ = ()
    _hx_methods = ["write", "flush", "close"]
a8_OutputStream._hx_class = a8_OutputStream


class a8_InputStream:
    _hx_class_name = "a8.InputStream"
    __slots__ = ()
    _hx_methods = ["readLine", "close"]
a8_InputStream._hx_class = a8_InputStream


class a8_FileIOInputStream:
    _hx_class_name = "a8.FileIOInputStream"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["readLine", "close"]

    def __init__(self,delegate):
        # src/a8/Streams.hx:29
        self.delegate = None
        self.delegate = delegate

    def readLine(self):
        # src/a8/Streams.hx:32
        _hx_bytes = self.delegate.readline()
        # src/a8/Streams.hx:33
        line = _hx_bytes.decode()
        # src/a8/Streams.hx:36
        if StringTools.endsWith(line,"\n"):
            return HxString.substr(line,0,(len(line) - 1))
        else:
            return None

    def close(self):
        pass

a8_FileIOInputStream._hx_class = a8_FileIOInputStream


class a8_TextIOBaseOutputStream:
    _hx_class_name = "a8.TextIOBaseOutputStream"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]

    def __init__(self,delegate):
        # src/a8/Streams.hx:53
        self.delegate = None
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:56
        self.delegate.write(s)

    def flush(self):
        # src/a8/Streams.hx:60
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:64
        self.delegate.close()

a8_TextIOBaseOutputStream._hx_class = a8_TextIOBaseOutputStream


class a8_OutputOutputStream:
    _hx_class_name = "a8.OutputOutputStream"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]

    def __init__(self,delegate):
        # src/a8/Streams.hx:73
        self.delegate = None
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:76
        self.delegate.writeString(s)

    def flush(self):
        # src/a8/Streams.hx:80
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:84
        self.delegate.close()

a8_OutputOutputStream._hx_class = a8_OutputOutputStream


class a8_FileIOOutputStream:
    _hx_class_name = "a8.FileIOOutputStream"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]

    def __init__(self,delegate):
        # src/a8/Streams.hx:92
        self.delegate = None
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:95
        self.delegate.write(bytes(s,"utf-8"))

    def flush(self):
        # src/a8/Streams.hx:99
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:103
        self.delegate.close()

a8_FileIOOutputStream._hx_class = a8_FileIOOutputStream


class a8_TeeOutputStream:
    _hx_class_name = "a8.TeeOutputStream"
    __slots__ = ("outputs",)
    _hx_fields = ["outputs"]
    _hx_methods = ["write", "flush", "close"]

    def __init__(self,outputs):
        # src/a8/Streams.hx:115
        self.outputs = outputs

    def write(self,s):
        # src/a8/Streams.hx:120
        def _hx_local_0(os):
            # src/a8/Streams.hx:120
            os.write(s)
        # src/a8/Streams.hx:119
        Lambda.iter(self.outputs,_hx_local_0)

    def flush(self):
        # src/a8/Streams.hx:126
        def _hx_local_0(os):
            # src/a8/Streams.hx:126
            os.flush()
        # src/a8/Streams.hx:125
        Lambda.iter(self.outputs,_hx_local_0)

    def close(self):
        # src/a8/Streams.hx:132
        def _hx_local_0(os):
            # src/a8/Streams.hx:132
            os.close()
        # src/a8/Streams.hx:131
        Lambda.iter(self.outputs,_hx_local_0)

a8_TeeOutputStream._hx_class = a8_TeeOutputStream


class a8_Pipe:
    _hx_class_name = "a8.Pipe"
    __slots__ = ("input", "output", "firstIO", "byteCount", "replaceOutput")
    _hx_fields = ["input", "output", "firstIO", "byteCount", "replaceOutput"]
    _hx_methods = ["run"]

    def __init__(self,input,output,firstIO):
        # src/a8/Streams.hx:148
        self.replaceOutput = None
        # src/a8/Streams.hx:151
        self.input = input
        # src/a8/Streams.hx:152
        self.output = output
        # src/a8/Streams.hx:153
        self.firstIO = firstIO
        # src/a8/Streams.hx:154
        self.byteCount = 0

    def run(self):
        # src/a8/Streams.hx:160
        _gthis = self
        # src/a8/Streams.hx:162
        def _hx_local_1():
            # src/a8/Streams.hx:163
            first = True
            # src/a8/Streams.hx:164
            cont = True
            # src/a8/Streams.hx:165
            while cont:
                # src/a8/Streams.hx:166
                line = _gthis.input.readLine()
                # src/a8/Streams.hx:167
                if (_gthis.replaceOutput is not None):
                    # src/a8/Streams.hx:168
                    _gthis.output = _gthis.replaceOutput(_gthis.output)
                    # src/a8/Streams.hx:169
                    first = True
                # src/a8/Streams.hx:171
                if (line is None):
                    cont = False
                else:
                    # src/a8/Streams.hx:174
                    if first:
                        # src/a8/Streams.hx:175
                        _gthis.firstIO(_gthis.output)
                        # src/a8/Streams.hx:176
                        first = False
                    # src/a8/Streams.hx:178
                    _gthis.output.write(line)
                    # src/a8/Streams.hx:179
                    _gthis.output.write("\n")
                    # src/a8/Streams.hx:180
                    _gthis.output.flush()
                    # src/a8/Streams.hx:181
                    _gthis.byteCount = (_gthis.byteCount + ((len(line) + 1)))
            # src/a8/Streams.hx:184
            _gthis.output.close()
        impl = _hx_local_1
        # src/a8/Streams.hx:187
        a8_PlatformOps.instance.spawn("pipe",impl)

a8_Pipe._hx_class = a8_Pipe


class a8__Tuple2_Tuple2_Impl_:
    _hx_class_name = "a8._Tuple2.Tuple2_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "_1", "_2", "toString"]

    @staticmethod
    def _new(a,b):
        # src/a8/Tuple2.hx:6
        this1 = [a, b]
        return this1

    @staticmethod
    def _1(this1):
        # src/a8/Tuple2.hx:11
        return (this1[0] if 0 < len(this1) else None)

    @staticmethod
    def _2(this1):
        # src/a8/Tuple2.hx:15
        return (this1[1] if 1 < len(this1) else None)

    @staticmethod
    def toString(this1):
        # src/a8/Tuple2.hx:19
        return haxe_format_JsonPrinter.print(this1,None,None)
a8__Tuple2_Tuple2_Impl_._hx_class = a8__Tuple2_Tuple2_Impl_

class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, [v])
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, list())
haxe_ds_Option._hx_class = haxe_ds_Option


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent", "getBytes", "saveBytes"]

    @staticmethod
    def getContent(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:32
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:33
        content = f.read(-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:34
        f.close()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:35
        return content

    @staticmethod
    def saveContent(path,content):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:39
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:40
        f.write(content)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:41
        f.close()

    @staticmethod
    def getBytes(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:45
        f = python_lib_Builtins.open(path,"rb",-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:46
        size = f.read(-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:47
        b = haxe_io_Bytes.ofData(size)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:48
        f.close()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:49
        return b

    @staticmethod
    def saveBytes(path,_hx_bytes):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:53
        f = python_lib_Builtins.open(path,"wb",-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:54
        f.write(_hx_bytes.b)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:55
        f.close()
sys_io_File._hx_class = sys_io_File


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["isAbsolute"]

    def __init__(self,path):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:68
        self.backslash = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:63
        self.ext = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:53
        self.file = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:43
        self.dir = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:77
        path1 = path
        _hx_local_0 = len(path1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:78
        if (_hx_local_0 == 1):
            if (path1 == "."):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:79
                self.dir = path
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:80
                self.file = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:81
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:79
                self.dir = path
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:80
                self.file = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:81
                return
        else:
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:83
        c1 = path.rfind("/", 0, len(path))
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:84
        c2 = path.rfind("\\", 0, len(path))
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:85
        if (c1 < c2):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:86
            self.dir = HxString.substr(path,0,c2)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:87
            path = HxString.substr(path,(c2 + 1),None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:88
            self.backslash = True
        elif (c2 < c1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:90
            self.dir = HxString.substr(path,0,c1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:91
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:94
        cp = path.rfind(".", 0, len(path))
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:95
        if (cp != -1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:96
            self.ext = HxString.substr(path,(cp + 1),None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:97
            self.file = HxString.substr(path,0,cp)
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:99
            self.ext = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:100
            self.file = path

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:115
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def isAbsolute(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:302
        if StringTools.startsWith(path,"/"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:303
        if ((("" if ((1 >= len(path))) else path[1])) == ":"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:304
        if StringTools.startsWith(path,"\\\\"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:305
        return False

haxe_io_Path._hx_class = haxe_io_Path


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:31
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:37
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:43
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:48
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:52
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:53
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:54
            check = s.find(_hx_str, startLeft, len(s))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:55
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:66
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:70
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:74
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:81
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:97
        if (startIndex < 0):
            startIndex = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:98
        if (endIndex is None):
            return s[startIndex:]
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:101
            if (endIndex < 0):
                endIndex = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:102
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:113
        if (_hx_len is None):
            return s[startIndex:]
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:116
            if (_hx_len == 0):
                return ""
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:117
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class a8_UserConfig:
    _hx_class_name = "a8.UserConfig"
    __slots__ = ()
    _hx_statics = ["sbtCredentials", "versions"]
a8_UserConfig._hx_class = a8_UserConfig


class a8_launcher_CommandLineProcessor:
    _hx_class_name = "a8.launcher.CommandLineProcessor"
    __slots__ = ("lazy_argDefs", "argDefs")
    _hx_fields = ["lazy_argDefs", "argDefs"]
    _hx_methods = ["apply", "get_argDefs"]

    def __init__(self):
        # src/a8/launcher/CommandLineProcessor.hx:9
        self.argDefs = None
        self.lazy_argDefs = None
        def _hx_local_5():
            def _hx_local_4():
                # src/a8/launcher/CommandLineProcessor.hx:14
                def _hx_local_0(config,args):
                    # src/a8/launcher/CommandLineProcessor.hx:14
                    Reflect.setField(config,"explicitVersion",args)
                # src/a8/launcher/CommandLineProcessor.hx:20
                def _hx_local_1(config1,args1):
                    # src/a8/launcher/CommandLineProcessor.hx:20
                    Reflect.setField(config1,"quiet",a8_OptionOps.isEmpty(args1))
                # src/a8/launcher/CommandLineProcessor.hx:26
                def _hx_local_2(config2,args2):
                    # src/a8/launcher/CommandLineProcessor.hx:26
                    Reflect.setField(config2,"resolveOnly",a8_OptionOps.nonEmpty(args2))
                # src/a8/launcher/CommandLineProcessor.hx:32
                def _hx_local_3(config3,args3):
                    # src/a8/launcher/CommandLineProcessor.hx:32
                    Reflect.setField(config3,"showHelp",a8_OptionOps.nonEmpty(args3))
                # src/a8/launcher/CommandLineProcessor.hx:9
                return [_hx_AnonObject({'name': "--l-version", 'parmCount': 1, 'apply': _hx_local_0}), _hx_AnonObject({'name': "--l-verbose", 'parmCount': 0, 'apply': _hx_local_1}), _hx_AnonObject({'name': "--l-resolveOnly", 'parmCount': 0, 'apply': _hx_local_2}), _hx_AnonObject({'name': "--l-help", 'parmCount': 0, 'apply': _hx_local_3})]
            return _hx_local_4()
        self.lazy_argDefs = tink_core__Lazy_LazyFunc(_hx_local_5)

    def apply(self,initialConfig):
        # src/a8/launcher/CommandLineProcessor.hx:40
        config = Reflect.copy(initialConfig)
        # src/a8/launcher/CommandLineProcessor.hx:42
        newArgs = []
        # src/a8/launcher/CommandLineProcessor.hx:43
        Reflect.setField(config,"resolvedCommandLineArgs",newArgs)
        # src/a8/launcher/CommandLineProcessor.hx:44
        temp = list(Reflect.field(initialConfig,"rawCommandLineArgs"))
        # src/a8/launcher/CommandLineProcessor.hx:47
        temp.reverse()
        # src/a8/launcher/CommandLineProcessor.hx:48
        if (len(temp) != 0):
            temp.pop()
        # src/a8/launcher/CommandLineProcessor.hx:50
        while (len(temp) > 0):
            # src/a8/launcher/CommandLineProcessor.hx:51
            a = [(None if ((len(temp) == 0)) else temp.pop())]
            # src/a8/launcher/CommandLineProcessor.hx:52
            def _hx_local_1(a1):
                # src/a8/launcher/CommandLineProcessor.hx:52
                def _hx_local_0(ad):
                    # src/a8/launcher/CommandLineProcessor.hx:52
                    return (ad.name == (a1[0] if 0 < len(a1) else None))
                return _hx_local_0
            argDef = Lambda.find(self.get_argDefs(),_hx_local_1(a))
            # src/a8/launcher/CommandLineProcessor.hx:53
            if (argDef is None):
                # src/a8/launcher/CommandLineProcessor.hx:54
                if StringTools.startsWith((a[0] if 0 < len(a) else None),"--l-"):
                    raise _HxException(a8_Exception(("don't know how to handle arg -- " + HxOverrides.stringOrNull((a[0] if 0 < len(a) else None))),None,_hx_AnonObject({'fileName': "CommandLineProcessor.hx", 'lineNumber': 55, 'className': "a8.launcher.CommandLineProcessor", 'methodName': "apply"})))
                # src/a8/launcher/CommandLineProcessor.hx:57
                newArgs.append((a[0] if 0 < len(a) else None))
            else:
                # src/a8/launcher/CommandLineProcessor.hx:59
                parms = None
                # src/a8/launcher/CommandLineProcessor.hx:60
                if (argDef.parmCount == 0):
                    parms = haxe_ds_Option.Some(argDef.name)
                elif (argDef.parmCount == 1):
                    parms = haxe_ds_Option.Some((None if ((len(temp) == 0)) else temp.pop()))
                else:
                    raise _HxException(a8_Exception("can only handle parmCount of 0 or 1",None,_hx_AnonObject({'fileName': "CommandLineProcessor.hx", 'lineNumber': 62, 'className': "a8.launcher.CommandLineProcessor", 'methodName': "apply"})))
                # src/a8/launcher/CommandLineProcessor.hx:63
                argDef.apply(config,parms)
                # src/a8/launcher/CommandLineProcessor.hx:64
                Reflect.setField(argDef,"processed",True)
        # src/a8/launcher/CommandLineProcessor.hx:70
        def _hx_local_2(ad1):
            # src/a8/launcher/CommandLineProcessor.hx:70
            if (not Reflect.field(ad1,"processed")):
                ad1.apply(config,haxe_ds_Option._hx_None)
        # src/a8/launcher/CommandLineProcessor.hx:69
        Lambda.iter(self.get_argDefs(),_hx_local_2)
        # src/a8/launcher/CommandLineProcessor.hx:77
        return config

    def get_argDefs(self):
        # src/a8/launcher/CommandLineProcessor.hx:9
        return self.lazy_argDefs.get()

a8_launcher_CommandLineProcessor._hx_class = a8_launcher_CommandLineProcessor


class a8_launcher_Launcher:
    _hx_class_name = "a8.launcher.Launcher"
    __slots__ = ("lazy_logArchivesDir", "lazy_logsDir", "lazy_installDir", "lazy_a8VersionsCache", "config", "appName", "initialArgs", "a8VersionsCache", "installDir", "logsDir", "logArchivesDir", "pipedStdout", "pipedStderr", "logRollers")
    _hx_fields = ["lazy_logArchivesDir", "lazy_logsDir", "lazy_installDir", "lazy_a8VersionsCache", "config", "appName", "initialArgs", "a8VersionsCache", "installDir", "logsDir", "logArchivesDir", "pipedStdout", "pipedStderr", "logRollers"]
    _hx_methods = ["logTrace", "logWarn", "_log", "archiveOldLogs", "archiveLogFiles", "resolveStandardArgs", "resolveJvmCliLaunchArgs", "resolveJvmLaunchArgs", "runAndWait", "initializeLogRollers", "get_a8VersionsCache", "get_installDir", "get_logsDir", "get_logArchivesDir"]
    _hx_statics = ["initDirectory"]

    def __init__(self,config,appName,initialArgs):
        # src/a8/launcher/Launcher.hx:34
        self.logRollers = None
        # src/a8/launcher/Launcher.hx:33
        self.pipedStderr = None
        # src/a8/launcher/Launcher.hx:32
        self.pipedStdout = None
        # src/a8/launcher/Launcher.hx:30
        self.logArchivesDir = None
        # src/a8/launcher/Launcher.hx:29
        self.logsDir = None
        # src/a8/launcher/Launcher.hx:28
        self.installDir = None
        # src/a8/launcher/Launcher.hx:25
        self.a8VersionsCache = None
        # src/a8/launcher/Launcher.hx:22
        self.initialArgs = None
        # src/a8/launcher/Launcher.hx:20
        self.appName = None
        # src/a8/launcher/Launcher.hx:19
        self.config = None
        # src/a8/launcher/Launcher.hx:25
        self.lazy_a8VersionsCache = None
        # src/a8/launcher/Launcher.hx:28
        self.lazy_installDir = None
        # src/a8/launcher/Launcher.hx:29
        self.lazy_logsDir = None
        # src/a8/launcher/Launcher.hx:30
        self.lazy_logArchivesDir = None
        # ?:1
        _gthis = self
        # src/a8/launcher/Launcher.hx:30
        def _hx_local_0():
            # src/a8/launcher/Launcher.hx:30
            return a8_launcher_Launcher.initDirectory("archives",None,_gthis.get_logsDir(),Reflect.field(_gthis.config,"logFiles"))
        self.lazy_logArchivesDir = tink_core__Lazy_LazyFunc(_hx_local_0)
        # src/a8/launcher/Launcher.hx:29
        def _hx_local_1():
            # src/a8/launcher/Launcher.hx:29
            return a8_launcher_Launcher.initDirectory(Reflect.field(config,"logsDir"),"logs",_gthis.get_installDir())
        self.lazy_logsDir = tink_core__Lazy_LazyFunc(_hx_local_1)
        # src/a8/launcher/Launcher.hx:28
        def _hx_local_2():
            # src/a8/launcher/Launcher.hx:28
            return a8_launcher_Launcher.initDirectory(Reflect.field(config,"installDir"),None,a8_PathOps.path(python_lib_Os.getcwd()))
        self.lazy_installDir = tink_core__Lazy_LazyFunc(_hx_local_2)
        # src/a8/launcher/Launcher.hx:25
        def _hx_local_3():
            # src/a8/launcher/Launcher.hx:25
            return a8_launcher_Launcher.initDirectory(".a8/versions/cache",None,a8_PathOps.userHome())
        self.lazy_a8VersionsCache = tink_core__Lazy_LazyFunc(_hx_local_3)
        # src/a8/launcher/Launcher.hx:19
        self.config = config
        # src/a8/launcher/Launcher.hx:20
        self.appName = appName
        # src/a8/launcher/Launcher.hx:22
        self.initialArgs = initialArgs

    def logTrace(self,msg,posInfo = None):
        # src/a8/launcher/Launcher.hx:58
        if (not Reflect.field(self.config,"quiet")):
            if (self.pipedStdout is not None):
                self.pipedStdout.log(("TRACE - " + ("null" if msg is None else msg)))
            else:
                a8_Logger.trace(msg,posInfo)

    def logWarn(self,msg,posInfo = None):
        # src/a8/launcher/Launcher.hx:68
        if (self.pipedStderr is not None):
            self.pipedStderr.log(("WARN - " + ("null" if msg is None else msg)))
        else:
            a8_Logger.warn(msg,posInfo)

    def _log(self,msg,pipe):
        pass

    def archiveOldLogs(self):
        # src/a8/launcher/Launcher.hx:80
        prefix = (HxOverrides.stringOrNull(self.appName) + ".")
        # src/a8/launcher/Launcher.hx:81
        suffix1 = ".details"
        # src/a8/launcher/Launcher.hx:82
        suffix2 = ".errors"
        # src/a8/launcher/Launcher.hx:87
        def _hx_local_0(f):
            # src/a8/launcher/Launcher.hx:88
            filename = a8_PathOps.basename(f)
            # src/a8/launcher/Launcher.hx:89
            if StringTools.startsWith(filename,prefix):
                if (not StringTools.endsWith(filename,suffix1)):
                    return StringTools.endsWith(filename,suffix2)
                else:
                    return True
            else:
                return False
        # src/a8/launcher/Launcher.hx:84
        filesToArchive = list(filter(_hx_local_0,a8_PathOps.files(self.get_logsDir())))
        # src/a8/launcher/Launcher.hx:94
        self.archiveLogFiles(filesToArchive)

    def archiveLogFiles(self,files):
        # src/a8/launcher/Launcher.hx:98
        _gthis = self
        # src/a8/launcher/Launcher.hx:102
        def _hx_local_0(f):
            # src/a8/launcher/Launcher.hx:103
            target = a8_PathOps.entry(_gthis.get_logArchivesDir(),a8_PathOps.basename(f))
            # src/a8/launcher/Launcher.hx:104
            a8_PathOps.deleteFile(target)
            # src/a8/launcher/Launcher.hx:105
            a8_PathOps.moveTo(f,target)
            # src/a8/launcher/Launcher.hx:106
            return target
        # src/a8/launcher/Launcher.hx:100
        archivedFiles = list(map(_hx_local_0,files))
        # src/a8/launcher/Launcher.hx:109
        self.logTrace(("archiving log files -- " + Std.string(archivedFiles)),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 109, 'className': "a8.launcher.Launcher", 'methodName': "archiveLogFiles"}))
        # src/a8/launcher/Launcher.hx:112
        def _hx_local_2():
            # src/a8/launcher/Launcher.hx:113
            def _hx_local_1(f1):
                # src/a8/launcher/Launcher.hx:113
                python_lib_Subprocess.call(["gzip", "-f", a8_PathOps.realPathStr(f1)])
            # src/a8/launcher/Launcher.hx:112
            Lambda.iter(archivedFiles,_hx_local_1)
        # src/a8/launcher/Launcher.hx:111
        gzipFiles = _hx_local_2
        # src/a8/launcher/Launcher.hx:117
        a8_PyOps.spawn(gzipFiles)

    def resolveStandardArgs(self,stdlauncher):
        # src/a8/launcher/Launcher.hx:122
        launchConfig = stdlauncher
        # src/a8/launcher/Launcher.hx:123
        return _hx_AnonObject({'kind': "popen", 'args': stdlauncher.args, 'env': None, 'cwd': None, 'executable': None})

    def resolveJvmCliLaunchArgs(self,jvmlauncher):
        # src/a8/launcher/Launcher.hx:133
        versionFile = None
        # src/a8/launcher/Launcher.hx:134
        if a8_OptionOps.nonEmpty(Reflect.field(self.config,"explicitVersion")):
            versionFile = (HxOverrides.stringOrNull(a8_OptionOps.getOrError(Reflect.field(self.config,"explicitVersion"),"")) + ".json")
        elif (Reflect.field(jvmlauncher,"branch") is not None):
            versionFile = (("latest_" + HxOverrides.stringOrNull(Reflect.field(jvmlauncher,"branch"))) + ".json")
        elif (Reflect.field(jvmlauncher,"version") is not None):
            versionFile = (HxOverrides.stringOrNull(Reflect.field(jvmlauncher,"version")) + ".json")
        else:
            raise _HxException(a8_Exception("must provide a config with branch or version",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 141, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmCliLaunchArgs"})))
        # src/a8/launcher/Launcher.hx:143
        inventoryFile = a8_PathOps.entry(self.get_a8VersionsCache(),((((HxOverrides.stringOrNull(jvmlauncher.organization) + "/") + HxOverrides.stringOrNull(jvmlauncher.artifact)) + "/") + ("null" if versionFile is None else versionFile)))
        # src/a8/launcher/Launcher.hx:144
        a8_Logger.trace(("using inventory file - " + HxOverrides.stringOrNull(inventoryFile.toString())),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 144, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmCliLaunchArgs"}))
        # src/a8/launcher/Launcher.hx:145
        if ((not a8_PathOps.exists(inventoryFile)) or Reflect.field(self.config,"resolveOnly")):
            # src/a8/launcher/Launcher.hx:146
            _hx_exec = a8_Exec()
            # src/a8/launcher/Launcher.hx:149
            user = a8_UserConfig.sbtCredentials.h.get("user",None)
            # src/a8/launcher/Launcher.hx:150
            password = a8_UserConfig.sbtCredentials.h.get("password",None)
            # src/a8/launcher/Launcher.hx:152
            version = a8_OptionOps.getOrElse(a8_OptionOps.toOption(a8_UserConfig.versions.h.get("versions_version",None)),"1.0.0-20180425_1229_master")
            # src/a8/launcher/Launcher.hx:154
            repoUrl = a8_OptionOps.getOrElse(a8_OptionOps.toOption(a8_UserConfig.versions.h.get("versions_repo_url",None)),(((("https://" + ("null" if user is None else user)) + ":") + ("null" if password is None else password)) + "@accur8.artifactoryonline.com/accur8/all"))
            # src/a8/launcher/Launcher.hx:156
            def _hx_local_0():
                # src/a8/launcher/Launcher.hx:156
                _hx_exec.args = [(Std.string(a8_PathOps.parent(a8_PathOps.programPath())) + "/coursier"), "launch", "--repository", repoUrl, ("a8:a8-versions_2.12:" + ("null" if version is None else version)), "-M", "a8.versions.apps.Main", "--", "resolve", "--organization", jvmlauncher.organization, "--artifact", jvmlauncher.artifact]
                return _hx_exec.args
            args = _hx_local_0()
            # src/a8/launcher/Launcher.hx:157
            if a8_OptionOps.nonEmpty(Reflect.field(self.config,"explicitVersion")):
                # src/a8/launcher/Launcher.hx:158
                args.append("--version")
                # src/a8/launcher/Launcher.hx:159
                # src/a8/launcher/Launcher.hx:159
                x = a8_OptionOps.get(Reflect.field(self.config,"explicitVersion"))
                args.append(x)
            elif (Reflect.field(jvmlauncher,"branch") is not None):
                # src/a8/launcher/Launcher.hx:161
                args.append("--branch")
                # src/a8/launcher/Launcher.hx:162
                # src/a8/launcher/Launcher.hx:162
                x1 = Reflect.field(jvmlauncher,"branch")
                args.append(x1)
            elif (Reflect.field(jvmlauncher,"version") is not None):
                # src/a8/launcher/Launcher.hx:164
                args.append("--version")
                # src/a8/launcher/Launcher.hx:165
                # src/a8/launcher/Launcher.hx:165
                x2 = Reflect.field(jvmlauncher,"version")
                args.append(x2)
            # src/a8/launcher/Launcher.hx:167
            _hx_exec.execInline()
        # src/a8/launcher/Launcher.hx:169
        la = self.resolveJvmLaunchArgs(jvmlauncher,inventoryFile,False)
        # src/a8/launcher/Launcher.hx:171
        la.kind = "exec"
        # src/a8/launcher/Launcher.hx:172
        la.cwd = None
        # src/a8/launcher/Launcher.hx:174
        return la

    def resolveJvmLaunchArgs(self,jvmlauncher,installInventoryFile,createAppNameSymlink):
        # src/a8/launcher/Launcher.hx:180
        if (not a8_PathOps.exists(installInventoryFile)):
            raise _HxException(a8_Exception(("inventory file does not exist " + HxOverrides.stringOrNull(installInventoryFile.toString())),None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 181, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmLaunchArgs"})))
        # src/a8/launcher/Launcher.hx:184
        launchConfig = jvmlauncher
        # src/a8/launcher/Launcher.hx:186
        config = python_lib_Json.loads(a8_PathOps.readText(installInventoryFile),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        # src/a8/launcher/Launcher.hx:188
        launcherD = jvmlauncher
        # src/a8/launcher/Launcher.hx:190
        def _hx_local_0(e):
            # src/a8/launcher/Launcher.hx:191
            p = a8_PathOps.realPathStr(e)
            # src/a8/launcher/Launcher.hx:192
            if (StringTools.endsWith(p,".jar") or a8_PathOps.isDir(e)):
                # src/a8/launcher/Launcher.hx:193
                _this = config.classpath
                _this.append(p)
        Lambda.iter(a8_PathOps.entries(a8_PathOps.entry(self.get_installDir(),"lib")),_hx_local_0)
        # src/a8/launcher/Launcher.hx:196
        _this1 = config.classpath
        classpath = ":".join([python_Boot.toString1(x1,'') for x1 in _this1])
        # src/a8/launcher/Launcher.hx:198
        args = list()
        # src/a8/launcher/Launcher.hx:200
        if createAppNameSymlink:
            # src/a8/launcher/Launcher.hx:201
            symlinkName = ("j_" + HxOverrides.stringOrNull(self.appName))
            # src/a8/launcher/Launcher.hx:202
            symlinkParent = self.get_installDir()
            # src/a8/launcher/Launcher.hx:203
            javaAppNameSymLink = ((HxOverrides.stringOrNull(a8_PathOps.realPathStr(symlinkParent)) + "/") + ("null" if symlinkName is None else symlinkName))
            # src/a8/launcher/Launcher.hx:204
            javaAppNameSymLinkPath = a8_PathOps.path(javaAppNameSymLink)
            # src/a8/launcher/Launcher.hx:205
            cmd = None
            # src/a8/launcher/Launcher.hx:206
            if (not a8_PathOps.isFile(javaAppNameSymLinkPath)):
                # src/a8/launcher/Launcher.hx:207
                javaExec = a8_PyShutil2.which("java")
                # src/a8/launcher/Launcher.hx:208
                a8_Logger.trace(((("creating symlink " + ("null" if javaExec is None else javaExec)) + " --> ") + ("null" if javaAppNameSymLink is None else javaAppNameSymLink)),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 208, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmLaunchArgs"}))
                # src/a8/launcher/Launcher.hx:209
                a8_PyOs2.symlink(javaExec,javaAppNameSymLink)
                # src/a8/launcher/Launcher.hx:210
                if a8_PathOps.isFile(javaAppNameSymLinkPath):
                    cmd = ("./" + ("null" if symlinkName is None else symlinkName))
                else:
                    cmd = "java"
            else:
                cmd = ("./" + ("null" if symlinkName is None else symlinkName))
            # src/a8/launcher/Launcher.hx:218
            args.append(cmd)
        else:
            args.append("java")
        # src/a8/launcher/Launcher.hx:223
        # src/a8/launcher/Launcher.hx:223
        x = ("-DappName=" + HxOverrides.stringOrNull(self.appName))
        args.append(x)
        # src/a8/launcher/Launcher.hx:225
        if (Reflect.field(launcherD,"jvmArgs") is not None):
            # src/a8/launcher/Launcher.hx:227
            def _hx_local_1(jvmArg):
                # src/a8/launcher/Launcher.hx:227
                args.append(jvmArg)
            # src/a8/launcher/Launcher.hx:226
            Lambda.iter(Reflect.field(jvmlauncher,"jvmArgs"),_hx_local_1)
        # src/a8/launcher/Launcher.hx:232
        # src/a8/launcher/Launcher.hx:232
        x1 = jvmlauncher.mainClass
        args.append(x1)
        # src/a8/launcher/Launcher.hx:234
        if (Reflect.field(launcherD,"args") is not None):
            # src/a8/launcher/Launcher.hx:236
            def _hx_local_2(arg):
                # src/a8/launcher/Launcher.hx:236
                args.append(arg)
            # src/a8/launcher/Launcher.hx:235
            Lambda.iter(Reflect.field(jvmlauncher,"args"),_hx_local_2)
        # src/a8/launcher/Launcher.hx:240
        def _hx_local_3(arg1):
            # src/a8/launcher/Launcher.hx:240
            args.append(arg1)
        # src/a8/launcher/Launcher.hx:239
        Lambda.iter(Reflect.field(self.config,"resolvedCommandLineArgs"),_hx_local_3)
        # src/a8/launcher/Launcher.hx:243
        env = python_lib_Os.environ
        # src/a8/launcher/Launcher.hx:245
        newEnv = env.copy()
        # src/a8/launcher/Launcher.hx:249
        newEnv["CLASSPATH"] = classpath
        # src/a8/launcher/Launcher.hx:250
        newEnv["LAUNCHER_INSTALL_DIR"] = a8_PathOps.realPathStr(self.get_installDir())
        # src/a8/launcher/Launcher.hx:251
        newEnv["LAUNCHER_WORKING_DIR"] = python_lib_Os.getcwd()
        # src/a8/launcher/Launcher.hx:252
        newEnv["LAUNCHER_EXEC_PATH"] = a8_PathOps.realPathStr(a8_PathOps.executablePath())
        # src/a8/launcher/Launcher.hx:258
        tmp = a8_PathOps.realPathStr(self.get_installDir())
        # src/a8/launcher/Launcher.hx:254
        return _hx_AnonObject({'kind': "popen", 'args': args, 'env': newEnv, 'cwd': tmp, 'executable': (args[0] if 0 < len(args) else None)})

    def runAndWait(self):
        # src/a8/launcher/Launcher.hx:267
        self.logTrace(("installDir = " + Std.string(self.get_installDir())),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 267, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:268
        self.logTrace(("logsDir = " + Std.string(self.get_logsDir())),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 268, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:269
        self.logTrace(("logArchivesDir = " + Std.string(self.get_logArchivesDir())),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 269, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:271
        resolvedLaunch = None
        # src/a8/launcher/Launcher.hx:272
        if (self.config.kind == "jvm"):
            # src/a8/launcher/Launcher.hx:273
            installInventoryFile = a8_PathOps.entry(self.get_installDir(),"install-inventory.json")
            # src/a8/launcher/Launcher.hx:271
            resolvedLaunch = self.resolveJvmLaunchArgs(self.config,installInventoryFile,True)
        elif (self.config.kind == "jvm_cli"):
            resolvedLaunch = self.resolveJvmCliLaunchArgs(self.config)
        elif (self.config.kind == "args"):
            resolvedLaunch = self.resolveStandardArgs(self.config)
        else:
            raise _HxException(a8_Exception(("unable to resolve config kind " + HxOverrides.stringOrNull(self.config.kind)),None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 280, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
        # src/a8/launcher/Launcher.hx:282
        if Reflect.field(self.config,"resolveOnly"):
            return 0
        else:
            # src/a8/launcher/Launcher.hx:286
            if Reflect.field(self.config,"logFiles"):
                self.archiveOldLogs()
            # src/a8/launcher/Launcher.hx:290
            _g = resolvedLaunch.kind
            _g1 = _g
            _hx_local_0 = len(_g1)
            # src/a8/launcher/Launcher.hx:291
            if (_hx_local_0 == 4):
                if (_g1 == "exec"):
                    # src/a8/launcher/Launcher.hx:294
                    if (resolvedLaunch.cwd is not None):
                        python_lib_Os.chdir(resolvedLaunch.cwd)
                    # src/a8/launcher/Launcher.hx:296
                    a8_PyOs2.execvpe(resolvedLaunch.executable,resolvedLaunch.args,resolvedLaunch.env)
                    # src/a8/launcher/Launcher.hx:298
                    raise _HxException(a8_Exception("this never happens",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 298, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
                else:
                    raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 334, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
            elif (_hx_local_0 == 5):
                if (_g1 == "popen"):
                    # src/a8/launcher/Launcher.hx:301
                    self.logTrace(("running -- " + Std.string(resolvedLaunch.args)),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 301, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:303
                    popen = python_lib_subprocess_Popen(resolvedLaunch.args,None,resolvedLaunch.executable,None,python_lib_Subprocess.PIPE,python_lib_Subprocess.PIPE,None,False,False,resolvedLaunch.cwd,resolvedLaunch.env)
                    # src/a8/launcher/Launcher.hx:306
                    def _hx_local_1(out):
                        # src/a8/launcher/Launcher.hx:306
                        out.write((("first output at " + HxOverrides.stringOrNull(a8_PathOps.timestampStr())) + "\n"))
                    # src/a8/launcher/Launcher.hx:305
                    firstIO = _hx_local_1
                    # src/a8/launcher/Launcher.hx:309
                    timestampStr = a8_PathOps.timestampStr()
                    # src/a8/launcher/Launcher.hx:311
                    self.logTrace("setting up pipes",_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 311, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:312
                    self.pipedStdout = a8_launcher_PipedStream(self,a8_StreamOps.asInputStream(popen.stdout),python_lib_Sys.stdout,"details",firstIO,Reflect.field(self.config,"logFiles"),timestampStr)
                    # src/a8/launcher/Launcher.hx:313
                    self.pipedStderr = a8_launcher_PipedStream(self,a8_StreamOps.asInputStream(popen.stderr),python_lib_Sys.stderr,"errors",firstIO,Reflect.field(self.config,"logFiles"),timestampStr)
                    # src/a8/launcher/Launcher.hx:315
                    self.pipedStdout.start()
                    # src/a8/launcher/Launcher.hx:316
                    self.pipedStderr.start()
                    # src/a8/launcher/Launcher.hx:320
                    self.logTrace("initializeLogRollers",_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 320, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:321
                    self.initializeLogRollers()
                    # src/a8/launcher/Launcher.hx:322
                    self.logTrace("initializeLogRollers complete",_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 322, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:325
                    popen.wait()
                    # src/a8/launcher/Launcher.hx:328
                    self.pipedStdout.close()
                    # src/a8/launcher/Launcher.hx:329
                    self.pipedStdout.close()
                    # src/a8/launcher/Launcher.hx:331
                    return popen.returncode
                else:
                    raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 334, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
            else:
                raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 334, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))

    def initializeLogRollers(self):
        # src/a8/launcher/Launcher.hx:340
        _gthis = self
        # src/a8/launcher/Launcher.hx:344
        def _hx_local_0(lr):
            # src/a8/launcher/Launcher.hx:344
            return a8_launcher_LogRollerOps.fromConfig(lr,_gthis)
        # src/a8/launcher/Launcher.hx:341
        self.logRollers = list(map(_hx_local_0,Reflect.field(self.config,"logRollers")))
        # src/a8/launcher/Launcher.hx:345
        def _hx_local_1(i):
            # src/a8/launcher/Launcher.hx:345
            i.init()
            return
        Lambda.iter(self.logRollers,_hx_local_1)

    def get_a8VersionsCache(self):
        # src/a8/launcher/Launcher.hx:25
        return self.lazy_a8VersionsCache.get()

    def get_installDir(self):
        # src/a8/launcher/Launcher.hx:28
        return self.lazy_installDir.get()

    def get_logsDir(self):
        # src/a8/launcher/Launcher.hx:29
        return self.lazy_logsDir.get()

    def get_logArchivesDir(self):
        # src/a8/launcher/Launcher.hx:30
        return self.lazy_logArchivesDir.get()

    @staticmethod
    def initDirectory(configEntry,secondEntry,basePath,makeDirectory = None):
        # src/a8/launcher/Launcher.hx:39
        entry = (configEntry if ((configEntry is not None)) else secondEntry)
        # src/a8/launcher/Launcher.hx:40
        d = None
        # src/a8/launcher/Launcher.hx:41
        if (entry is None):
            d = basePath
        else:
            # src/a8/launcher/Launcher.hx:44
            asPath = a8_PathOps.path(entry)
            # src/a8/launcher/Launcher.hx:45
            if a8_PathOps.isAbsolute(asPath):
                d = asPath
            else:
                d = a8_PathOps.entry(basePath,entry)
        # src/a8/launcher/Launcher.hx:51
        if (makeDirectory and (not a8_PathOps.exists(d))):
            a8_PathOps.makeDirectories(d)
        # src/a8/launcher/Launcher.hx:54
        return d

a8_launcher_Launcher._hx_class = a8_launcher_Launcher


class a8_launcher_LogRollerOps:
    _hx_class_name = "a8.launcher.LogRollerOps"
    __slots__ = ()
    _hx_statics = ["fromConfig", "scheduleAtMidnight"]

    @staticmethod
    def fromConfig(c,launcher):
        # src/a8/launcher/LogRoller.hx:11
        if (c == "midnight"):
            return a8_launcher_MidnightLogRoller(launcher)
        else:
            return a8_launcher_UnknownLogRoller(c)

    @staticmethod
    def scheduleAtMidnight(fn):
        # src/a8/launcher/LogRoller.hx:18
        now = Date.now()
        # src/a8/launcher/LogRoller.hx:19
        midnight = a8_DateOps.midnight()
        # src/a8/launcher/LogRoller.hx:20
        millisToMidnight = ((python_lib_Time.mktime(midnight.date.timetuple()) * 1000) - ((python_lib_Time.mktime(now.date.timetuple()) * 1000)))
        # src/a8/launcher/LogRoller.hx:21
        secondsToMidnight = (millisToMidnight / 1000)
        # src/a8/launcher/LogRoller.hx:22
        a8_GlobalScheduler.schedule(secondsToMidnight,fn)
a8_launcher_LogRollerOps._hx_class = a8_launcher_LogRollerOps


class a8_launcher_LogRoller:
    _hx_class_name = "a8.launcher.LogRoller"
    __slots__ = ()
    _hx_methods = ["init", "onArchiveLogChanges"]
a8_launcher_LogRoller._hx_class = a8_launcher_LogRoller


class a8_launcher_AbstractLogRoller:
    _hx_class_name = "a8.launcher.AbstractLogRoller"
    __slots__ = ()
    _hx_methods = ["init", "onArchiveLogChanges"]

    def init(self):
        pass

    def onArchiveLogChanges(self):
        pass

a8_launcher_AbstractLogRoller._hx_class = a8_launcher_AbstractLogRoller


class a8_launcher_MidnightLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.MidnightLogRoller"
    __slots__ = ("launcher",)
    _hx_fields = ["launcher"]
    _hx_methods = ["init", "schedule", "doMidnightRollover"]
    _hx_statics = []
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,launcher):
        # src/a8/launcher/LogRoller.hx:42
        self.launcher = None
        self.launcher = launcher

    def init(self):
        # src/a8/launcher/LogRoller.hx:45
        self.schedule()

    def schedule(self):
        # src/a8/launcher/LogRoller.hx:49
        a8_launcher_LogRollerOps.scheduleAtMidnight(self.doMidnightRollover)

    def doMidnightRollover(self):
        # src/a8/launcher/LogRoller.hx:53
        self.launcher.logTrace("running doMidnightRollover",_hx_AnonObject({'fileName': "LogRoller.hx", 'lineNumber': 53, 'className': "a8.launcher.MidnightLogRoller", 'methodName': "doMidnightRollover"}))
        # src/a8/launcher/LogRoller.hx:54
        timestampStr = a8_PathOps.timestampStr()
        # src/a8/launcher/LogRoller.hx:56
        self.launcher.pipedStderr.rollover(timestampStr)
        # src/a8/launcher/LogRoller.hx:57
        self.launcher.pipedStdout.rollover(timestampStr)
        # src/a8/launcher/LogRoller.hx:58
        self.schedule()
        # src/a8/launcher/LogRoller.hx:59
        self.launcher.logTrace("doMidnightRollover complete",_hx_AnonObject({'fileName': "LogRoller.hx", 'lineNumber': 59, 'className': "a8.launcher.MidnightLogRoller", 'methodName': "doMidnightRollover"}))

a8_launcher_MidnightLogRoller._hx_class = a8_launcher_MidnightLogRoller


class a8_launcher_UnknownLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.UnknownLogRoller"
    __slots__ = ("config",)
    _hx_fields = ["config"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,config):
        # src/a8/launcher/LogRoller.hx:67
        self.config = None
        self.config = config

a8_launcher_UnknownLogRoller._hx_class = a8_launcher_UnknownLogRoller


class a8_launcher_CullOldArchivesLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.CullOldArchivesLogRoller"
    __slots__ = ("config", "launcher")
    _hx_fields = ["config", "launcher"]
    _hx_methods = ["init", "cullOldLogs"]
    _hx_statics = []
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,config,launcher):
        # src/a8/launcher/LogRoller.hx:78
        self.launcher = None
        # src/a8/launcher/LogRoller.hx:77
        self.config = None
        self.config = config
        # src/a8/launcher/LogRoller.hx:78
        self.launcher = launcher

    def init(self):
        # src/a8/launcher/LogRoller.hx:84
        a8_GlobalScheduler.submit(self.cullOldLogs)

    def cullOldLogs(self):
        # src/a8/launcher/LogRoller.hx:89
        fiveMinutes = 300
        # src/a8/launcher/LogRoller.hx:90
        a8_GlobalScheduler.schedule(fiveMinutes,self.cullOldLogs)

a8_launcher_CullOldArchivesLogRoller._hx_class = a8_launcher_CullOldArchivesLogRoller


class a8_launcher_Main:
    _hx_class_name = "a8.launcher.Main"
    __slots__ = ()
    _hx_statics = ["loadConfig", "helpString", "main"]

    @staticmethod
    def loadConfig():
        # src/a8/launcher/Main.hx:17
        execPath = a8_PathOps.executablePath()
        # src/a8/launcher/Main.hx:18
        appName = execPath.file
        # src/a8/launcher/Main.hx:20
        configExtensions = [".json", ".launcher.json"]
        # src/a8/launcher/Main.hx:25
        def _hx_local_2(l):
            # src/a8/launcher/Main.hx:25
            def _hx_local_1():
                # src/a8/launcher/Main.hx:25
                def _hx_local_0(e):
                    # src/a8/launcher/Main.hx:25
                    return a8_PathOps.entry(a8_PathOps.parent(l),(HxOverrides.stringOrNull(a8_PathOps.name(l)) + ("null" if e is None else e)))
                return list(map(_hx_local_0,configExtensions))
            return _hx_local_1()
        # src/a8/launcher/Main.hx:22
        possibleConfigFiles = Lambda.array(Lambda.flatMap(a8_PathOps.symlinkChain(execPath),_hx_local_2))
        # src/a8/launcher/Main.hx:33
        def _hx_local_3(f):
            # src/a8/launcher/Main.hx:33
            return a8_PathOps.exists(f)
        # src/a8/launcher/Main.hx:31
        configFile = Lambda.find(possibleConfigFiles,_hx_local_3)
        # src/a8/launcher/Main.hx:36
        config = python_lib_Json.loads(a8_PathOps.readText(configFile),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        # src/a8/launcher/Main.hx:38
        if (Reflect.field(config,"quiet") is None):
            Reflect.setField(config,"quiet",False)
        # src/a8/launcher/Main.hx:41
        if (Reflect.field(config,"logRollers") is None):
            Reflect.setField(config,"logRollers",[])
        # src/a8/launcher/Main.hx:44
        if (Reflect.field(config,"logFiles") is None):
            Reflect.setField(config,"logFiles",True)
        # src/a8/launcher/Main.hx:47
        if (config.kind == "jvm_cli"):
            # src/a8/launcher/Main.hx:48
            jvmLaunchConfig = config
            # src/a8/launcher/Main.hx:49
            Reflect.setField(config,"installDir",None)
            # src/a8/launcher/Main.hx:50
            Reflect.setField(config,"logFiles",False)
            # src/a8/launcher/Main.hx:51
            Reflect.setField(config,"logRollers",[])
        # src/a8/launcher/Main.hx:53
        if ((config.kind == "jvm") or ((config.kind == "jvm_cli"))):
            # src/a8/launcher/Main.hx:54
            jvmLaunchConfig1 = config
            # src/a8/launcher/Main.hx:55
            if (Reflect.field(jvmLaunchConfig1,"jvmArgs") is None):
                Reflect.setField(jvmLaunchConfig1,"jvmArgs",[])
            # src/a8/launcher/Main.hx:57
            if (Reflect.field(jvmLaunchConfig1,"args") is None):
                Reflect.setField(jvmLaunchConfig1,"args",[])
        # src/a8/launcher/Main.hx:62
        return config

    @staticmethod
    def helpString():
        # src/a8/launcher/Main.hx:69
        return "\nAccur8 Launcher Tool\n\n    The launchers job is to make sure the app is installed in the local cache and run the app it is configured to run.  \n\n    It will usually be installed (using Accur8 Recipes ie: a8-recipe install a8-scripts) at ~/tools-a8/packages/a8-scripts/a8-launcher.py\n\nConfiguration:\n    An app being run by the a8-launcher.py (or a copy/symbolic link of the launcher like a8-zoo) is configured by a .json file which will be alongside the command. \n    The base filename of the command needs to be the same as the json file. \n    So if you run the ‘a8-zoo’ launch command it will look for a ‘a8-zoo.json’ sitting alongside the a8-zoo command. \n    An example of a8-zoo.json will look like:\n        {\n            \"kind\": \"jvm_cli\",\n            \"mainClass\": \"a8.zoolander.Main\",\n            \"organization\": \"a8\",\n            \"artifact\": \"a8-zoolander_2.12\",\n            \"branch\": \"master\"\n        }\n\nUsage requirements:\n\n    Python 3.4+ (currently Python versions 3.7+ do not work)\n\n\nUsage:\n    --l-version <version> [<args>]\n        Runs the app with the specific version requested.\n\n    --l-resolveOnly\n        Does not run the app.\n        Sets up the inventory file(s) in a8VersionCache (~/a8/versions/cache) which contain app installer config and classpaths to jars.\n    \n    --l-help\n        Does not run the app.\n        Shows this help text.\n\n    [<args>]\n        Run the app passing through whatever arguments are passed in\n        \n"

    @staticmethod
    def main():
        # src/a8/launcher/Main.hx:114
        exitCode = 0
        # src/a8/launcher/Main.hx:116
        try:
            # src/a8/launcher/Main.hx:118
            execPath = a8_PathOps.executablePath()
            # src/a8/launcher/Main.hx:120
            appName = execPath.file
            # src/a8/launcher/Main.hx:122
            initialConfig = a8_launcher_Main.loadConfig()
            # src/a8/launcher/Main.hx:124
            args = list(python_lib_Sys.argv)
            # src/a8/launcher/Main.hx:125
            Reflect.setField(initialConfig,"rawCommandLineArgs",args)
            # src/a8/launcher/Main.hx:127
            clp = a8_launcher_CommandLineProcessor()
            # src/a8/launcher/Main.hx:128
            config = clp.apply(initialConfig)
            # src/a8/launcher/Main.hx:130
            a8_Logger.traceEnabled = (not Reflect.field(config,"quiet"))
            # src/a8/launcher/Main.hx:132
            if Reflect.field(config,"showHelp"):
                Sys.print(a8_launcher_Main.helpString())
            else:
                # src/a8/launcher/Main.hx:135
                launcher = a8_launcher_Launcher(config,appName,args)
                # src/a8/launcher/Main.hx:141
                exitCode = launcher.runAndWait()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # src/a8/launcher/Main.hx:145
            stack = haxe_CallStack.exceptionStack()
            # src/a8/launcher/Main.hx:146
            a8_Logger.warn(((("" + Std.string(e)) + "\n") + HxOverrides.stringOrNull(a8_HaxeOps2.asString(stack,"    "))),_hx_AnonObject({'fileName': "Main.hx", 'lineNumber': 146, 'className': "a8.launcher.Main", 'methodName': "main"}))
            # src/a8/launcher/Main.hx:147
            Sys.exit(1)
        # src/a8/launcher/Main.hx:150
        Sys.exit(exitCode)
a8_launcher_Main._hx_class = a8_launcher_Main


class a8_launcher_PipedStream:
    _hx_class_name = "a8.launcher.PipedStream"
    __slots__ = ("launcher", "processInput", "stdxxx", "fileExtension", "firstIO", "pipeToLogFiles", "initialTimestampStr", "pipe", "outputFile", "started")
    _hx_fields = ["launcher", "processInput", "stdxxx", "fileExtension", "firstIO", "pipeToLogFiles", "initialTimestampStr", "pipe", "outputFile", "started"]
    _hx_methods = ["start", "newOutputFile", "timestampedOutputFile", "log", "rollover", "close"]

    def __init__(self,launcher,processInput,stdxxx,fileExtension,firstIO,pipeToLogFiles,initialTimestampStr):
        # src/a8/launcher/PipedStream.hx:24
        self.outputFile = None
        # src/a8/launcher/PipedStream.hx:22
        self.pipe = None
        # src/a8/launcher/PipedStream.hx:20
        self.initialTimestampStr = None
        # src/a8/launcher/PipedStream.hx:19
        self.pipeToLogFiles = None
        # src/a8/launcher/PipedStream.hx:18
        self.firstIO = None
        # src/a8/launcher/PipedStream.hx:17
        self.fileExtension = None
        # src/a8/launcher/PipedStream.hx:16
        self.stdxxx = None
        # src/a8/launcher/PipedStream.hx:15
        self.processInput = None
        # src/a8/launcher/PipedStream.hx:14
        self.launcher = None
        # src/a8/launcher/PipedStream.hx:26
        self.started = False
        # src/a8/launcher/PipedStream.hx:14
        self.launcher = launcher
        # src/a8/launcher/PipedStream.hx:15
        self.processInput = processInput
        # src/a8/launcher/PipedStream.hx:16
        self.stdxxx = stdxxx
        # src/a8/launcher/PipedStream.hx:17
        self.fileExtension = fileExtension
        # src/a8/launcher/PipedStream.hx:18
        self.firstIO = firstIO
        # src/a8/launcher/PipedStream.hx:19
        self.pipeToLogFiles = pipeToLogFiles
        # src/a8/launcher/PipedStream.hx:20
        self.initialTimestampStr = initialTimestampStr
        # src/a8/launcher/PipedStream.hx:24
        self.outputFile = haxe_ds_Option._hx_None

    def start(self):
        # src/a8/launcher/PipedStream.hx:29
        if (not self.started):
            # src/a8/launcher/PipedStream.hx:30
            self.started = True
            # src/a8/launcher/PipedStream.hx:31
            if self.pipeToLogFiles:
                # src/a8/launcher/PipedStream.hx:32
                of = self.newOutputFile(self.initialTimestampStr)
                # src/a8/launcher/PipedStream.hx:33
                self.outputFile = haxe_ds_Option.Some(of)
                # src/a8/launcher/PipedStream.hx:34
                self.pipe = a8_Pipe(self.processInput,of.teedOut,self.firstIO)
                # src/a8/launcher/PipedStream.hx:35
                self.pipe.run()
            else:
                # src/a8/launcher/PipedStream.hx:37
                self.outputFile = haxe_ds_Option._hx_None
                # src/a8/launcher/PipedStream.hx:38
                self.pipe = a8_Pipe(self.processInput,a8_StreamOps.asOutputStream(self.stdxxx),self.firstIO)
                # src/a8/launcher/PipedStream.hx:39
                self.pipe.run()

    def newOutputFile(self,timesatmpStr):
        # src/a8/launcher/PipedStream.hx:45
        fileOutputPath = self.timestampedOutputFile(timesatmpStr)
        # src/a8/launcher/PipedStream.hx:46
        fileOut = a8_StreamOps.fileOutputStream(a8_PathOps.realPathStr(fileOutputPath))
        # src/a8/launcher/PipedStream.hx:47
        teeOut = a8_TeeOutputStream([fileOut, a8_StreamOps.asOutputStream(self.stdxxx)])
        # src/a8/launcher/PipedStream.hx:48
        return _hx_AnonObject({'path': fileOutputPath, 'outputStream': fileOut, 'teedOut': teeOut})

    def timestampedOutputFile(self,timestampStr):
        # src/a8/launcher/PipedStream.hx:56
        return a8_PathOps.entry(self.launcher.get_logsDir(),((((HxOverrides.stringOrNull(self.launcher.appName) + ".") + ("null" if timestampStr is None else timestampStr)) + ".") + HxOverrides.stringOrNull(self.fileExtension)))

    def log(self,msg):
        # src/a8/launcher/PipedStream.hx:60
        _g = self.outputFile
        if (_g.index == 0):
            # src/a8/launcher/PipedStream.hx:61
            of = _g.params[0]
            # src/a8/launcher/PipedStream.hx:62
            try:
                # src/a8/launcher/PipedStream.hx:63
                of.teedOut.write(msg)
                # src/a8/launcher/PipedStream.hx:64
                of.teedOut.write("\n")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                a8_Logger.warn(("error logging - " + Std.string(e)),_hx_AnonObject({'fileName': "PipedStream.hx", 'lineNumber': 66, 'className': "a8.launcher.PipedStream", 'methodName': "log"}))

    def rollover(self,timestampStr):
        # src/a8/launcher/PipedStream.hx:73
        _g = self.outputFile
        _g1 = _g.index
        # ?:1
        if (_g1 == 0):
            # src/a8/launcher/PipedStream.hx:74
            existingOutputFile = _g.params[0]
            # src/a8/launcher/PipedStream.hx:77
            newFileOutputPath = self.timestampedOutputFile(timestampStr)
            # src/a8/launcher/PipedStream.hx:78
            newfileOut = a8_PathOps.outputStream(newFileOutputPath)
            # src/a8/launcher/PipedStream.hx:79
            def _hx_local_0(oldOut):
                # src/a8/launcher/PipedStream.hx:80
                oldOut.close()
                # src/a8/launcher/PipedStream.hx:81
                return newfileOut
            self.pipe.replaceOutput = _hx_local_0
            # src/a8/launcher/PipedStream.hx:85
            oldFileoutputPath = existingOutputFile.path
            # src/a8/launcher/PipedStream.hx:86
            existingOutputFile.path = newFileOutputPath
            # src/a8/launcher/PipedStream.hx:87
            existingOutputFile.outputStream = newfileOut
            # src/a8/launcher/PipedStream.hx:88
            self.launcher.archiveLogFiles([oldFileoutputPath])
        elif (_g1 == 1):
            raise _HxException(a8_Exception("this should not happen since rollover should never get called when we don't have a Some for outputFile: Option<PipedStreamOutputFile>",None,_hx_AnonObject({'fileName': "PipedStream.hx", 'lineNumber': 92, 'className': "a8.launcher.PipedStream", 'methodName': "rollover"})))
        else:
            pass

    def close(self):
        # src/a8/launcher/PipedStream.hx:98
        def _hx_local_0(f):
            # src/a8/launcher/PipedStream.hx:98
            f.teedOut.close()
            return
        a8_OptionOps.iter(self.outputFile,_hx_local_0)

a8_launcher_PipedStream._hx_class = a8_launcher_PipedStream

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, [m])

    @staticmethod
    def FilePos(s,file,line):
        return haxe_StackItem("FilePos", 2, [s,file,line])

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, [classname,method])

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, [v])
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, list())
haxe_StackItem._hx_class = haxe_StackItem


class haxe_CallStack:
    _hx_class_name = "haxe.CallStack"
    __slots__ = ()
    _hx_statics = ["callStack", "exceptionStack"]

    @staticmethod
    def callStack():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:122
        stack = []
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:123
        infos = python_lib_Traceback.extract_stack()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:124
        if (len(infos) != 0):
            infos.pop()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:125
        infos.reverse()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:126
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:126
        _g = 0
        while (_g < len(infos)):
            elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:127
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:127
            x = haxe_StackItem.FilePos(None,elem[0],elem[1])
            stack.append(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:128
        return stack

    @staticmethod
    def exceptionStack():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:211
        stack = []
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:212
        exc = python_lib_Sys.exc_info()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:213
        if (exc[2] is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:215
            infos = python_lib_Traceback.extract_tb(exc[2])
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:216
            infos.reverse()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:217
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:217
            _g = 0
            while (_g < len(infos)):
                elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:218
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:218
                x = haxe_StackItem.FilePos(None,elem[0],elem[1])
                stack.append(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:220
        return stack
haxe_CallStack._hx_class = haxe_CallStack


class haxe__EntryPoint_Lock:
    _hx_class_name = "haxe._EntryPoint.Lock"
    __slots__ = ()

    def __init__(self):
        pass
haxe__EntryPoint_Lock._hx_class = haxe__EntryPoint_Lock


class haxe__EntryPoint_Mutex:
    _hx_class_name = "haxe._EntryPoint.Mutex"
    __slots__ = ()

    def __init__(self):
        pass
haxe__EntryPoint_Mutex._hx_class = haxe__EntryPoint_Mutex


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    __slots__ = ()
    _hx_statics = ["sleepLock", "mutex", "pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:93
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:95
            _this = haxe_EntryPoint.mutex
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:96
            _this1 = haxe_EntryPoint.pending
            f = (None if ((len(_this1) == 0)) else _this1.pop(0))
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:97
            _this2 = haxe_EntryPoint.mutex
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:101
            if (f is None):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:102
            f()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:104
        if ((haxe_MainLoop.pending is None) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:106
        return haxe_MainLoop.tick()

    @staticmethod
    def run():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:134
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:135
            nextTick = haxe_EntryPoint.processEvents()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:136
            if (nextTick < 0):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:138
            if (nextTick > 0):
                _this = haxe_EntryPoint.sleepLock
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["trace"]

    @staticmethod
    def trace(v,infos = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:105
        _hx_str = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:106
        if (infos is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:107
            _hx_str = ((((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber)) + ": ") + Std.string(v))
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:108
            if (Reflect.field(infos,"customParams") is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:109
                _this = Reflect.field(infos,"customParams")
                _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull((("," + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))))))
        else:
            _hx_str = v
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:114
        python_Lib.println(_hx_str)
haxe_Log._hx_class = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    __slots__ = ("f", "prev", "next", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "nextRun", "priority"]
    _hx_methods = ["delay", "stop"]

    def __init__(self,f,p):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:8
        self.next = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:7
        self.prev = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:13
        self.f = f
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:14
        self.priority = p
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:15
        self.nextRun = -1

    def delay(self,t):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:23
        self.nextRun = (-1 if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def stop(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:37
        if (self.f is None):
            return
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:38
        self.f = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:39
        self.nextRun = -1
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:40
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:44
        if (self.next is not None):
            self.next.prev = self.prev

haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    __slots__ = ()
    _hx_statics = ["pending", "add", "sortEvents", "tick"]
    threadCount = None

    @staticmethod
    def add(f,priority = 0):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:74
        if (priority is None):
            priority = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:75
        if (f is None):
            raise _HxException("Event function is null")
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:77
        e = haxe_MainEvent(f,priority)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:78
        head = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:79
        if (head is not None):
            head.prev = e
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:80
        e.next = head
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:81
        haxe_MainLoop.pending = e
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:82
        return e

    @staticmethod
    def sortEvents():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:89
        _hx_list = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:91
        if (_hx_list is None):
            return
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:93
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:94
        p = None
        q = None
        e = None
        tail = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:96
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:97
            p = _hx_list
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:98
            _hx_list = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:99
            tail = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:100
            nmerges = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:101
            while (p is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:102
                nmerges = (nmerges + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:103
                q = p
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:104
                psize = 0
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:105
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:105
                _g1 = 0
                _g = insize
                while (_g1 < _g):
                    i = _g1
                    _g1 = (_g1 + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:106
                    psize = (psize + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:107
                    q = q.next
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:108
                    if (q is None):
                        break
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:110
                qsize = insize
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:111
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:112
                    if (psize == 0):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:113
                        e = q
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:114
                        q = q.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:115
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:117
                        e = p
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:118
                        p = p.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:119
                        psize = (psize - 1)
                    else:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:121
                        e = q
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:122
                        q = q.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:123
                        qsize = (qsize - 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:125
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:129
                    e.prev = tail
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:130
                    tail = e
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:132
                p = q
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:134
            tail.next = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:135
            if (nmerges <= 1):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:137
            insize = (insize * 2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:139
        _hx_list.prev = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:140
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:147
        haxe_MainLoop.sortEvents()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:148
        e = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:149
        now = python_lib_Timeit.default_timer()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:150
        wait = 1e9
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:151
        while (e is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:152
            next = e.next
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:153
            wt = (e.nextRun - now)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:154
            if ((e.nextRun < 0) or ((wt <= 0))):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:155
                wait = 0
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:156
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:159
            e = next
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:161
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:46
        self.event = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:60
        _gthis = self
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:71
        dt = (time_ms / 1000)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:72
        def _hx_local_2():
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:73
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:73
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:74
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:76
        self.event.delay(dt)

    def stop(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:105
        if (self.event is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:106
            self.event.stop()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:107
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:137
        t = haxe_Timer(time_ms)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:138
        def _hx_local_0():
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:139
            t.stop()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:140
            f()
        t.run = _hx_local_0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:142
        return t

haxe_Timer._hx_class = haxe_Timer

class haxe_ds_Either(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Either"

    @staticmethod
    def Left(v):
        return haxe_ds_Either("Left", 0, [v])

    @staticmethod
    def Right(v):
        return haxe_ds_Either("Right", 1, [v])
haxe_ds_Either._hx_class = haxe_ds_Either


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:32
        self.h = dict()

    def get(self,key):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:40
        return self.h.get(key,None)

    def keys(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:55
        return python_HaxeIterator(iter(self.h.keys()))

haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:57
        self.replacer = replacer
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:58
        self.indent = space
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:59
        self.pretty = (space is not None)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:60
        self.nind = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:67
        self.buf = StringBuf()

    def write(self,k,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:80
        if (self.replacer is not None):
            v = self.replacer(k,v)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:81
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:81
        _g = Type.typeof(v)
        _g1 = _g.index
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:136
        if (_g1 == 0):
            self.buf.b.write("null")
        elif (_g1 == 1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:87
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (_g1 == 2):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:89
            v1 = None
            f = v
            if (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f))):
                v1 = v
            else:
                v1 = "null"
            _this1 = self.buf
            s1 = Std.string(v1)
            _this1.b.write(s1)
        elif (_g1 == 3):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:134
            _this2 = self.buf
            s2 = Std.string(v)
            _this2.b.write(s2)
        elif (_g1 == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (_g1 == 5):
            self.buf.b.write("\"<fun>\"")
        elif (_g1 == 6):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:92
            c = _g.params[0]
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:93
            if (c == str):
                self.quote(v)
            elif (c == list):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:96
                v2 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:97
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:97
                _this3 = self.buf
                s3 = "".join(map(chr,[91]))
                _this3.b.write(s3)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:99
                _hx_len = len(v2)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:100
                last = (_hx_len - 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:101
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:101
                _g11 = 0
                _g2 = _hx_len
                while (_g11 < _g2):
                    i = _g11
                    _g11 = (_g11 + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:103
                    if (i > 0):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:103
                        _this4 = self.buf
                        s4 = "".join(map(chr,[44]))
                        _this4.b.write(s4)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:104
                    if self.pretty:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:104
                        _this5 = self.buf
                        s5 = "".join(map(chr,[10]))
                        _this5.b.write(s5)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:105
                    if self.pretty:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:105
                        v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this6 = self.buf
                        s6 = Std.string(v3)
                        _this6.b.write(s6)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:106
                    self.write(i,(v2[i] if i >= 0 and i < len(v2) else None))
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:107
                    if (i == last):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:109
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:109
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:110
                        if self.pretty:
                            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:110
                            _this7 = self.buf
                            s7 = "".join(map(chr,[10]))
                            _this7.b.write(s7)
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:111
                        if self.pretty:
                            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:111
                            v4 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this8 = self.buf
                            s8 = Std.string(v4)
                            _this8.b.write(s8)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:114
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:114
                _this9 = self.buf
                s9 = "".join(map(chr,[93]))
                _this9.b.write(s9)
            elif (c == haxe_ds_StringMap):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:116
                v5 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:117
                o = _hx_AnonObject({})
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:118
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:118
                k1 = v5.keys()
                while k1.hasNext():
                    k2 = k1.next()
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:119
                    value = v5.h.get(k2,None)
                    setattr(o,(("_hx_" + k2) if ((k2 in python_Boot.keywords)) else (("_hx_" + k2) if (((((len(k2) > 2) and ((ord(k2[0]) == 95))) and ((ord(k2[1]) == 95))) and ((ord(k2[(len(k2) - 1)]) != 95)))) else k2)),value)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:120
                self.fieldsString(o,python_Boot.fields(o))
            elif (c == Date):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:122
                v6 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:123
                self.quote(v6.toString())
            else:
                self.fieldsString(v,python_Boot.fields(v))
        elif (_g1 == 7):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:131
            i1 = v.index
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:132
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:132
            _this10 = self.buf
            s10 = Std.string(i1)
            _this10.b.write(s10)
        elif (_g1 == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def fieldsString(self,v,fields):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:168
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:168
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:169
        _hx_len = len(fields)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:170
        last = (_hx_len - 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:171
        first = True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:172
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:172
        _g1 = 0
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:173
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:174
            value = Reflect.field(v,f)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:175
            if Reflect.isFunction(value):
                continue
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:176
            if first:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:176
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:176
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this1 = self.buf
                s1 = "".join(map(chr,[44]))
                _this1.b.write(s1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:177
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:177
                _this2 = self.buf
                s2 = "".join(map(chr,[10]))
                _this2.b.write(s2)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:178
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:178
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this3 = self.buf
                s3 = Std.string(v1)
                _this3.b.write(s3)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:179
            self.quote(f)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:180
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:180
            _this4 = self.buf
            s4 = "".join(map(chr,[58]))
            _this4.b.write(s4)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:181
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:181
                _this5 = self.buf
                s5 = "".join(map(chr,[32]))
                _this5.b.write(s5)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:182
            self.write(f,value)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:183
            if (i == last):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:185
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:185
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:186
                if self.pretty:
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:186
                    _this6 = self.buf
                    s6 = "".join(map(chr,[10]))
                    _this6.b.write(s6)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:187
                if self.pretty:
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:187
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this7 = self.buf
                    s7 = Std.string(v2)
                    _this7.b.write(s7)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:190
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:190
        _this8 = self.buf
        s8 = "".join(map(chr,[125]))
        _this8.b.write(s8)

    def quote(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:200
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:200
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:201
        i = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:202
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:203
            index = i
            i = (i + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:204
            if (c == -1):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:205
            c1 = c
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:211
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:217
                _this1 = self.buf
                s2 = "".join(map(chr,[c]))
                _this1.b.write(s2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:221
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:221
        _this2 = self.buf
        s3 = "".join(map(chr,[34]))
        _this2.b.write(s3)

    @staticmethod
    def print(o,replacer = None,space = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:45
        printer = haxe_format_JsonPrinter(replacer,space)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:46
        printer.write("",o)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:47
        return printer.buf.b.getvalue()

haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString"]
    _hx_statics = ["ofString", "ofData"]

    def __init__(self,length,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:34
        self.length = length
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:35
        self.b = b

    def getString(self,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:362
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:382
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    @staticmethod
    def ofString(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:516
        b = bytearray(s,"UTF-8")
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:517
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:561
        return haxe_io_Bytes(len(b),b)

haxe_io_Bytes._hx_class = haxe_io_Bytes


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:60
        self.b = list()

    def getBytes(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:207
        buf = bytearray(self.b)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:208
        _hx_bytes = haxe_io_Bytes(len(buf),buf)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:214
        self.b = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:215
        return _hx_bytes

haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:96
        self.bigEndian = b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:97
        return b

haxe_io_Input._hx_class = haxe_io_Input


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "close", "set_bigEndian", "writeFullBytes", "writeString"]

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:47
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:59
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:62
        b = s.b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:63
        k = _hx_len
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:64
        while (k > 0):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:74
            self.writeByte(b[pos])
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:76
            pos = (pos + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:77
            k = (k - 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:79
        return _hx_len

    def flush(self):
        pass

    def close(self):
        pass

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:97
        self.bigEndian = b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:98
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:123
        while (_hx_len > 0):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:124
            k = self.writeBytes(s,pos,_hx_len)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:125
            pos = (pos + k)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:126
            _hx_len = (_hx_len - k)

    def writeString(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:282
        b = haxe_io_Bytes.ofString(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:284
        self.writeFullBytes(b,0,b.length)

haxe_io_Output._hx_class = haxe_io_Output


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:40
        self.b = haxe_io_BytesBuffer()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:43
        self.set_bigEndian(False)

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:55
        _this = self.b.b
        _this.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:64
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:64
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b1 = _this.b
        b2 = buf.b
        _g1 = pos
        _g = (pos + _hx_len)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            _this1 = _this.b
            _this1.append(b2[i])
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:66
        return _hx_len

    def getBytes(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:137
        return self.b.getBytes()

haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Eof.hx:31
        return "Eof"

haxe_io_Eof._hx_class = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overglen = haxe_io_Error("Overglen", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())
haxe_io_Error._hx_class = haxe_io_Error


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:94
        if (o is None):
            return "null"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:96
        if isinstance(o,str):
            return o
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:98
        if (s is None):
            s = ""
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:99
        if (len(s) >= 5):
            return "<...>"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:101
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:104
        if isinstance(o,int):
            return str(o)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:108
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:120
        if isinstance(o,list):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:122
            o1 = o
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:124
            l = len(o1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:126
            st = "["
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:127
            s = (("null" if s is None else s) + "\t")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:128
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:128
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:129
                prefix = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:130
                if (i > 0):
                    prefix = ","
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:133
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:135
            st = (("null" if st is None else st) + "]")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:136
            return st
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:139
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:145
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:147
        if hasattr(o,"__class__"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:150
            if isinstance(o,_hx_AnonObject):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:152
                toStr = None
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:153
                try:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:155
                    fields = python_Boot.fields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:156
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:157
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:163
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:173
            if isinstance(o,Enum):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:175
                o2 = o
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:177
                l1 = len(o2.params)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:178
                hasParams = (l1 > 0)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:179
                if hasParams:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:180
                    paramsStr = ""
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:181
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:181
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:182
                        prefix1 = ""
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:183
                        if (i1 > 0):
                            prefix1 = ","
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:186
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:188
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:194
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:196
                    fields1 = python_Boot.getInstanceFields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:197
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:199
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:200
                    return toStr1
                else:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:202
                    fields2 = python_Boot.getClassFields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:203
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:204
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:205
                    return toStr2
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:209
            if (o == str):
                return "#String"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:213
            if (o == list):
                return "#Array"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:217
            if callable(o):
                return "function"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:220
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:226
            if hasattr(o,"__str__"):
                return o.__str__([])
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:230
            if hasattr(o,"__name__"):
                return o.__name__
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:233
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:245
        a = []
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:246
        if (o is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:247
            if hasattr(o,"_hx_fields"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:248
                fields = o._hx_fields
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:249
                return list(fields)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:251
            if isinstance(o,_hx_AnonObject):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:253
                d = o.__dict__
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:254
                keys = d.keys()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:255
                handler = python_Boot.unhandleKeywords
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:257
                for k in keys:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:258
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:262
                d1 = o.__dict__
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:263
                keys1 = d1.keys()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:264
                for k in keys1:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:265
                    a.append(k)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:269
        return a

    @staticmethod
    def simpleField(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:281
        if (field is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:283
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:284
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:288
        if (field is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:290
        field1 = field
        _hx_local_0 = len(field1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:295
        if (_hx_local_0 == 10):
            if (field1 == "charCodeAt"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:295
                    s1 = o
                    def _hx_local_1(a11):
                        return HxString.charCodeAt(s1,a11)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field1 == "lastIndexOf"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:297
                    s3 = o
                    def _hx_local_2(a15):
                        return HxString.lastIndexOf(s3,a15)
                    return _hx_local_2
                elif isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:315
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field1 == "toLowerCase"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:292
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field1 == "toUpperCase"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:293
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field1 == "substring"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:300
                    s6 = o
                    def _hx_local_6(a19):
                        return HxString.substring(s6,a19)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field1 == "copy"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:306
                    def _hx_local_7():
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:306
                        return list(o)
                    return _hx_local_7
            elif (field1 == "join"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:309
                    def _hx_local_8(sep):
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:309
                        return sep.join([python_Boot.toString1(x1,'') for x1 in o])
                    return _hx_local_8
            elif (field1 == "push"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:312
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field1 == "sort"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:320
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field1 == "shift"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:318
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field1 == "slice"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:319
                    x10 = o
                    def _hx_local_12(a16):
                        return python_internal_ArrayImpl.slice(x10,a16)
                    return _hx_local_12
            elif (field1 == "split"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:298
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field1 == "indexOf"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:296
                    s2 = o
                    def _hx_local_14(a13):
                        return HxString.indexOf(s2,a13)
                    return _hx_local_14
                elif isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:314
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field1 == "reverse"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:317
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field1 == "unshift"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:313
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field1 == "map"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:303
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field1 == "pop"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:311
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field1 == "iterator"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:307
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field1 == "toString"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:301
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:310
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field1 == "charAt"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:294
                    s = o
                    def _hx_local_23(a1):
                        return HxString.charAt(s,a1)
                    return _hx_local_23
            elif (field1 == "concat"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:305
                    a12 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a12,a2)
                    return _hx_local_24
            elif (field1 == "filter"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:304
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field1 == "insert"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:308
                    a3 = o
                    def _hx_local_26(a14,x2):
                        python_internal_ArrayImpl.insert(a3,a14,x2)
                    return _hx_local_26
            elif (field1 == "length"):
                if isinstance(o,str):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field1 == "remove"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:316
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field1 == "splice"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:321
                    x12 = o
                    def _hx_local_28(a17,a21):
                        return python_internal_ArrayImpl.splice(x12,a17,a21)
                    return _hx_local_28
            elif (field1 == "substr"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:299
                    s5 = o
                    def _hx_local_29(a18):
                        return HxString.substr(s5,a18)
                    return _hx_local_29
        else:
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:325
        field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:326
        if hasattr(o,field2):
            return getattr(o,field2)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:331
        f = (c._hx_fields if (hasattr(c,"_hx_fields")) else [])
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:332
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:335
        sc = python_Boot.getSuperClass(c)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:337
        if (sc is None):
            return f
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:341
            scArr = python_Boot.getInstanceFields(sc)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:342
            scMap = set(scArr)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:345
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:345
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:346
                if (not (f1 in scMap)):
                    scArr.append(f1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:351
            return scArr

    @staticmethod
    def getSuperClass(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:356
        if (c is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:359
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:360
            if hasattr(c,"_hx_super"):
                return c._hx_super
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:363
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:367
        return None

    @staticmethod
    def getClassFields(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:372
        if hasattr(c,"_hx_statics"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:373
            x = c._hx_statics
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:374
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:398
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:399
            real = HxString.substr(name,python_Boot.prefixLength,None)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:400
            if (real in python_Boot.keywords):
                return real
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:402
        return name
python_Boot._hx_class = python_Boot


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "iterator", "indexOf", "lastIndexOf", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:35
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:45
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:50
        _hx_len = len(a)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:51
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:55
        if (l < 0):
            l = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:56
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:56
        _g1 = l
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:57
            if (a[i] == x):
                return i
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:59
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:64
        _hx_len = len(a)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:65
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:69
        if (l > _hx_len):
            l = _hx_len
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:70
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:70
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:71
            if (a[l] == x):
                return l
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:73
        return -1

    @staticmethod
    def toString(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:84
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:89
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:94
        x.append(e)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:95
        return len(x)

    @staticmethod
    def unshift(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:100
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:105
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:106
            x.remove(e)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:107
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:115
        if (len(x) == 0):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:116
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:121
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:125
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:130
        if (pos < 0):
            pos = (len(x) + pos)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:131
        if (pos < 0):
            pos = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:132
        res = x[pos:(pos + _hx_len)]
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:133
        del x[pos:(pos + _hx_len)]
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:134
        return res

    @staticmethod
    def map(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:139
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:144
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:149
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:153
        a.reverse()

    @staticmethod
    def _get(x,idx):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:158
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:163
        l = len(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:164
        while (l < idx):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:165
            x.append(None)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:166
            l = (l + 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:168
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:173
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = Exception


    def __init__(self,val):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:28
        self.val = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:31
        message = str(val)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:32
        super().__init__(message)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:33
        self.val = val

_HxException._hx_class = _HxException


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:39
        if isinstance(x,list):
            return python_HaxeIterator(x.__iter__())
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:42
        return x.iterator()

    @staticmethod
    def eq(a,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:46
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:49
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:53
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def mapKwArgs(a,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:156
        a1 = python_Lib.dictAsAnon(python_Lib.anonToDict(a))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:157
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:157
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:158
            val = v.get(k1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:159
            if hasattr(a1,k1):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:160
                x = getattr(a1,k1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:161
                setattr(a1,val,x)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:162
                delattr(a1,k1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:165
        return a1
HxOverrides._hx_class = HxOverrides


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:33
        self.wasEof = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:36
        self.stream = s
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:37
        self.set_bigEndian(False)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:38
        self.wasEof = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:39
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")

python_io_NativeInput._hx_class = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian"]
python_io_IInput._hx_class = python_io_IInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
python_io_IFileInput._hx_class = python_io_IFileInput


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close", "flush"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:31
        self.stream = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:37
        self.set_bigEndian(False)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:38
        self.stream = stream
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:39
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def close(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:44
        self.stream.close()

    def flush(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:54
        self.stream.flush()

python_io_NativeOutput._hx_class = python_io_NativeOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]
python_io_IOutput._hx_class = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
python_io_IFileOutput._hx_class = python_io_IFileOutput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeTextInput.hx:39
        super().__init__(stream)
python_io_NativeTextInput._hx_class = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/FileTextInput.hx:32
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeTextOutput.hx:34
        super().__init__(stream)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeTextOutput.hx:35
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeTextOutput.hx:45
        self.stream.write("".join(map(chr,[c])))

python_io_NativeTextOutput._hx_class = python_io_NativeTextOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/FileTextOutput.hx:30
        super().__init__(stream)
python_io_FileTextOutput._hx_class = python_io_FileTextOutput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText"]

    @staticmethod
    def createFileInputFromText(t):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/IoTools.hx:39
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/IoTools.hx:47
        return sys_io_FileOutput(python_io_FileTextOutput(t))
python_io_IoTools._hx_class = python_io_IoTools


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian"]
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileInput.hx:37
        self.impl = impl

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileInput.hx:41
        return self.impl.set_bigEndian(b)

sys_io_FileInput._hx_class = sys_io_FileInput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:34
        self.impl = impl

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:46
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:50
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:54
        return self.impl.writeBytes(s,pos,_hx_len)

    def flush(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:58
        self.impl.flush()

    def close(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:62
        self.impl.close()

    def writeFullBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:70
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeString(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:114
        self.impl.writeString(s)

sys_io_FileOutput._hx_class = sys_io_FileOutput


class tink_core_Annex:
    _hx_class_name = "tink.core.Annex"
    __slots__ = ("target", "registry")
    _hx_fields = ["target", "registry"]

    def __init__(self,target):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Annex.hx:16
        self.target = target
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Annex.hx:17
        self.registry = haxe_ds_ObjectMap()

tink_core_Annex._hx_class = tink_core_Annex


class tink_core__Callback_Callback_Impl_:
    _hx_class_name = "tink.core._Callback.Callback_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "toFunction", "depth", "MAX_DEPTH", "invoke", "ignore", "fromNiladic", "fromMany", "defer"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:5
        this1 = f
        return this1

    @staticmethod
    def toFunction(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:9
        return this1

    @staticmethod
    def invoke(this1,data):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:14
        if (tink_core__Callback_Callback_Impl_.depth < 1000):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:15
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:15
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:16
            this1(data)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:17
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:17
            _hx_local_2 = tink_core__Callback_Callback_Impl_
            _hx_local_3 = _hx_local_2.depth
            _hx_local_2.depth = (_hx_local_3 - 1)
            _hx_local_3
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:19
            _e = this1
            def _hx_local_4(data1):
                tink_core__Callback_Callback_Impl_.invoke(_e,data1)
            f = _hx_local_4
            a1 = data
            def _hx_local_5():
                f(a1)
            tink_core__Callback_Callback_Impl_.defer(_hx_local_5)

    @staticmethod
    def ignore(cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:22
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:22
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:22
                tink_core__Callback_Callback_Impl_.invoke(cb,tink_core_Noise.Noise)
            return tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def fromNiladic(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:25
        def _hx_local_0(r):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:25
            f()
        this1 = _hx_local_0
        return this1

    @staticmethod
    def fromMany(callbacks):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:29
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:30
            _g = 0
            while (_g < len(callbacks)):
                callback = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                _g = (_g + 1)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:31
                tink_core__Callback_Callback_Impl_.invoke(callback,v)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:28
        return _hx_local_0

    @staticmethod
    def defer(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:47
        haxe_Timer.delay(f,0)
tink_core__Callback_Callback_Impl_._hx_class = tink_core__Callback_Callback_Impl_


class tink_core__Callback_LinkObject:
    _hx_class_name = "tink.core._Callback.LinkObject"
    __slots__ = ()
    _hx_methods = ["dissolve"]
tink_core__Callback_LinkObject._hx_class = tink_core__Callback_LinkObject


class tink_core__Callback_CallbackLink_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackLink_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "cancel", "dissolve", "toCallback", "fromFunction", "join", "fromMany"]

    @staticmethod
    def _new(link):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:59
        this1 = tink_core__Callback_SimpleLink(link)
        return this1

    @staticmethod
    def cancel(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:63
        if (this1 is not None):
            this1.dissolve()

    @staticmethod
    def dissolve(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:66
        if (this1 is not None):
            this1.dissolve()

    @staticmethod
    def toCallback(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:69
        def _hx_local_0(_):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:69
            this1.dissolve()
        return _hx_local_0

    @staticmethod
    def fromFunction(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:72
        this1 = tink_core__Callback_SimpleLink(f)
        return this1

    @staticmethod
    def join(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:75
        return tink_core__Callback_LinkPair(a,b)

    @staticmethod
    def fromMany(callbacks):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:78
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:78
            _g = 0
            while (_g < len(callbacks)):
                cb = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                _g = (_g + 1)
                if (cb is not None):
                    cb.dissolve()
        this1 = tink_core__Callback_SimpleLink(_hx_local_1)
        return this1
tink_core__Callback_CallbackLink_Impl_._hx_class = tink_core__Callback_CallbackLink_Impl_


class tink_core__Callback_SimpleLink:
    _hx_class_name = "tink.core._Callback.SimpleLink"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["dissolve"]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:85
        self.f = f

    def dissolve(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:88
        if (self.f is not None):
            self.f()

tink_core__Callback_SimpleLink._hx_class = tink_core__Callback_SimpleLink


class tink_core__Callback_LinkPair:
    _hx_class_name = "tink.core._Callback.LinkPair"
    __slots__ = ("a", "b", "dissolved")
    _hx_fields = ["a", "b", "dissolved"]
    _hx_methods = ["dissolve"]

    def __init__(self,a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:95
        self.dissolved = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:97
        self.a = a
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:98
        self.b = b

    def dissolve(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:102
        if (not self.dissolved):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:103
            self.dissolved = True
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:104
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:104
            this1 = self.a
            if (this1 is not None):
                this1.dissolve()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:105
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:105
            this2 = self.b
            if (this2 is not None):
                this2.dissolve()

tink_core__Callback_LinkPair._hx_class = tink_core__Callback_LinkPair


class tink_core__Callback_ListCell:
    _hx_class_name = "tink.core._Callback.ListCell"
    __slots__ = ("list", "cb")
    _hx_fields = ["list", "cb"]
    _hx_methods = ["invoke", "clear", "dissolve"]

    def __init__(self,cb,_hx_list):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:115
        if (cb is None):
            raise _HxException("callback expected but null received")
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:116
        self.cb = cb
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:117
        self.list = _hx_list

    def invoke(self,data):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:121
        if (self.cb is not None):
            tink_core__Callback_Callback_Impl_.invoke(self.cb,data)

    def clear(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:125
        self.list = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:126
        self.cb = None

    def dissolve(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:130
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:131
        if (_g is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:132
            v = _g
            self.clear()
            python_internal_ArrayImpl.remove(v,self)

tink_core__Callback_ListCell._hx_class = tink_core__Callback_ListCell


class tink_core__Callback_CallbackList_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackList_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_length", "add", "invoke", "clear"]
    length = None

    @staticmethod
    def _new():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:140
        this1 = []
        return this1

    @staticmethod
    def get_length(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:144
        return len(this1)

    @staticmethod
    def add(this1,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:147
        node = tink_core__Callback_ListCell(cb,this1)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:148
        this1.append(node)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:149
        return node

    @staticmethod
    def invoke(this1,data):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:153
        _g = 0
        _g1 = list(this1)
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:154
            if (cell.cb is not None):
                tink_core__Callback_Callback_Impl_.invoke(cell.cb,data)

    @staticmethod
    def clear(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:157
        _g = 0
        _hx_len = len(this1)
        pos = 0
        if (pos < 0):
            pos = (len(this1) + pos)
        if (pos < 0):
            pos = 0
        res = this1[pos:(pos + _hx_len)]
        del this1[pos:(pos + _hx_len)]
        _g1 = res
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:158
            cell.clear()
tink_core__Callback_CallbackList_Impl_._hx_class = tink_core__Callback_CallbackList_Impl_


class tink_core_TypedError:
    _hx_class_name = "tink.core.TypedError"
    __slots__ = ("message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError")
    _hx_fields = ["message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError"]
    _hx_methods = ["printPos", "toString", "throwSelf"]
    _hx_statics = ["withData", "typed", "asError", "catchExceptions", "reporter", "rethrow", "tryFinally"]

    def __init__(self,code = 500,message = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:44
        if (code is None):
            code = 500
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:47
        self.data = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:51
        self.isTinkError = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:54
        self.code = code
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:55
        self.message = message
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:56
        self.pos = pos
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:57
        self.exceptionStack = []
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:58
        self.callStack = []

    def printPos(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:61
        return ((((HxOverrides.stringOrNull(self.pos.className) + ".") + HxOverrides.stringOrNull(self.pos.methodName)) + ":") + Std.string(self.pos.lineNumber))

    def toString(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:71
        ret = ((("Error#" + Std.string(self.code)) + ": ") + HxOverrides.stringOrNull(self.message))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:73
        if (self.pos is not None):
            ret = (("null" if ret is None else ret) + HxOverrides.stringOrNull(((" @ " + HxOverrides.stringOrNull(self.printPos())))))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:76
        return ret

    def throwSelf(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:88
        raise _HxException(self)

    @staticmethod
    def withData(code = None,message = None,data = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:92
        return tink_core_TypedError.typed(code,message,data,pos)

    @staticmethod
    def typed(code = None,message = None,data = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:96
        ret = tink_core_TypedError(code,message,pos)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:97
        ret.data = data
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:98
        return ret

    @staticmethod
    def asError(v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:112
        value = v
        try:
            if isinstance(value,tink_core_TypedError):
                return value
            else:
                return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    @staticmethod
    def catchExceptions(f,report = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:117
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:121
            _g = tink_core_TypedError.asError(e)
            tmp = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:122
            if (_g is None):
                if (report is None):
                    tmp = tink_core_TypedError.withData(None,"Unexpected Error",e,pos)
                else:
                    tmp = report(e)
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:127
                e1 = _g
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:121
                tmp = e1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:120
            return tink_core_Outcome.Failure(tmp)

    @staticmethod
    def reporter(code = None,message = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:133
        def _hx_local_0(e):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:133
            return tink_core_TypedError.withData(code,message,e,pos)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:132
        return _hx_local_0

    @staticmethod
    def rethrow(any):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:143
        raise _HxException(any)

    @staticmethod
    def tryFinally(f,cleanup):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:153
        try:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:154
            ret = f()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:155
            cleanup()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:156
            return ret
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:159
            cleanup()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:160
            raise _HxException(e)

tink_core_TypedError._hx_class = tink_core_TypedError


class tink_core__Error_Stack_Impl_:
    _hx_class_name = "tink.core._Error.Stack_Impl_"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:170
        return "Error stack not available. Compile with -D error_stack."
tink_core__Error_Stack_Impl_._hx_class = tink_core__Error_Stack_Impl_


class tink_core__Future_FutureObject:
    _hx_class_name = "tink.core._Future.FutureObject"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
tink_core__Future_FutureObject._hx_class = tink_core__Future_FutureObject


class tink_core__Future_NeverFuture:
    _hx_class_name = "tink.core._Future.NeverFuture"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
    _hx_statics = ["inst"]

    def __init__(self):
        pass

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:217
        return tink_core__Future_NeverFuture.inst

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:218
        return tink_core__Future_NeverFuture.inst

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:219
        return None

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:220
        return tink_core__Future_NeverFuture.inst

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:221
        return tink_core__Future_NeverFuture.inst

tink_core__Future_NeverFuture._hx_class = tink_core__Future_NeverFuture

class tink_core_Noise(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Noise"
tink_core_Noise.Noise = tink_core_Noise("Noise", 0, list())
tink_core_Noise._hx_class = tink_core_Noise


class tink_core__Lazy_LazyObject:
    _hx_class_name = "tink.core._Lazy.LazyObject"
    __slots__ = ()
    _hx_methods = ["get", "map", "flatMap"]
tink_core__Lazy_LazyObject._hx_class = tink_core__Lazy_LazyObject


class tink_core__Lazy_LazyConst:
    _hx_class_name = "tink.core._Lazy.LazyConst"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["get", "map", "flatMap"]

    def __init__(self,value):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:32
        self.value = value

    def get(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:35
        return self.value

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:38
        return tink_core__Lazy_LazyConst(f(self.value))

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:41
        return f(self.value)

tink_core__Lazy_LazyConst._hx_class = tink_core__Lazy_LazyConst


class tink_core__Future_SyncFuture:
    _hx_class_name = "tink.core._Future.SyncFuture"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["map", "flatMap", "handle", "eager", "gather"]

    def __init__(self,value):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:229
        self.value = value

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:232
        return tink_core__Future_SyncFuture(self.value.map(f))

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:236
        l = self.value.map(f)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:235
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:237
            def _hx_local_0(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:237
                return l.get().handle(cb)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:235
            return tink_core__Future_SimpleFuture(_hx_local_0)
        return _hx_local_1()

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:241
        tink_core__Callback_Callback_Impl_.invoke(cb,self.value.get())
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:242
        return None

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:246
        return self

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:249
        return self

tink_core__Future_SyncFuture._hx_class = tink_core__Future_SyncFuture


class tink_core__Future_Future_Impl_:
    _hx_class_name = "tink.core._Future.Future_Impl_"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "first", "map", "flatMap", "next", "merge", "flatten", "asPromise", "ofMany", "fromMany", "lazy", "sync", "async", "or", "either", "and", "_tryFailingFlatMap", "_tryFlatMap", "_tryFailingMap", "_tryMap", "_flatMap", "_map", "trigger"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:12
        this1 = tink_core__Future_SimpleFuture(f)
        return this1

    @staticmethod
    def first(this1,other):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:19
        ret = tink_core_FutureTrigger()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:20
        l1 = this1.handle(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:21
        l2 = other.handle(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:22
        ret1 = ret
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:23
        if (l1 is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:24
            this2 = l1
            def _hx_local_0(_):
                this2.dissolve()
            ret1.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:25
        if (l2 is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:26
            this3 = l2
            def _hx_local_1(_1):
                this3.dissolve()
            ret1.handle(_hx_local_1)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:27
        return ret1

    @staticmethod
    def map(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:34
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:35
        ret = this1.map(f)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:37
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatMap(this1,next,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:45
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:46
        ret = this1.flatMap(next)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:48
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def next(this1,n):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:57
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:57
            def _hx_local_0(v):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:57
                return n(v)
            return this1.flatMap(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:63
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:64
        def _hx_local_1(t):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:64
            def _hx_local_0(a):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:64
                return merger(t,a)
            ret1 = other.map(_hx_local_0)
            return ret1
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:63
        ret = this1.flatMap(_hx_local_1)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatten(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:71
        return tink_core__Future_NestedFuture(f)

    @staticmethod
    def asPromise(s):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:85
        return s

    @staticmethod
    def ofMany(futures,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:90
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:91
        ret = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst([]))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:92
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:92
        _g = 0
        while (_g < len(futures)):
            f = [(futures[_g] if _g >= 0 and _g < len(futures) else None)]
            _g = (_g + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:94
            def _hx_local_4(f1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:94
                def _hx_local_1(results):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:96
                    def _hx_local_3():
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:96
                        def _hx_local_2(result):
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:97
                            return (results + [result])
                        return _hx_local_2
                    ret2 = _hx_local_3()
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:95
                    ret3 = (f1[0] if 0 < len(f1) else None).map(ret2)
                    return ret3
                return _hx_local_1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:93
            ret1 = ret.flatMap(_hx_local_4(f))
            ret = ret1
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:103
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def fromMany(futures):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:108
        return tink_core__Future_Future_Impl_.ofMany(futures)

    @staticmethod
    def lazy(l):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:112
        return tink_core__Future_SyncFuture(l)

    @staticmethod
    def sync(v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:119
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def async(f,lazy = False):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:126
        if (lazy is None):
            lazy = False
        if lazy:
            return tink_core__Future_LazyTrigger(f)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:129
            op = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:130
            wrapped = f
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:131
            tink_core__Callback_Callback_Impl_.invoke(wrapped,op.trigger)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:132
            return op

    @staticmethod
    def _hx_or(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:139
        return tink_core__Future_Future_Impl_.first(a,b)

    @staticmethod
    def either(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:145
        ret = a.map(haxe_ds_Either.Left)
        ret1 = b.map(haxe_ds_Either.Right)
        return tink_core__Future_Future_Impl_.first(ret,ret1)

    @staticmethod
    def _hx_and(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:151
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:151
            def _hx_local_0(a1,b1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:151
                this1 = tink_core_MPair(a1,b1)
                return this1
            return tink_core__Future_Future_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFailingFlatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:154
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:154
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:155
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:155
                d = o.params[0]
                return _hx_map(d)
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:156
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFlatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:160
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:160
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:161
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:161
                d = o.params[0]
                ret1 = _hx_map(d).map(tink_core_Outcome.Success)
                return ret1.gather()
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:162
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFailingMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:166
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:166
            return tink_core_OutcomeTools.flatMap(o,tink_core__Outcome_OutcomeMapper_Impl_.withSameError(_hx_map))
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:169
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:169
            return tink_core_OutcomeTools.map(o,_hx_map)
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _flatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:172
        ret = f.flatMap(_hx_map)
        return ret.gather()

    @staticmethod
    def _map(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:175
        ret = f.map(_hx_map)
        return ret.gather()

    @staticmethod
    def trigger():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:181
        return tink_core_FutureTrigger()
tink_core__Future_Future_Impl_._hx_class = tink_core__Future_Future_Impl_


class tink_core__Future_Futuristic_Impl_:
    _hx_class_name = "tink.core._Future.Futuristic_Impl_"
    __slots__ = ()
    _hx_statics = ["ofAny"]

    @staticmethod
    def ofAny(v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:188
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
tink_core__Future_Futuristic_Impl_._hx_class = tink_core__Future_Futuristic_Impl_


class tink_core__Future_SimpleFuture:
    _hx_class_name = "tink.core._Future.SimpleFuture"
    __slots__ = ("f", "gathered")
    _hx_fields = ["f", "gathered"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager"]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:255
        self.gathered = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:258
        self.f = f

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:261
        return self.f(callback)

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:263
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:264
        def _hx_local_3():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:265
            def _hx_local_2(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:265
                def _hx_local_1():
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:265
                    def _hx_local_0(v):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:265
                        tmp = f(v)
                        tink_core__Callback_Callback_Impl_.invoke(cb,tmp)
                    return _gthis.f(_hx_local_0)
                return _hx_local_1()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:264
            return tink_core__Future_SimpleFuture(_hx_local_2)
        return _hx_local_3()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:269
        f1 = f
        _gthis = self
        def _hx_local_3():
            def _hx_local_2(cb):
                def _hx_local_1():
                    def _hx_local_0(v):
                        tmp = f1(v)
                        tink_core__Callback_Callback_Impl_.invoke(cb,tmp)
                    return _gthis.f(_hx_local_0)
                return _hx_local_1()
            return tink_core__Future_Future_Impl_.flatten(tink_core__Future_SimpleFuture(_hx_local_2))
        return _hx_local_3()

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:272
        return tink_core_FutureTrigger.gatherFuture(self)

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:275
        ret = tink_core_FutureTrigger.gatherFuture(self)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:276
        def _hx_local_0():
            pass
        ret.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:277
        return ret

tink_core__Future_SimpleFuture._hx_class = tink_core__Future_SimpleFuture


class tink_core__Future_NestedFuture:
    _hx_class_name = "tink.core._Future.NestedFuture"
    __slots__ = ("outer",)
    _hx_fields = ["outer"]
    _hx_methods = ["map", "flatMap", "gather", "eager", "handle"]

    def __init__(self,outer):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:285
        self.outer = outer

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:288
        def _hx_local_0(inner):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:288
            ret1 = inner.map(f)
            return ret1.gather()
        ret = self.outer.flatMap(_hx_local_0)
        return ret.gather()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:291
        def _hx_local_0(inner):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:291
            ret1 = inner.flatMap(f)
            return ret1.gather()
        ret = self.outer.flatMap(_hx_local_0)
        return ret.gather()

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:294
        return tink_core_FutureTrigger.gatherFuture(self)

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:297
        ret = tink_core_FutureTrigger.gatherFuture(self)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:298
        def _hx_local_0():
            pass
        ret.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:299
        return ret

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:303
        ret = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:305
        def _hx_local_1(inner):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:305
            nonlocal ret
            def _hx_local_0(result):
                tink_core__Callback_Callback_Impl_.invoke(cb,result)
            ret = inner.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:304
        ret = self.outer.handle(_hx_local_1)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:307
        return ret

tink_core__Future_NestedFuture._hx_class = tink_core__Future_NestedFuture


class tink_core_FutureTrigger:
    _hx_class_name = "tink.core.FutureTrigger"
    __slots__ = ("result", "list")
    _hx_fields = ["result", "list"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager", "asFuture", "trigger"]
    _hx_statics = ["gatherFuture"]

    def __init__(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:312
        self.result = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:316
        this1 = []
        self.list = this1

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:319
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:320
        if (_g is None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:321
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:322
            return None
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:323
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:324
            return tink_core__Callback_CallbackList_Impl_.add(v,callback)

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:328
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:329
        if (_g is None):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(self.result)))
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:330
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:331
            ret = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:332
            def _hx_local_0(v1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:332
                tmp = f(v1)
                ret.trigger(tmp)
            tink_core__Callback_CallbackList_Impl_.add(self.list,_hx_local_0)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:333
            return ret

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:337
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:338
        if (_g is None):
            return f(self.result)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:339
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:340
            ret = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:341
            def _hx_local_0(v1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:341
                f(v1).handle(ret.trigger)
            tink_core__Callback_CallbackList_Impl_.add(self.list,_hx_local_0)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:342
            return ret

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:346
        return self

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:349
        return self

    def asFuture(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:352
        return self

    def trigger(self,result):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:371
        if (self.list is None):
            return False
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:373
            _hx_list = self.list
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:374
            self.list = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:375
            self.result = result
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:376
            tink_core__Callback_CallbackList_Impl_.invoke(_hx_list,result)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:377
            tink_core__Callback_CallbackList_Impl_.clear(_hx_list)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:378
            return True

    @staticmethod
    def gatherFuture(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:355
        op = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:356
        def _hx_local_0(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:356
            nonlocal op
            nonlocal f
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:357
            if (op is None):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:358
                op = tink_core_FutureTrigger()
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:359
                f.handle(op.trigger)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:360
                f = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:362
            return op.handle(cb)
        this1 = tink_core__Future_SimpleFuture(_hx_local_0)
        return this1

tink_core_FutureTrigger._hx_class = tink_core_FutureTrigger


class tink_core__Future_LazyTrigger(tink_core_FutureTrigger):
    _hx_class_name = "tink.core._Future.LazyTrigger"
    __slots__ = ("op",)
    _hx_fields = ["op"]
    _hx_methods = ["eager", "map", "flatMap", "handle"]
    _hx_statics = []
    _hx_super = tink_core_FutureTrigger


    def __init__(self,op):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:387
        if (op is None):
            raise _HxException("invalid argument")
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:389
        self.op = op
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:390
        super().__init__()

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:394
        if (self.op is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:395
            op = self.op
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:396
            self.op = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:397
            tink_core__Callback_Callback_Impl_.invoke(op,self.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:399
        return self

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:402
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:404
        if (self.op is None):
            return super().map(f)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:405
            def _hx_local_2():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:406
                def _hx_local_1(cb):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:406
                    def _hx_local_0(v):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:406
                        tmp = f(v)
                        cb(tmp)
                    _gthis.handle(_hx_local_0)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:405
                return tink_core__Future_Future_Impl_.async(_hx_local_1,True)
            return _hx_local_2()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:409
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:411
        if (self.op is None):
            return super().flatMap(f)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:412
            def _hx_local_2():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:413
                def _hx_local_1(cb):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:413
                    def _hx_local_0(v):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:413
                        f(v).handle(cb)
                    _gthis.handle(_hx_local_0)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:412
                return tink_core__Future_Future_Impl_.async(_hx_local_1,True)
            return _hx_local_2()

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:417
        self.eager()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:418
        return super().handle(cb)

tink_core__Future_LazyTrigger._hx_class = tink_core__Future_LazyTrigger


class tink_core__Lazy_Lazy_Impl_:
    _hx_class_name = "tink.core._Lazy.Lazy_Impl_"
    __slots__ = ()
    _hx_statics = ["get", "ofFunc", "map", "flatMap", "ofConst"]

    @staticmethod
    def get(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:6
        return this1.get()

    @staticmethod
    def ofFunc(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:9
        return tink_core__Lazy_LazyFunc(f)

    @staticmethod
    def map(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:12
        return this1.map(f)

    @staticmethod
    def flatMap(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:15
        return this1.flatMap(f)

    @staticmethod
    def ofConst(c):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:18
        return tink_core__Lazy_LazyConst(c)
tink_core__Lazy_Lazy_Impl_._hx_class = tink_core__Lazy_Lazy_Impl_


class tink_core__Lazy_LazyFunc:
    _hx_class_name = "tink.core._Lazy.LazyFunc"
    __slots__ = ("f", "result", "busy")
    _hx_fields = ["f", "result", "busy"]
    _hx_methods = ["get", "map", "flatMap"]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:46
        self.result = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:47
        self.busy = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:49
        self.f = f

    def get(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:52
        if self.busy:
            raise _HxException(tink_core_TypedError(None,"circular lazyness",_hx_AnonObject({'fileName': "Lazy.hx", 'lineNumber': 52, 'className': "tink.core._Lazy.LazyFunc", 'methodName': "get"})))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:53
        if (self.f is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:54
            self.busy = True
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:55
            self.result = self.f()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:56
            self.f = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:57
            self.busy = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:59
        return self.result

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:62
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:63
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:63
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:63
                tmp = _gthis.get()
                return f(tmp)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:65
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:66
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:66
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:66
                this1 = _gthis.get()
                return f(this1).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

tink_core__Lazy_LazyFunc._hx_class = tink_core__Lazy_LazyFunc


class tink_core_NamedWith:
    _hx_class_name = "tink.core.NamedWith"
    __slots__ = ("name", "value")
    _hx_fields = ["name", "value"]

    def __init__(self,name,value):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Named.hx:11
        self.name = name
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Named.hx:12
        self.value = value

tink_core_NamedWith._hx_class = tink_core_NamedWith


class tink_core_OptionTools:
    _hx_class_name = "tink.core.OptionTools"
    __slots__ = ()
    _hx_statics = ["force", "or", "orNull", "filter", "satisfies", "equals", "map", "flatMap", "iterator", "toArray"]

    @staticmethod
    def force(o,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:11
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:12
            v = o.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:13
            return v
        else:
            raise _HxException(tink_core_TypedError(404,"Some value expected but none found",pos))

    @staticmethod
    def _hx_or(o,l):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:22
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:23
            v = o.params[0]
            return v
        else:
            return l.get()

    @staticmethod
    def orNull(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:31
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:32
            v = o.params[0]
            return v
        else:
            return None

    @staticmethod
    def filter(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:40
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:41
            _hx_tmp = f(o.params[0])
            if (_hx_tmp == False):
                return haxe_ds_Option._hx_None
            else:
                return o
        else:
            return o

    @staticmethod
    def satisfies(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:49
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:50
            v = o.params[0]
            return f(v)
        else:
            return False

    @staticmethod
    def equals(o,v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:58
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:58
            v1 = o.params[0]
            return (v1 == v)
        else:
            return False

    @staticmethod
    def map(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:65
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:66
            v = o.params[0]
            return haxe_ds_Option.Some(f(v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def flatMap(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:75
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:76
            v = o.params[0]
            return f(v)
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def iterator(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:85
        return tink_core_OptionIter(o)

    @staticmethod
    def toArray(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:92
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:93
            v = o.params[0]
            return [v]
        else:
            return []
tink_core_OptionTools._hx_class = tink_core_OptionTools


class tink_core_OptionIter:
    _hx_class_name = "tink.core.OptionIter"
    __slots__ = ("value", "alive")
    _hx_fields = ["value", "alive"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:100
        self.value = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:101
        self.alive = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:104
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:105
            v = o.params[0]
            self.value = v
        else:
            self.alive = False

    def hasNext(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:110
        return self.alive

    def next(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:113
        self.alive = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:115
        return self.value

tink_core_OptionIter._hx_class = tink_core_OptionIter

class tink_core_Outcome(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Outcome"

    @staticmethod
    def Success(data):
        return tink_core_Outcome("Success", 0, [data])

    @staticmethod
    def Failure(failure):
        return tink_core_Outcome("Failure", 1, [failure])
tink_core_Outcome._hx_class = tink_core_Outcome


class tink_core_OutcomeTools:
    _hx_class_name = "tink.core.OutcomeTools"
    __slots__ = ()
    _hx_statics = ["sure", "toOption", "toOutcome", "orNull", "orUse", "orTry", "equals", "map", "isSuccess", "flatMap", "swap", "attempt", "flatten"]

    @staticmethod
    def sure(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:18
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:19
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:19
            data = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:20
            return data
        elif (outcome1 == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:21
            failure = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:22
            _g = tink_core_TypedError.asError(failure)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:23
            if (_g is None):
                raise _HxException(failure)
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:24
                e = _g
                return e.throwSelf()
        else:
            pass

    @staticmethod
    def toOption(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:33
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:34
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:34
            data = outcome.params[0]
            return haxe_ds_Option.Some(data)
        elif (outcome1 == 1):
            return haxe_ds_Option._hx_None
        else:
            pass

    @staticmethod
    def toOutcome(option,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:43
        option1 = option.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:44
        if (option1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:44
            value = option.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:45
            return tink_core_Outcome.Success(value)
        elif (option1 == 1):
            return tink_core_Outcome.Failure(tink_core_TypedError(404,((("Some value expected but none found in " + HxOverrides.stringOrNull(pos.fileName)) + "@line ") + Std.string(pos.lineNumber)),_hx_AnonObject({'fileName': "Outcome.hx", 'lineNumber': 47, 'className': "tink.core.OutcomeTools", 'methodName': "toOutcome"})))
        else:
            pass

    @staticmethod
    def orNull(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:55
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:56
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:56
            data = outcome.params[0]
            return data
        elif (outcome1 == 1):
            return None
        else:
            pass

    @staticmethod
    def orUse(outcome,fallback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:65
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:66
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:66
            data = outcome.params[0]
            return data
        elif (outcome1 == 1):
            return fallback.get()
        else:
            pass

    @staticmethod
    def orTry(outcome,fallback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:75
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:76
        if (outcome1 == 0):
            return outcome
        elif (outcome1 == 1):
            return fallback.get()
        else:
            pass

    @staticmethod
    def equals(outcome,to):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:84
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:85
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:85
            data = outcome.params[0]
            return (data == to)
        elif (outcome1 == 1):
            return False
        else:
            pass

    @staticmethod
    def map(outcome,transform):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:94
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:95
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:95
            a = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:96
            return tink_core_Outcome.Success(transform(a))
        elif (outcome1 == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:97
            f = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:98
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def isSuccess(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:106
        if (outcome.index == 0):
            return True
        else:
            return False

    @staticmethod
    def flatMap(o,mapper):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:117
        return tink_core__Outcome_OutcomeMapper_Impl_.apply(mapper,o)

    @staticmethod
    def swap(outcome,v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:125
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:126
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:126
            a = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:127
            return tink_core_Outcome.Success(v)
        elif (outcome1 == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:128
            f = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:129
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def attempt(f,report):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:138
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return tink_core_Outcome.Failure(report(e))

    @staticmethod
    def flatten(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:143
        o1 = o.index
        if (o1 == 0):
            tmp = o.params[0].index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:144
            if (tmp == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:144
                d = o.params[0].params[0]
                return tink_core_Outcome.Success(d)
            elif (tmp == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:145
                f = o.params[0].params[0]
                return tink_core_Outcome.Failure(f)
            else:
                pass
        elif (o1 == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:145
            f1 = o.params[0]
            return tink_core_Outcome.Failure(f1)
        else:
            pass
tink_core_OutcomeTools._hx_class = tink_core_OutcomeTools


class tink_core__Outcome_OutcomeMapper_Impl_:
    _hx_class_name = "tink.core._Outcome.OutcomeMapper_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "withSameError", "withEitherError"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:150
        this1 = _hx_AnonObject({'f': f})
        return this1

    @staticmethod
    def apply(this1,o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:152
        return this1.f(o)

    @staticmethod
    def withSameError(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:155
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:156
            def _hx_local_0(o):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:156
                o1 = o.index
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:157
                if (o1 == 0):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:157
                    d = o.params[0]
                    return f(d)
                elif (o1 == 1):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:158
                    f1 = o.params[0]
                    return tink_core_Outcome.Failure(f1)
                else:
                    pass
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:155
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def withEitherError(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:164
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:165
            def _hx_local_0(o):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:165
                o1 = o.index
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:166
                if (o1 == 0):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:166
                    d = o.params[0]
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:167
                    _g = f(d)
                    _g1 = _g.index
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:168
                    if (_g1 == 0):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:168
                        d1 = _g.params[0]
                        return tink_core_Outcome.Success(d1)
                    elif (_g1 == 1):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:169
                        f1 = _g.params[0]
                        return tink_core_Outcome.Failure(haxe_ds_Either.Right(f1))
                    else:
                        pass
                elif (o1 == 1):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:171
                    f2 = o.params[0]
                    return tink_core_Outcome.Failure(haxe_ds_Either.Left(f2))
                else:
                    pass
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:164
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()
tink_core__Outcome_OutcomeMapper_Impl_._hx_class = tink_core__Outcome_OutcomeMapper_Impl_


class tink_core__Pair_Pair_Impl_:
    _hx_class_name = "tink.core._Pair.Pair_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_a", "get_b", "toBool", "isNil", "nil"]
    a = None
    b = None

    @staticmethod
    def _new(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:8
        this1 = tink_core_MPair(a,b)
        return this1

    @staticmethod
    def get_a(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:10
        return this1.a

    @staticmethod
    def get_b(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:11
        return this1.b

    @staticmethod
    def toBool(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:14
        return (this1 is not None)

    @staticmethod
    def isNil(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:17
        return (this1 is None)

    @staticmethod
    def nil():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:20
        return None
tink_core__Pair_Pair_Impl_._hx_class = tink_core__Pair_Pair_Impl_


class tink_core_MPair:
    _hx_class_name = "tink.core.MPair"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]

    def __init__(self,a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:27
        self.a = a
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:28
        self.b = b

tink_core_MPair._hx_class = tink_core_MPair


class tink_core__Promise_Promise_Impl_:
    _hx_class_name = "tink.core._Promise.Promise_Impl_"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "eager", "map", "flatMap", "tryRecover", "recover", "mapError", "handle", "noise", "isSuccess", "next", "swap", "swapError", "merge", "and", "iterate", "ofSpecific", "ofFuture", "ofOutcome", "ofError", "ofData", "lazy", "inParallel", "inSequence", "cache", "lift"]

    @staticmethod
    def eager(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:12
        return this1.eager()

    @staticmethod
    def map(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:15
        ret = this1.map(f)
        return ret.gather()

    @staticmethod
    def flatMap(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:18
        ret = this1.flatMap(f)
        return ret.gather()

    @staticmethod
    def tryRecover(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:21
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:21
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:22
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:22
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:23
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def recover(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:27
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:27
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:28
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:28
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(d))
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:29
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def mapError(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:33
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:33
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:34
            if (o1 == 0):
                return o
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:35
                e = o.params[0]
                return tink_core_Outcome.Failure(f(e))
            else:
                pass
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def handle(this1,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:39
        return this1.handle(cb)

    @staticmethod
    def noise(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:42
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:42
            def _hx_local_0(v):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:42
                return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(tink_core_Noise.Noise))
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def isSuccess(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:45
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:45
            return tink_core_OutcomeTools.isSuccess(o)
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def next(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:48
        if (gather is None):
            gather = True
        def _hx_local_0(o):
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:49
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:49
                d = o.params[0]
                return f(d)
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:50
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def swap(this1,v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:54
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:54
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:54
                return v
            return tink_core__Future_Future_Impl_._tryMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def swapError(this1,e):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:57
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:57
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:57
                return e
            return tink_core__Promise_Promise_Impl_.mapError(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:60
        if (gather is None):
            gather = True
        def _hx_local_3():
            def _hx_local_2(t):
                def _hx_local_1():
                    def _hx_local_0(a):
                        return merger(t,a)
                    return tink_core__Promise_Promise_Impl_.next(other,_hx_local_0,False)
                return _hx_local_1()
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_2,gather)
        return _hx_local_3()

    @staticmethod
    def _hx_and(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:63
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:63
            def _hx_local_0(a1,b1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:63
                this1 = tink_core_MPair(a1,b1)
                return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(this1))
            return tink_core__Promise_Promise_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def iterate(promises,_hx_yield,_hx_finally,lazy = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:67
        def _hx_local_4():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:67
            def _hx_local_3(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:68
                _hx_iter = HxOverrides.iterator(promises)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:69
                next = None
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:70
                def _hx_local_2():
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:70
                    if _hx_iter.hasNext():
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:71
                        def _hx_local_1(o):
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:71
                            o1 = o.index
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:72
                            if (o1 == 0):
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:72
                                v = o.params[0]
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:73
                                def _hx_local_0(o2):
                                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:73
                                    o3 = o2.index
                                    if (o3 == 0):
                                        next1 = o2.params[0].index
                                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:74
                                        if (next1 == 0):
                                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:74
                                            ret = o2.params[0].params[0]
                                            cb(tink_core_Outcome.Success(ret))
                                        elif (next1 == 1):
                                            next()
                                        else:
                                            pass
                                    elif (o3 == 1):
                                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:76
                                        e = o2.params[0]
                                        cb(tink_core_Outcome.Failure(e))
                                    else:
                                        pass
                                _hx_yield(v).handle(_hx_local_0)
                            elif (o1 == 1):
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:78
                                e1 = o.params[0]
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:79
                                cb(tink_core_Outcome.Failure(e1))
                            else:
                                pass
                        _hx_iter.next().handle(_hx_local_1)
                    else:
                        _hx_finally.handle(cb)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:69
                next = _hx_local_2
                next2 = next
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:84
                next2()
            return tink_core__Future_Future_Impl_.async(_hx_local_3,lazy)
        return _hx_local_4()

    @staticmethod
    def ofSpecific(s):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:94
        return s

    @staticmethod
    def ofFuture(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:97
        ret = f.map(tink_core_Outcome.Success)
        return ret.gather()

    @staticmethod
    def ofOutcome(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:100
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))

    @staticmethod
    def ofError(e):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:103
        return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Failure(e))

    @staticmethod
    def ofData(d):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:106
        return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(d))

    @staticmethod
    def lazy(p):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:109
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:109
            def _hx_local_0(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:109
                p.get().handle(cb)
            return tink_core__Future_Future_Impl_.async(_hx_local_0,True)
        return _hx_local_1()

    @staticmethod
    def inParallel(a,lazy = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:113
        if (len(a) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:114
            def _hx_local_8():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:114
                def _hx_local_7(cb):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:115
                    result = []
                    pending = len(a)
                    links = None
                    sync = False
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:120
                    def _hx_local_0(o):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:120
                        nonlocal sync
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:121
                        if (links is None):
                            sync = True
                        elif (links is not None):
                            links.dissolve()
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:123
                        cb(o)
                    done = _hx_local_0
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:127
                    def _hx_local_1(e):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:127
                        done(tink_core_Outcome.Failure(e))
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:126
                    fail = _hx_local_1
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:129
                    def _hx_local_4(index,value):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:130
                        python_internal_ArrayImpl._set(result, index, value)
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:131
                        def _hx_local_3():
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:131
                            nonlocal pending
                            pending = (pending - 1)
                            return pending
                        if ((_hx_local_3()) == 0):
                            done(tink_core_Outcome.Success(result))
                    _hx_set = _hx_local_4
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:135
                    linkArray = []
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:137
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:137
                    _g1 = 0
                    _g = len(a)
                    while (_g1 < _g):
                        i = _g1
                        _g1 = (_g1 + 1)
                        i1 = [i]
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:138
                        if sync:
                            break
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:139
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:139
                        i2 = (i1[0] if 0 < len(i1) else None)
                        def _hx_local_6(i3):
                            def _hx_local_5(o1):
                                o2 = o1.index
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:140
                                if (o2 == 0):
                                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:140
                                    v = o1.params[0]
                                    _hx_set((i3[0] if 0 < len(i3) else None),v)
                                elif (o2 == 1):
                                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:141
                                    e1 = o1.params[0]
                                    fail(e1)
                                else:
                                    pass
                            return _hx_local_5
                        x = _hx_local_6(i1)
                        x1 = (a[i2] if i2 >= 0 and i2 < len(a) else None).handle(x)
                        linkArray.append(x1)
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:145
                    links = tink_core__Callback_CallbackLink_Impl_.fromMany(linkArray)
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:147
                    if sync:
                        if (links is not None):
                            links.dissolve()
                return tink_core__Future_Future_Impl_.async(_hx_local_7,lazy)
            return _hx_local_8()

    @staticmethod
    def inSequence(a):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:153
        loop = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:155
        def _hx_local_4(index):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:155
            if (index == len(a)):
                return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success([]))
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:157
                def _hx_local_3():
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:158
                    def _hx_local_2(head):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:158
                        def _hx_local_1():
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:159
                            def _hx_local_0(tail):
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:159
                                return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(([head] + tail)))
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:158
                            return tink_core__Promise_Promise_Impl_.next(loop((index + 1)),_hx_local_0)
                        return _hx_local_1()
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:157
                    return tink_core__Promise_Promise_Impl_.next((a[index] if index >= 0 and index < len(a) else None),_hx_local_2)
                return _hx_local_3()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:153
        loop = _hx_local_4
        loop1 = loop
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:163
        return loop1(0)

    @staticmethod
    def cache(gen):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:167
        p = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:168
        def _hx_local_0():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:168
            nonlocal p
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:169
            ret = p
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:170
            if (ret is None):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:171
                sync = False
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:172
                def _hx_local_2(o):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:173
                    def _hx_local_1(_):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:173
                        nonlocal sync
                        nonlocal p
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:174
                        sync = True
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:175
                        p = None
                    o.b.handle(_hx_local_1)
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:177
                    return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(o.a))
                ret = tink_core__Promise_Promise_Impl_.next(gen(),_hx_local_2)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:179
                if (not sync):
                    p = ret
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:181
            def _hx_local_3(o1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:181
                nonlocal p
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:182
                if (not tink_core_OutcomeTools.isSuccess(o1)):
                    p = None
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:183
                return o1
            ret1 = ret.map(_hx_local_3)
            return ret1.gather()
        return _hx_local_0

    @staticmethod
    def lift(p):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:190
        return p
tink_core__Promise_Promise_Impl_._hx_class = tink_core__Promise_Promise_Impl_


class tink_core__Promise_Next_Impl_:
    _hx_class_name = "tink.core._Promise.Next_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync", "_chain"]

    @staticmethod
    def ofSafe(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:197
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:197
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:200
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:200
            ret = f(x).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:203
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:203
            return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(f(x)))
        return _hx_local_0

    @staticmethod
    def _chain(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:206
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:206
            return tink_core__Promise_Promise_Impl_.next(a(v),b)
        return _hx_local_0
tink_core__Promise_Next_Impl_._hx_class = tink_core__Promise_Next_Impl_


class tink_core__Promise_Recover_Impl_:
    _hx_class_name = "tink.core._Promise.Recover_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSync"]

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:213
        def _hx_local_0(e):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:213
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(e)))
        return _hx_local_0
tink_core__Promise_Recover_Impl_._hx_class = tink_core__Promise_Recover_Impl_


class tink_core__Promise_Combiner_Impl_:
    _hx_class_name = "tink.core._Promise.Combiner_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync"]

    @staticmethod
    def ofSafe(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:220
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:220
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x1,x2)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:223
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:223
            ret = f(x1,x2).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:226
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:226
            return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(f(x1,x2)))
        return _hx_local_0
tink_core__Promise_Combiner_Impl_._hx_class = tink_core__Promise_Combiner_Impl_


class tink_core__Ref_Ref_Impl_:
    _hx_class_name = "tink.core._Ref.Ref_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "set_value", "toString", "to"]
    value = None

    @staticmethod
    def _new():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:6
        this1 = None
        this2 = [None]*1
        this1 = this2
        return this1

    @staticmethod
    def get_value(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:8
        return this1[0]

    @staticmethod
    def set_value(this1,param):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:9
        this1[0] = param
        return param

    @staticmethod
    def toString(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:11
        return (("@[" + Std.string(this1[0])) + "]")

    @staticmethod
    def to(v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:14
        this1 = None
        this2 = [None]*1
        this1 = this2
        ret = this1
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:15
        ret[0] = v
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:16
        return ret
tink_core__Ref_Ref_Impl_._hx_class = tink_core__Ref_Ref_Impl_


class tink_core__Signal_Signal_Impl_:
    _hx_class_name = "tink.core._Signal.Signal_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "map", "flatMap", "filter", "select", "join", "nextTime", "next", "noise", "gather", "generate", "trigger", "ofClassical"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:9
        this1 = tink_core__Signal_SimpleSignal(f)
        return this1

    @staticmethod
    def map(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:15
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:16
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:16
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:16
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:16
                    this3 = f(result)
                    tink_core__Callback_Callback_Impl_.invoke(cb,this3)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:18
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def flatMap(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:26
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:27
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:27
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:27
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:27
                    f(result).handle(cb)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:29
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def filter(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:36
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:37
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:37
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:37
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:37
                    if f(result):
                        tink_core__Callback_Callback_Impl_.invoke(cb,result)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:39
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def select(this1,selector,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:43
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:44
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:44
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:44
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:44
                    _g = selector(result)
                    _g1 = _g.index
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:45
                    if (_g1 == 0):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:45
                        v = _g.params[0]
                        tink_core__Callback_Callback_Impl_.invoke(cb,v)
                    elif (_g1 == 1):
                        pass
                    else:
                        pass
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:49
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def join(this1,other,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:57
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:60
        def _hx_local_0(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:60
            return tink_core__Callback_LinkPair(this1.handle(cb),other.handle(cb))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:58
        this2 = tink_core__Signal_SimpleSignal(_hx_local_0)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:63
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def nextTime(this1,condition = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:71
        ret = tink_core_FutureTrigger()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:72
        link = None
        immediate = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:75
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:75
            nonlocal immediate
            if ((condition is None) or condition(v)):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:76
                ret.trigger(v)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:77
                if (link is None):
                    immediate = True
                elif (link is not None):
                    link.dissolve()
        link = this1.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:81
        if immediate:
            if (link is not None):
                link.dissolve()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:84
        return ret

    @staticmethod
    def next(this1,condition = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:91
        return tink_core__Signal_Signal_Impl_.nextTime(this1,condition)

    @staticmethod
    def noise(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:97
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:97
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:97
                return tink_core_Noise.Noise
            return tink_core__Signal_Signal_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def gather(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:105
        ret = tink_core__Signal_Signal_Impl_.trigger()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:106
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:106
            tink_core__Callback_CallbackList_Impl_.invoke(ret.handlers,x)
        this1.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:107
        return ret

    @staticmethod
    def generate(generator):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:111
        ret = tink_core__Signal_Signal_Impl_.trigger()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:112
        generator(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:113
        return ret

    @staticmethod
    def trigger():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:120
        return tink_core_SignalTrigger()

    @staticmethod
    def ofClassical(add,remove,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:126
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:127
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:128
            def _hx_local_0(a):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:128
                tink_core__Callback_Callback_Impl_.invoke(cb,a)
            f = _hx_local_0
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:129
            add(f)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:130
            this2 = None
            f1 = remove
            a1 = f
            def _hx_local_1():
                f1(a1)
            this2 = tink_core__Callback_SimpleLink(_hx_local_1)
            return this2
        this1 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this1
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:134
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret
tink_core__Signal_Signal_Impl_._hx_class = tink_core__Signal_Signal_Impl_


class tink_core_SignalObject:
    _hx_class_name = "tink.core.SignalObject"
    __slots__ = ()
    _hx_methods = ["handle"]
tink_core_SignalObject._hx_class = tink_core_SignalObject


class tink_core__Signal_SimpleSignal:
    _hx_class_name = "tink.core._Signal.SimpleSignal"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["handle"]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:141
        self.f = f

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:142
        return self.f(cb)

tink_core__Signal_SimpleSignal._hx_class = tink_core__Signal_SimpleSignal


class tink_core_SignalTrigger:
    _hx_class_name = "tink.core.SignalTrigger"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["trigger", "getLength", "handle", "clear", "asSignal"]

    def __init__(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:146
        this1 = []
        self.handlers = this1

    def trigger(self,event):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:153
        tink_core__Callback_CallbackList_Impl_.invoke(self.handlers,event)

    def getLength(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:159
        return len(self.handlers)

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:162
        return tink_core__Callback_CallbackList_Impl_.add(self.handlers,cb)

    def clear(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:168
        tink_core__Callback_CallbackList_Impl_.clear(self.handlers)

    def asSignal(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:171
        return self

tink_core_SignalTrigger._hx_class = tink_core_SignalTrigger

# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:135
Math.NEGATIVE_INFINITY = float("-inf")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:136
Math.POSITIVE_INFINITY = float("inf")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:137
Math.NaN = float("nan")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:138
Math.PI = python_lib_Math.pi

Date.EPOCH_UTC = python_lib_datetime_Datetime.fromtimestamp(0,python_lib_datetime_Timezone.utc)
def _hx_init_Sys_environ():
    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:30
    def _hx_local_0():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:31
        Sys.environ = haxe_ds_StringMap()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:33
        env = python_lib_Os.environ
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:35
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:35
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:36
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:38
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
def _hx_init_a8_GlobalScheduler_scheduler():
    # src/a8/GlobalScheduler.hx:9
    def _hx_local_0():
        # src/a8/GlobalScheduler.hx:10
        s = a8_PySched.scheduler()
        # src/a8/GlobalScheduler.hx:12
        def _hx_local_1():
            # src/a8/GlobalScheduler.hx:12
            while True:
                # src/a8/GlobalScheduler.hx:13
                s.run()
                # src/a8/GlobalScheduler.hx:14
                python_lib_Time.sleep(1)
        # src/a8/GlobalScheduler.hx:11
        a8_PyOps.spawn(_hx_local_1)
        # src/a8/GlobalScheduler.hx:17
        return s
    return _hx_local_0()
a8_GlobalScheduler.scheduler = _hx_init_a8_GlobalScheduler_scheduler()
a8_Logger.traceEnabled = False
a8_PlatformOps.instance = a8_PythonPlatform()
a8_UserConfig.sbtCredentials = a8_PathOps.readProperties(a8_PathOps.entry(a8_PathOps.userHome(),".sbt/credentials"))
a8_UserConfig.versions = a8_PathOps.readProperties(a8_PathOps.entry(a8_PathOps.userHome(),".a8/versions/config.properties"))
haxe_EntryPoint.sleepLock = haxe__EntryPoint_Lock()
haxe_EntryPoint.mutex = haxe__EntryPoint_Mutex()
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
haxe_MainLoop.pending = None
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
tink_core__Callback_Callback_Impl_.depth = 0
tink_core__Callback_Callback_Impl_.MAX_DEPTH = 1000
tink_core__Future_NeverFuture.inst = tink_core__Future_NeverFuture()
tink_core__Future_Future_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(None))
tink_core__Future_Future_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
tink_core__Future_Future_Impl_.NEVER = tink_core__Future_NeverFuture.inst
tink_core__Promise_Promise_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(None)))
tink_core__Promise_Promise_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
def _hx_init_tink_core__Promise_Promise_Impl__NEVER():
    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:9
    def _hx_local_0():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:9
        ret = tink_core__Future_Future_Impl_.NEVER.map(tink_core_Outcome.Success)
        return ret.gather()
    return _hx_local_0()
tink_core__Promise_Promise_Impl_.NEVER = _hx_init_tink_core__Promise_Promise_Impl__NEVER()

a8_launcher_Main.main()
haxe_EntryPoint.run()
