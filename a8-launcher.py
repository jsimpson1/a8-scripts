#!/usr/bin/env python3
# Generated by Haxe 3.4.7
# coding: utf-8

from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import sched as a8_PySched
from threading import Thread as python_lib_threading_Thread
import time as python_lib_Time
import shutil as a8_PyShutil2
import os as a8_PyOs2
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import io as python_lib_Io
import json as python_lib_Json
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import subprocess as python_lib_Subprocess
import sys as python_lib_Sys
try:
    import termios as python_lib_Termios
except:
    pass
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
try:
    import tty as python_lib_Tty
except:
    pass
from io import StringIO as python_lib_io_StringIO
from subprocess import Popen as python_lib_subprocess_Popen


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:38
        self.tag = tag
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:39
        self.index = index
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:40
        self.params = params

    def __str__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:45
        if (self.params is None):
            return self.tag
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/EnumImpl.hx:48
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")

Enum._hx_class = Enum


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date",)
    _hx_fields = ["date"]
    _hx_methods = ["toString"]
    _hx_statics = ["EPOCH_UTC", "now", "fromTime", "UTC", "datetimeTimestamp", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:34
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:35
        if (day == 0):
            day = 1
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:36
        self.date = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0)

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:83
        m = ((self.date.month - 1) + 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:84
        d = self.date.day
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:85
        h = self.date.hour
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:86
        mi = self.date.minute
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:87
        s = self.date.second
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:88
        return ((((((((((Std.string(self.date.year) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(m)) if ((m < 10)) else ("" + Std.string(m)))))) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(d)) if ((d < 10)) else ("" + Std.string(d)))))) + " ") + HxOverrides.stringOrNull(((("0" + Std.string(h)) if ((h < 10)) else ("" + Std.string(h)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(mi)) if ((mi < 10)) else ("" + Std.string(mi)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(s)) if ((s < 10)) else ("" + Std.string(s))))))

    @staticmethod
    def now():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:98
        d = Date(1970,0,1,0,0,0)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:99
        d.date = python_lib_datetime_Datetime.now()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:100
        return d

    @staticmethod
    def fromTime(t):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:105
        d = Date(1970,0,1,0,0,0)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:106
        d.date = python_lib_datetime_Datetime.fromtimestamp((t / 1000.0))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:107
        return d

    @staticmethod
    def UTC(year,month,day,hour,_hx_min,sec):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:113
        dt = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0,python_lib_datetime_Timezone.utc)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:114
        return Date.datetimeTimestamp(dt,Date.EPOCH_UTC)

    @staticmethod
    def datetimeTimestamp(dt,epoch):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:119
        return ((dt - epoch).total_seconds() * 1000)

    @staticmethod
    def fromString(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:124
        _g = len(s)
        _g1 = _g
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:126
        if (_g1 == 8):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:127
            k = s.split(":")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:128
            d = Date(0,0,0,Std.parseInt((k[0] if 0 < len(k) else None)),Std.parseInt((k[1] if 1 < len(k) else None)),Std.parseInt((k[2] if 2 < len(k) else None)))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:129
            return d
        elif (_g1 == 10):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:131
            k1 = s.split("-")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:132
            return Date(Std.parseInt((k1[0] if 0 < len(k1) else None)),(Std.parseInt((k1[1] if 1 < len(k1) else None)) - 1),Std.parseInt((k1[2] if 2 < len(k1) else None)),0,0,0)
        elif (_g1 == 19):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:134
            k2 = s.split(" ")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:135
            _this = (k2[0] if 0 < len(k2) else None)
            y = _this.split("-")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:136
            _this1 = (k2[1] if 1 < len(k2) else None)
            t = _this1.split(":")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Date.hx:137
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise _HxException(("Invalid date format : " + ("null" if s is None else s)))

Date._hx_class = Date


class EnumValue:
    _hx_class_name = "EnumValue"
EnumValue._hx_class = EnumValue


class Lambda:
    _hx_class_name = "Lambda"
    __slots__ = ()
    _hx_statics = ["array", "map", "flatten", "flatMap", "iter", "find"]

    @staticmethod
    def array(it):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:45
        a = list()
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:46
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:46
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:47
            a.append(i1)
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:48
        return a

    @staticmethod
    def map(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:71
        l = List()
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:72
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:72
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:73
            l.add(f(x1))
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:74
        return l

    @staticmethod
    def flatten(it):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:98
        l = List()
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:99
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:99
        e = HxOverrides.iterator(it)
        while e.hasNext():
            e1 = e.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:100
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:100
            x = HxOverrides.iterator(e1)
            while x.hasNext():
                x1 = x.next()
                # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:101
                l.add(x1)
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:102
        return l

    @staticmethod
    def flatMap(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:113
        return Lambda.flatten(Lambda.map(it,f))

    @staticmethod
    def iter(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:173
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:174
            f(x1)

    @staticmethod
    def find(it,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:264
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:264
        v = HxOverrides.iterator(it)
        while v.hasNext():
            v1 = v.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:265
            if f(v1):
                return v1
        # /Users/glen/tools-a8/packages/haxe/current/std/Lambda.hx:267
        return None
Lambda._hx_class = Lambda


class List:
    _hx_class_name = "List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "iterator"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:33
        self.q = None
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:32
        self.h = None
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:44
        self.length = 0

    def add(self,item):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:53
        x = _List_ListNode(item,None)
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:54
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:58
        self.q = x
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:59
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:59
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def iterator(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:161
        return _List_ListIterator(self.h)

List._hx_class = List


class _List_ListNode:
    _hx_class_name = "_List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:256
        self.item = item
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:257
        self.next = next

_List_ListNode._hx_class = _List_ListNode


class _List_ListIterator:
    _hx_class_name = "_List.ListIterator"
    __slots__ = ("head",)
    _hx_fields = ["head"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,head):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:269
        self.head = head

    def hasNext(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:273
        return (self.head is not None)

    def next(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:277
        val = self.head.item
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:278
        self.head = self.head.next
        # /Users/glen/tools-a8/packages/haxe/current/std/List.hx:279
        return val

_List_ListIterator._hx_class = _List_ListIterator


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField", "isFunction", "copy"]

    @staticmethod
    def field(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:44
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:49
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def isFunction(f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:86
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return hasattr(f,"func_code")
        else:
            return True

    @staticmethod
    def copy(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:124
        o2 = _hx_AnonObject({})
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:125
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:125
        _g = 0
        _g1 = python_Boot.fields(o)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:126
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:126
            value = Reflect.field(o,f)
            setattr(o2,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Reflect.hx:127
        return o2
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def string(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:134
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:147
        if (x is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:148
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:152
                prefix = HxString.substr(x,0,2).lower()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:154
                if (prefix == "0x"):
                    return int(x,16)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:157
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:160
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:162
                if (r is None):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:163
                    r1 = Std.shortenPossibleNumber(x)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:164
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:170
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:177
        r = ""
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:178
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:178
        _g1 = 0
        _g = len(x)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:179
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:180
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:180
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g21 = _g2
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:191
                if (((((((((((_g21 == 57) or ((_g21 == 56))) or ((_g21 == 55))) or ((_g21 == 54))) or ((_g21 == 53))) or ((_g21 == 52))) or ((_g21 == 51))) or ((_g21 == 50))) or ((_g21 == 49))) or ((_g21 == 48))) or ((_g21 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:195
        return r

    @staticmethod
    def parseFloat(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:200
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:204
            if (x is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:205
                r1 = Std.shortenPossibleNumber(x)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:206
                if (r1 != x):
                    return Std.parseFloat(r1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Std.hx:210
            return Math.NaN
Std._hx_class = Std


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/StringBuf.hx:32
        self.b = python_lib_io_StringIO()

StringBuf._hx_class = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["startsWith", "endsWith", "lpad"]

    @staticmethod
    def startsWith(s,start):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:200
        if (len(s) >= len(start)):
            return (HxString.substr(s,0,len(start)) == start)
        else:
            return False

    @staticmethod
    def endsWith(s,end):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:230
        elen = len(end)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:231
        slen = len(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:232
        if (slen >= elen):
            return (HxString.substr(s,(slen - elen),elen) == end)
        else:
            return False

    @staticmethod
    def lpad(s,c,l):
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:332
        if (len(c) <= 0):
            return s
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:335
        while (len(s) < l):
            s = (("null" if c is None else c) + ("null" if s is None else s))
        # /Users/glen/tools-a8/packages/haxe/current/std/StringTools.hx:338
        return s
StringTools._hx_class = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "fullPath", "isDirectory", "createDirectory", "deleteFile", "readDirectory"]

    @staticmethod
    def exists(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:31
        return python_lib_os_Path.exists(path)

    @staticmethod
    def fullPath(relPath):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:56
        return python_lib_os_Path.realpath(relPath)

    @staticmethod
    def isDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:66
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def createDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:70
        python_lib_Os.makedirs(path,511,True)

    @staticmethod
    def deleteFile(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:74
        python_lib_Os.remove(path)

    @staticmethod
    def readDirectory(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/FileSystem.hx:82
        return python_lib_Os.listdir(path)
sys_FileSystem._hx_class = sys_FileSystem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
    _hx_methods = ["get", "keys"]
haxe_IMap._hx_class = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:32
        self.h = dict()

    def get(self,key):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:40
        return self.h.get(key,None)

    def keys(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/StringMap.hx:54
        return python_HaxeIterator(iter(self.h.keys()))

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:31
        self.checked = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:30
        self.has = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:29
        self.x = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:34
        self.it = it

    def next(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:38
        if (not self.checked):
            self.hasNext()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:39
        self.checked = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:40
        return self.x

    def hasNext(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:44
        if (not self.checked):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:45
            try:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:46
                self.x = self.it.__next__()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:47
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:49
                    self.has = False
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:50
                    self.x = None
                else:
                    raise _hx_e
            # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:52
            self.checked = True
        # /Users/glen/tools-a8/packages/haxe/current/std/python/HaxeIterator.hx:54
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["environ", "time", "exit", "print", "println", "args", "getEnv", "putEnv", "environment", "sleep", "setTimeLocale", "getCwd", "setCwd", "systemName", "command", "cpuTime", "executablePath", "_programPath", "programPath", "getChar", "stdin", "stdout", "stderr"]

    @staticmethod
    def time():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:42
        return python_lib_Time.time()

    @staticmethod
    def exit(code):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:46
        python_lib_Sys.exit(code)

    @staticmethod
    def print(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:50
        python_Lib.print(v)

    @staticmethod
    def println(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:54
        python_Lib.println(v)

    @staticmethod
    def args():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:58
        argv = python_lib_Sys.argv
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:59
        return argv[1:None]

    @staticmethod
    def getEnv(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:63
        return Sys.environ.h.get(s,None)

    @staticmethod
    def putEnv(s,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:67
        python_lib_Os.putenv(s,v)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:68
        Sys.environ.h[s] = v

    @staticmethod
    def environment():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:72
        return Sys.environ

    @staticmethod
    def sleep(seconds):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:76
        python_lib_Time.sleep(seconds)

    @staticmethod
    def setTimeLocale(loc):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:80
        return False

    @staticmethod
    def getCwd():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:84
        return python_lib_Os.getcwd()

    @staticmethod
    def setCwd(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:88
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:92
        _g = python_lib_Sys.platform
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:93
        x = _g
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:92
        if StringTools.startsWith(x,"linux"):
            return "Linux"
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:92
            _g1 = _g
            _hx_local_0 = len(_g1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:96
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:104
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def cpuTime():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:111
        return python_lib_Timeit.default_timer()

    @staticmethod
    def executablePath():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:115
        return python_internal_ArrayImpl._get(python_lib_Sys.argv, 0)

    @staticmethod
    def programPath():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:121
        return Sys._programPath

    @staticmethod
    def getChar(echo):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:126
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:127
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:128
                fd = python_lib_Sys.stdin.fileno()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:129
                old = python_lib_Termios.tcgetattr(fd)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:131
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_1
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:133
                try:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:134
                    python_lib_Tty.setraw(fd)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:135
                    x = python_lib_Sys.stdin.read(1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:136
                    restore()
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:126
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:139
                    restore()
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:140
                    raise _HxException(e)
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:145
                x1 = _g
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:146
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:128
                fd = python_lib_Sys.stdin.fileno()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:129
                old = python_lib_Termios.tcgetattr(fd)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:131
                a1 = fd
                a2 = python_lib_Termios.TCSADRAIN
                a3 = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(a1,a2,a3)
                restore = _hx_local_2
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:133
                try:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:134
                    python_lib_Tty.setraw(fd)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:135
                    x = python_lib_Sys.stdin.read(1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:136
                    restore()
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:126
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:139
                    restore()
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:140
                    raise _HxException(e)
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:145
                x1 = _g
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:146
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getch().decode("utf-8"),0)
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:145
                x1 = _g
                # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:146
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:145
            x1 = _g
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:146
            raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:148
        if echo:
            python_Lib.print("".join(map(chr,[ch])))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:151
        return ch

    @staticmethod
    def stdin():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:155
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

    @staticmethod
    def stdout():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:159
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stdout)

    @staticmethod
    def stderr():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:163
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stderr)
Sys._hx_class = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, [c])

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, [e])
ValueType.TNull = ValueType("TNull", 0, list())
ValueType.TInt = ValueType("TInt", 1, list())
ValueType.TFloat = ValueType("TFloat", 2, list())
ValueType.TBool = ValueType("TBool", 3, list())
ValueType.TObject = ValueType("TObject", 4, list())
ValueType.TFunction = ValueType("TFunction", 5, list())
ValueType.TUnknown = ValueType("TUnknown", 8, list())
ValueType._hx_class = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["typeof"]

    @staticmethod
    def typeof(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Type.hx:178
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown
Type._hx_class = Type


class a8_DateOps:
    _hx_class_name = "a8.DateOps"
    __slots__ = ()
    _hx_statics = ["midnight"]

    @staticmethod
    def midnight():
        # src/a8/DateOps.hx:7
        now = Date.now()
        # src/a8/DateOps.hx:8
        oneSecondBeforeMidnight = Date(now.date.year,(now.date.month - 1),now.date.day,23,59,59)
        # src/a8/DateOps.hx:9
        return Date.fromTime(((python_lib_Time.mktime(oneSecondBeforeMidnight.date.timetuple()) * 1000) + 1000))
a8_DateOps._hx_class = a8_DateOps


class a8_Exception:
    _hx_class_name = "a8.Exception"
    __slots__ = ("message", "causedBy", "callStack", "posInfos")
    _hx_fields = ["message", "causedBy", "callStack", "posInfos"]
    _hx_methods = ["toString", "rethrow"]
    _hx_statics = ["thro"]

    def __init__(self,message,causedBy = None,posInfos = None):
        # src/a8/Exception.hx:19
        self.message = message
        # src/a8/Exception.hx:20
        self.causedBy = a8_OptionOps.toOption(causedBy)
        # src/a8/Exception.hx:21
        self.callStack = haxe_CallStack.callStack()
        # src/a8/Exception.hx:22
        self.posInfos = posInfos

    def toString(self):
        # src/a8/Exception.hx:26
        return ((((((HxOverrides.stringOrNull(self.posInfos.fileName) + ":") + Std.string(self.posInfos.lineNumber)) + " ") + HxOverrides.stringOrNull(self.message)) + "\n") + HxOverrides.stringOrNull(a8_HaxeOps2.asString(self.callStack,"    ")))

    def rethrow(self,context,posInfos = None):
        # src/a8/Exception.hx:35
        raise _HxException(a8_Exception(context,self,posInfos))

    @staticmethod
    def thro(message):
        # src/a8/Exception.hx:10
        raise _HxException(a8_Exception(message,None,_hx_AnonObject({'fileName': "Exception.hx", 'lineNumber': 10, 'className': "a8.Exception", 'methodName': "thro"})))

a8_Exception._hx_class = a8_Exception


class a8_Exec:
    _hx_class_name = "a8.Exec"
    __slots__ = ("args", "cwd", "env", "failOnNonZeroExitCode", "executable")
    _hx_fields = ["args", "cwd", "env", "failOnNonZeroExitCode", "executable"]
    _hx_methods = ["asCommandLine", "execInline", "execCapture"]

    def __init__(self):
        # src/a8/Exec.hx:17
        self.executable = None
        # src/a8/Exec.hx:15
        self.env = None
        # src/a8/Exec.hx:14
        self.cwd = None
        # src/a8/Exec.hx:13
        self.args = None
        # src/a8/Exec.hx:16
        self.failOnNonZeroExitCode = True
        # src/a8/Exec.hx:13
        self.args = []
        # src/a8/Exec.hx:14
        self.cwd = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:15
        self.env = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:17
        self.executable = haxe_ds_Option._hx_None

    def asCommandLine(self):
        # src/a8/Exec.hx:23
        _this = self.args
        return " ".join([python_Boot.toString1(x1,'') for x1 in _this])

    def execInline(self):
        # src/a8/Exec.hx:31
        a8_Logger.trace(("running -- " + HxOverrides.stringOrNull(self.asCommandLine())),_hx_AnonObject({'fileName': "Exec.hx", 'lineNumber': 31, 'className': "a8.Exec", 'methodName': "execInline"}))
        # src/a8/Exec.hx:32
        exitCode = python_lib_Subprocess.call(self.args,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'cwd': a8_OptionOps.getOrElse(self.cwd,None)})))
        # src/a8/Exec.hx:39
        if ((exitCode != 0) and self.failOnNonZeroExitCode):
            a8_Exception.thro(((("non-zero exit code of " + Std.string(exitCode)) + " while executing -- ") + HxOverrides.stringOrNull(self.asCommandLine())))
        # src/a8/Exec.hx:42
        return exitCode

    def execCapture(self):
        # src/a8/Exec.hx:49
        a8_Logger.trace(("running -- " + HxOverrides.stringOrNull(self.asCommandLine())),_hx_AnonObject({'fileName': "Exec.hx", 'lineNumber': 49, 'className': "a8.Exec", 'methodName': "execCapture"}))
        # src/a8/Exec.hx:52
        popen = self.args
        # src/a8/Exec.hx:54
        popen1 = a8_OptionOps.getOrElse(self.executable,(self.args[0] if 0 < len(self.args) else None))
        # src/a8/Exec.hx:56
        popen2 = python_lib_Subprocess.PIPE
        # src/a8/Exec.hx:57
        popen3 = python_lib_Subprocess.PIPE
        # src/a8/Exec.hx:61
        popen4 = a8_OptionOps.getOrElse(self.cwd,None)
        # src/a8/Exec.hx:62
        o = self.env
        popen5 = None
        if (o.index == 0):
            v = o.params[0]
            popen5 = haxe_ds_Option.Some(a8_PyOps.toDict(v))
        else:
            popen5 = haxe_ds_Option._hx_None
        # src/a8/Exec.hx:50
        popen6 = python_lib_subprocess_Popen(popen,None,popen1,None,popen2,popen3,None,False,False,popen4,a8_OptionOps.getOrElse(popen5,None))
        # src/a8/Exec.hx:65
        def _hx_local_0(out):
            pass
        firstIO = _hx_local_0
        # src/a8/Exec.hx:68
        timestampStr = a8_PathOps.timestampStr()
        # src/a8/Exec.hx:70
        stdoutCapture = haxe_io_BytesOutput()
        # src/a8/Exec.hx:71
        stderrCapture = haxe_io_BytesOutput()
        # src/a8/Exec.hx:73
        pipedStdout = a8_Pipe(a8_StreamOps.asInputStream(popen6.stdout),a8_StreamOps2.asOutputStream(stdoutCapture),firstIO)
        # src/a8/Exec.hx:74
        pipedStderr = a8_Pipe(a8_StreamOps.asInputStream(popen6.stderr),a8_StreamOps2.asOutputStream(stderrCapture),firstIO)
        # src/a8/Exec.hx:76
        pipedStdout.run()
        # src/a8/Exec.hx:77
        pipedStderr.run()
        # src/a8/Exec.hx:79
        popen6.wait()
        # src/a8/Exec.hx:81
        result = _hx_AnonObject({'exitCode': popen6.returncode, 'stderr': a8_HaxeOps.asString(stderrCapture.getBytes()), 'stdout': a8_HaxeOps.asString(stdoutCapture.getBytes())})
        # src/a8/Exec.hx:88
        a8_Logger.trace(("" + Std.string(result.exitCode)),_hx_AnonObject({'fileName': "Exec.hx", 'lineNumber': 88, 'className': "a8.Exec", 'methodName': "execCapture"}))
        # src/a8/Exec.hx:89
        if ((result.exitCode != 0) and self.failOnNonZeroExitCode):
            a8_Exception.thro(((("non-zero exit code of " + Std.string(result.exitCode)) + " while executing -- ") + HxOverrides.stringOrNull(self.asCommandLine())))
        # src/a8/Exec.hx:93
        return result

a8_Exec._hx_class = a8_Exec


class a8_PyOps:
    _hx_class_name = "a8.PyOps"
    __slots__ = ()
    _hx_statics = ["toDict", "spawn"]

    @staticmethod
    def toDict(_hx_map):
        # src/a8/PyOps.hx:53
        _hx_dict = dict()
        # src/a8/PyOps.hx:54
        # src/a8/PyOps.hx:54
        k = _hx_map.keys()
        while k.hasNext():
            k1 = k.next()
            # src/a8/PyOps.hx:55
            _hx_dict[k1] = _hx_map.get(k1)
        # src/a8/PyOps.hx:57
        return _hx_dict

    @staticmethod
    def spawn(fn):
        # src/a8/PyOps.hx:62
        th = python_lib_threading_Thread(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'target': fn})))
        # src/a8/PyOps.hx:63
        th.daemon = True
        # src/a8/PyOps.hx:64
        th.start()
        # src/a8/PyOps.hx:66
        return th
a8_PyOps._hx_class = a8_PyOps


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/KwArgs.hx:57
        this1 = python_Lib.anonAsDict(d)
        return this1
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["print", "println", "dictToAnon", "anonToDict", "anonAsDict", "dictAsAnon"]

    @staticmethod
    def print(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:40
        _hx_str = Std.string(v)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:42
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:43
        python_lib_Sys.stdout.flush()

    @staticmethod
    def println(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:50
        _hx_str = Std.string(v)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:52
        python_lib_Sys.stdout.buffer.write((("" + ("null" if _hx_str is None else _hx_str)) + "\n").encode("utf-8", "strict"))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:53
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:60
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:69
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:83
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None

    @staticmethod
    def dictAsAnon(d):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Lib.hx:95
        return _hx_AnonObject(d)
python_Lib._hx_class = python_Lib


class a8_GlobalScheduler:
    _hx_class_name = "a8.GlobalScheduler"
    __slots__ = ()
    _hx_statics = ["scheduler", "schedule", "submit"]

    @staticmethod
    def schedule(delayInSeconds,fn):
        # src/a8/GlobalScheduler.hx:22
        a8_GlobalScheduler.scheduler.enter(delayInSeconds,1.0,fn)

    @staticmethod
    def submit(fn):
        # src/a8/GlobalScheduler.hx:26
        a8_GlobalScheduler.schedule(0,fn)
a8_GlobalScheduler._hx_class = a8_GlobalScheduler


class a8_HaxeOps:
    _hx_class_name = "a8.HaxeOps"
    __slots__ = ()
    _hx_statics = ["asString", "toMap"]

    @staticmethod
    def asString(_hx_bytes):
        # src/a8/HaxeOps.hx:12
        return _hx_bytes.getString(0,_hx_bytes.length)

    @staticmethod
    def toMap(iterable,keyFn):
        # src/a8/HaxeOps.hx:16
        _hx_map = haxe_ds_StringMap()
        # src/a8/HaxeOps.hx:17
        def _hx_local_0(a):
            # src/a8/HaxeOps.hx:17
            key = keyFn(a)
            _hx_map.h[key] = a
        Lambda.iter(iterable,_hx_local_0)
        # src/a8/HaxeOps.hx:18
        return _hx_map
a8_HaxeOps._hx_class = a8_HaxeOps


class a8_HaxeOps2:
    _hx_class_name = "a8.HaxeOps2"
    __slots__ = ()
    _hx_statics = ["asString", "toMap"]

    @staticmethod
    def asString(stack,indent = None):
        # src/a8/HaxeOps.hx:29
        if (indent is None):
            indent = ""
        # src/a8/HaxeOps.hx:33
        def _hx_local_0(si):
            # src/a8/HaxeOps.hx:33
            _this1 = Std.string(si)
            return (("null" if indent is None else indent) + ("null" if _this1 is None else _this1))
        # src/a8/HaxeOps.hx:32
        _this = list(map(_hx_local_0,stack))
        s = "\n".join([python_Boot.toString1(x1,'') for x1 in _this])
        # src/a8/HaxeOps.hx:35
        return s

    @staticmethod
    def toMap(iterable):
        # src/a8/HaxeOps.hx:39
        _hx_map = haxe_ds_StringMap()
        # src/a8/HaxeOps.hx:40
        # src/a8/HaxeOps.hx:40
        t = HxOverrides.iterator(iterable)
        while t.hasNext():
            t1 = t.next()
            # src/a8/HaxeOps.hx:41
            _hx_map.h[python_internal_ArrayImpl._get(t1, 0)] = python_internal_ArrayImpl._get(t1, 1)
        # src/a8/HaxeOps.hx:43
        return _hx_map
a8_HaxeOps2._hx_class = a8_HaxeOps2


class a8_Logger:
    _hx_class_name = "a8.Logger"
    __slots__ = ()
    _hx_statics = ["traceEnabled", "trace", "warn"]

    @staticmethod
    def trace(msg,posInfo = None):
        # src/a8/Logger.hx:12
        if a8_Logger.traceEnabled:
            haxe_Log.trace(("TRACE - " + ("null" if msg is None else msg)),posInfo)

    @staticmethod
    def warn(msg,posInfo = None):
        # src/a8/Logger.hx:18
        haxe_Log.trace(("WARN - " + ("null" if msg is None else msg)),posInfo)
a8_Logger._hx_class = a8_Logger


class a8_OptionOps:
    _hx_class_name = "a8.OptionOps"
    __slots__ = ()
    _hx_statics = ["toOption", "nonEmpty", "isEmpty", "getOrError", "getOrElse", "getOrElseFn", "get", "iter"]

    @staticmethod
    def toOption(a):
        # src/a8/OptionOps.hx:14
        if (a is None):
            return haxe_ds_Option._hx_None
        else:
            return haxe_ds_Option.Some(a)

    @staticmethod
    def nonEmpty(o):
        # src/a8/OptionOps.hx:20
        o1 = o.index
        # src/a8/OptionOps.hx:21
        if (o1 == 0):
            return True
        elif (o1 == 1):
            return False
        else:
            pass

    @staticmethod
    def isEmpty(o):
        # src/a8/OptionOps.hx:27
        return (not a8_OptionOps.nonEmpty(o))

    @staticmethod
    def getOrError(o,msg):
        # src/a8/OptionOps.hx:33
        o1 = o.index
        # src/a8/OptionOps.hx:34
        if (o1 == 0):
            # src/a8/OptionOps.hx:34
            i = o.params[0]
            return i
        elif (o1 == 1):
            raise _HxException(a8_Exception(msg,None,_hx_AnonObject({'fileName': "OptionOps.hx", 'lineNumber': 35, 'className': "a8.OptionOps", 'methodName': "getOrError"})))
        else:
            pass

    @staticmethod
    def getOrElse(o,_hx_def):
        # src/a8/OptionOps.hx:41
        o1 = o.index
        # src/a8/OptionOps.hx:42
        if (o1 == 0):
            # src/a8/OptionOps.hx:42
            i = o.params[0]
            return i
        elif (o1 == 1):
            return _hx_def
        else:
            pass

    @staticmethod
    def getOrElseFn(o,_hx_def):
        # src/a8/OptionOps.hx:49
        o1 = o.index
        # src/a8/OptionOps.hx:50
        if (o1 == 0):
            # src/a8/OptionOps.hx:50
            i = o.params[0]
            return i
        elif (o1 == 1):
            return _hx_def()
        else:
            pass

    @staticmethod
    def get(o):
        # src/a8/OptionOps.hx:56
        return a8_OptionOps.getOrError(o,"expected a Some")

    @staticmethod
    def iter(o,fn):
        # src/a8/OptionOps.hx:61
        o1 = o.index
        # src/a8/OptionOps.hx:62
        if (o1 == 0):
            # src/a8/OptionOps.hx:62
            a = o.params[0]
            fn(a)
        elif (o1 == 1):
            pass
        else:
            pass
        # src/a8/OptionOps.hx:60
        return
a8_OptionOps._hx_class = a8_OptionOps


class a8_PathOps:
    _hx_class_name = "a8.PathOps"
    __slots__ = ()
    _hx_statics = ["timestampStr", "path", "symlinkChain", "executablePath", "userHome", "absPath", "name", "programPath", "readText", "readLines", "makeDirectories", "readBytes", "exists", "isAbsolute", "files", "basename", "moveTo", "deleteFile", "entries", "isFile", "isDir", "realPathStr", "writeBytes", "writeText", "parent", "entry", "outputStream", "readProperties"]

    @staticmethod
    def timestampStr():
        # src/a8/PathOps.hx:14
        now = Date.now()
        # src/a8/PathOps.hx:16
        def _hx_local_0(i):
            # src/a8/PathOps.hx:16
            return StringTools.lpad(("" + Std.string(i)),"0",2)
        # src/a8/PathOps.hx:15
        pad = _hx_local_0
        # src/a8/PathOps.hx:18
        return ((((((Std.string(now.date.year) + HxOverrides.stringOrNull(pad((now.date.month - 1)))) + HxOverrides.stringOrNull(pad(now.date.day))) + "_") + HxOverrides.stringOrNull(pad(now.date.hour))) + HxOverrides.stringOrNull(pad(now.date.minute))) + HxOverrides.stringOrNull(pad(now.date.second)))

    @staticmethod
    def path(p):
        # src/a8/PathOps.hx:22
        return haxe_io_Path(p)

    @staticmethod
    def symlinkChain(p):
        # src/a8/PathOps.hx:26
        paths = []
        # src/a8/PathOps.hx:27
        impl = None
        def _hx_local_0(thePath):
            # src/a8/PathOps.hx:28
            # src/a8/PathOps.hx:28
            x = a8_PathOps.absPath(thePath)
            paths.append(x)
            # src/a8/PathOps.hx:29
            if python_lib_os_Path.islink(thePath.toString()):
                # src/a8/PathOps.hx:30
                relativeLink = a8_PyOs2.readlink(thePath.toString())
                # src/a8/PathOps.hx:31
                absoluteLink = (relativeLink if (python_lib_os_Path.isabs(relativeLink)) else python_lib_os_Path.join(a8_PathOps.parent(thePath).toString(),relativeLink))
                # src/a8/PathOps.hx:36
                p1 = a8_PathOps.path(absoluteLink)
                # src/a8/PathOps.hx:37
                impl(p1)
        impl = _hx_local_0
        impl1 = impl
        # src/a8/PathOps.hx:40
        impl1(p)
        # src/a8/PathOps.hx:41
        return paths

    @staticmethod
    def executablePath():
        # src/a8/PathOps.hx:49
        return a8_PlatformOps.instance.executablePath()

    @staticmethod
    def userHome():
        # src/a8/PathOps.hx:53
        return haxe_io_Path(Sys.environment().h.get("HOME",None))

    @staticmethod
    def absPath(p):
        # src/a8/PathOps.hx:57
        return a8_PlatformOps.instance.absPath(p)

    @staticmethod
    def name(p):
        # src/a8/PathOps.hx:62
        if (p.ext is None):
            return p.file
        else:
            return ((HxOverrides.stringOrNull(p.file) + ".") + HxOverrides.stringOrNull(p.ext))

    @staticmethod
    def programPath():
        # src/a8/PathOps.hx:74
        return haxe_io_Path(Sys.programPath())

    @staticmethod
    def readText(path):
        # src/a8/PathOps.hx:78
        return sys_io_File.getContent(path.toString())

    @staticmethod
    def readLines(path):
        # src/a8/PathOps.hx:82
        _this = a8_PathOps.readText(path)
        return _this.split("\n")

    @staticmethod
    def makeDirectories(path):
        # src/a8/PathOps.hx:86
        sys_FileSystem.createDirectory(path.toString())

    @staticmethod
    def readBytes(path):
        # src/a8/PathOps.hx:90
        return sys_io_File.getBytes(path.toString())

    @staticmethod
    def exists(path):
        # src/a8/PathOps.hx:94
        return sys_FileSystem.exists(path.toString())

    @staticmethod
    def isAbsolute(path):
        # src/a8/PathOps.hx:98
        return haxe_io_Path.isAbsolute(path.toString())

    @staticmethod
    def files(parentDir):
        # src/a8/PathOps.hx:103
        def _hx_local_1():
            # src/a8/PathOps.hx:105
            def _hx_local_0(e):
                # src/a8/PathOps.hx:105
                return a8_PathOps.isFile(e)
            # src/a8/PathOps.hx:103
            return list(filter(_hx_local_0,a8_PathOps.entries(parentDir)))
        return _hx_local_1()

    @staticmethod
    def basename(path):
        # src/a8/PathOps.hx:113
        suffix = ("" if ((path.ext is None)) else ("." + HxOverrides.stringOrNull(path.ext)))
        # src/a8/PathOps.hx:114
        return (HxOverrides.stringOrNull(path.file) + ("null" if suffix is None else suffix))

    @staticmethod
    def moveTo(source,target):
        # src/a8/PathOps.hx:118
        a8_PlatformOps.instance.moveTo(source,target)

    @staticmethod
    def deleteFile(source):
        # src/a8/PathOps.hx:122
        if a8_PathOps.exists(source):
            sys_FileSystem.deleteFile(source.toString())

    @staticmethod
    def entries(parentDir):
        # src/a8/PathOps.hx:128
        sep = ("" if (parentDir.backslash) else "/")
        # src/a8/PathOps.hx:130
        if a8_PathOps.exists(parentDir):
            # src/a8/PathOps.hx:131
            def _hx_local_1():
                # src/a8/PathOps.hx:134
                def _hx_local_0(e):
                    # src/a8/PathOps.hx:134
                    return haxe_io_Path(((HxOverrides.stringOrNull(parentDir.toString()) + ("null" if sep is None else sep)) + ("null" if e is None else e)))
                # src/a8/PathOps.hx:131
                return list(map(_hx_local_0,sys_FileSystem.readDirectory(a8_PathOps.realPathStr(parentDir))))
            return _hx_local_1()
        else:
            return []

    @staticmethod
    def isFile(path):
        # src/a8/PathOps.hx:141
        return a8_PlatformOps.instance.isFile(path)

    @staticmethod
    def isDir(path):
        # src/a8/PathOps.hx:145
        return sys_FileSystem.isDirectory(path.toString())

    @staticmethod
    def realPathStr(path):
        # src/a8/PathOps.hx:149
        return sys_FileSystem.fullPath(path.toString())

    @staticmethod
    def writeBytes(path,_hx_bytes):
        # src/a8/PathOps.hx:153
        sys_io_File.saveBytes(path.toString(),_hx_bytes)

    @staticmethod
    def writeText(path,text):
        # src/a8/PathOps.hx:157
        sys_io_File.saveContent(path.toString(),text)

    @staticmethod
    def parent(path):
        # src/a8/PathOps.hx:161
        _g = path.dir
        # src/a8/PathOps.hx:1
        if (_g is None):
            if a8_PathOps.isAbsolute(path):
                return None
            else:
                return haxe_io_Path(sys_FileSystem.fullPath("."))
        else:
            # src/a8/PathOps.hx:168
            d = _g
            # src/a8/PathOps.hx:169
            return haxe_io_Path(d)

    @staticmethod
    def entry(dir,name):
        # src/a8/PathOps.hx:174
        separator = ("" if (dir.backslash) else "/")
        # src/a8/PathOps.hx:175
        return haxe_io_Path(((HxOverrides.stringOrNull(dir.toString()) + ("null" if separator is None else separator)) + ("null" if name is None else name)))

    @staticmethod
    def outputStream(p):
        # src/a8/PathOps.hx:179
        return a8_StreamOps.fileOutputStream(a8_PathOps.realPathStr(p))

    @staticmethod
    def readProperties(p,failOnNotFound = None):
        # src/a8/PathOps.hx:183
        rf = a8_OptionOps.getOrElse(a8_OptionOps.toOption(failOnNotFound),False)
        # src/a8/PathOps.hx:184
        exists = a8_PathOps.exists(p)
        # src/a8/PathOps.hx:186
        if ((not exists) and (not rf)):
            return haxe_ds_StringMap()
        else:
            # src/a8/PathOps.hx:189
            def _hx_local_1():
                # src/a8/PathOps.hx:190
                def _hx_local_0(line):
                    # src/a8/PathOps.hx:191
                    a = line.split("=")
                    # src/a8/PathOps.hx:193
                    if (len(a) == 2):
                        # src/a8/PathOps.hx:194
                        this1 = [(a[0] if 0 < len(a) else None), (a[1] if 1 < len(a) else None)]
                        return [this1]
                    else:
                        return []
                # src/a8/PathOps.hx:189
                return a8_HaxeOps2.toMap(Lambda.flatMap(a8_PathOps.readLines(p),_hx_local_0))
            return _hx_local_1()
a8_PathOps._hx_class = a8_PathOps


class a8_AbstractPlatform:
    _hx_class_name = "a8.AbstractPlatform"
    __slots__ = ()
    _hx_methods = ["isFile", "spawn", "moveTo"]

    def isFile(self,path):
        # src/a8/Platform.hx:42
        e = sys_FileSystem.exists(path.toString())
        # src/a8/Platform.hx:43
        d = sys_FileSystem.isDirectory(path.toString())
        # src/a8/Platform.hx:44
        if e:
            return (not d)
        else:
            return False

    def spawn(self,threadName,fn):
        # src/a8/Platform.hx:48
        raise _HxException(a8_Exception("TODO ??? implement me",None,_hx_AnonObject({'fileName': "Platform.hx", 'lineNumber': 48, 'className': "a8.AbstractPlatform", 'methodName': "spawn"})))

    def moveTo(self,source,target):
        # src/a8/Platform.hx:52
        raise _HxException(a8_Exception("TODO ??? implement me",None,_hx_AnonObject({'fileName': "Platform.hx", 'lineNumber': 52, 'className': "a8.AbstractPlatform", 'methodName': "moveTo"})))

a8_AbstractPlatform._hx_class = a8_AbstractPlatform


class a8_Platform:
    _hx_class_name = "a8.Platform"
    __slots__ = ()
    _hx_methods = ["executablePath", "isFile", "spawn", "moveTo", "absPath"]
a8_Platform._hx_class = a8_Platform


class a8_PythonPlatform(a8_AbstractPlatform):
    _hx_class_name = "a8.PythonPlatform"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["absPath", "executablePath", "isFile", "spawn", "moveTo"]
    _hx_statics = []
    _hx_super = a8_AbstractPlatform


    def __init__(self):
        pass

    def absPath(self,path):
        # src/a8/Platform.hx:77
        return a8_PathOps.path(python_lib_os_Path.normpath(python_lib_os_Path.abspath(path.toString())))

    def executablePath(self):
        # src/a8/Platform.hx:81
        return haxe_io_Path(python_internal_ArrayImpl._get(python_lib_Sys.argv, 0))

    def isFile(self,path):
        # src/a8/Platform.hx:85
        return python_lib_os_Path.isfile(path.toString())

    def spawn(self,threadName,fn):
        # src/a8/Platform.hx:89
        th = python_lib_threading_Thread(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'target': fn})))
        # src/a8/Platform.hx:90
        th.start()

    def moveTo(self,source,target):
        # src/a8/Platform.hx:94
        a8_PyShutil2.move(source.toString(),target.toString())

a8_PythonPlatform._hx_class = a8_PythonPlatform


class a8_PlatformOps:
    _hx_class_name = "a8.PlatformOps"
    __slots__ = ()
    _hx_statics = ["instance"]
a8_PlatformOps._hx_class = a8_PlatformOps


class a8_StreamOps:
    _hx_class_name = "a8.StreamOps"
    __slots__ = ()
    _hx_statics = ["asInputStream", "asOutputStream", "fileOutputStream"]

    @staticmethod
    def asInputStream(fileIO):
        # src/a8/StreamOps.hx:12
        return a8_FileIOInputStream(fileIO)

    @staticmethod
    def asOutputStream(io):
        # src/a8/StreamOps.hx:16
        return a8_TextIOBaseOutputStream(io)

    @staticmethod
    def fileOutputStream(filename):
        # src/a8/StreamOps.hx:20
        return a8_StreamOps.asOutputStream(python_lib_Io.open(filename,"wt"))
a8_StreamOps._hx_class = a8_StreamOps


class a8_StreamOps2:
    _hx_class_name = "a8.StreamOps2"
    __slots__ = ()
    _hx_statics = ["asOutputStream"]

    @staticmethod
    def asOutputStream(output):
        # src/a8/StreamOps.hx:28
        return a8_OutputOutputStream(output)
a8_StreamOps2._hx_class = a8_StreamOps2


class a8_OutputStream:
    _hx_class_name = "a8.OutputStream"
    __slots__ = ()
    _hx_methods = ["write", "flush", "close"]
a8_OutputStream._hx_class = a8_OutputStream


class a8_InputStream:
    _hx_class_name = "a8.InputStream"
    __slots__ = ()
    _hx_methods = ["readLine", "close"]
a8_InputStream._hx_class = a8_InputStream


class a8_FileIOInputStream:
    _hx_class_name = "a8.FileIOInputStream"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["readLine", "close"]

    def __init__(self,delegate):
        # src/a8/Streams.hx:29
        self.delegate = None
        self.delegate = delegate

    def readLine(self):
        # src/a8/Streams.hx:32
        _hx_bytes = self.delegate.readline()
        # src/a8/Streams.hx:33
        line = _hx_bytes.decode()
        # src/a8/Streams.hx:36
        if StringTools.endsWith(line,"\n"):
            return HxString.substr(line,0,(len(line) - 1))
        else:
            return None

    def close(self):
        pass

a8_FileIOInputStream._hx_class = a8_FileIOInputStream


class a8_TextIOBaseOutputStream:
    _hx_class_name = "a8.TextIOBaseOutputStream"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]

    def __init__(self,delegate):
        # src/a8/Streams.hx:53
        self.delegate = None
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:56
        self.delegate.write(s)

    def flush(self):
        # src/a8/Streams.hx:60
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:64
        self.delegate.close()

a8_TextIOBaseOutputStream._hx_class = a8_TextIOBaseOutputStream


class a8_OutputOutputStream:
    _hx_class_name = "a8.OutputOutputStream"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]

    def __init__(self,delegate):
        # src/a8/Streams.hx:73
        self.delegate = None
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:76
        self.delegate.writeString(s)

    def flush(self):
        # src/a8/Streams.hx:80
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:84
        self.delegate.close()

a8_OutputOutputStream._hx_class = a8_OutputOutputStream


class a8_FileIOOutputStream:
    _hx_class_name = "a8.FileIOOutputStream"
    __slots__ = ("delegate",)
    _hx_fields = ["delegate"]
    _hx_methods = ["write", "flush", "close"]

    def __init__(self,delegate):
        # src/a8/Streams.hx:92
        self.delegate = None
        self.delegate = delegate

    def write(self,s):
        # src/a8/Streams.hx:95
        self.delegate.write(bytes(s,"utf-8"))

    def flush(self):
        # src/a8/Streams.hx:99
        self.delegate.flush()

    def close(self):
        # src/a8/Streams.hx:103
        self.delegate.close()

a8_FileIOOutputStream._hx_class = a8_FileIOOutputStream


class a8_TeeOutputStream:
    _hx_class_name = "a8.TeeOutputStream"
    __slots__ = ("outputs",)
    _hx_fields = ["outputs"]
    _hx_methods = ["write", "flush", "close"]

    def __init__(self,outputs):
        # src/a8/Streams.hx:115
        self.outputs = outputs

    def write(self,s):
        # src/a8/Streams.hx:120
        def _hx_local_0(os):
            # src/a8/Streams.hx:120
            os.write(s)
        # src/a8/Streams.hx:119
        Lambda.iter(self.outputs,_hx_local_0)

    def flush(self):
        # src/a8/Streams.hx:126
        def _hx_local_0(os):
            # src/a8/Streams.hx:126
            os.flush()
        # src/a8/Streams.hx:125
        Lambda.iter(self.outputs,_hx_local_0)

    def close(self):
        # src/a8/Streams.hx:132
        def _hx_local_0(os):
            # src/a8/Streams.hx:132
            os.close()
        # src/a8/Streams.hx:131
        Lambda.iter(self.outputs,_hx_local_0)

a8_TeeOutputStream._hx_class = a8_TeeOutputStream


class a8_Pipe:
    _hx_class_name = "a8.Pipe"
    __slots__ = ("input", "output", "firstIO", "byteCount", "replaceOutput")
    _hx_fields = ["input", "output", "firstIO", "byteCount", "replaceOutput"]
    _hx_methods = ["run"]

    def __init__(self,input,output,firstIO):
        # src/a8/Streams.hx:148
        self.replaceOutput = None
        # src/a8/Streams.hx:151
        self.input = input
        # src/a8/Streams.hx:152
        self.output = output
        # src/a8/Streams.hx:153
        self.firstIO = firstIO
        # src/a8/Streams.hx:154
        self.byteCount = 0

    def run(self):
        # src/a8/Streams.hx:160
        _gthis = self
        # src/a8/Streams.hx:162
        def _hx_local_1():
            # src/a8/Streams.hx:163
            first = True
            # src/a8/Streams.hx:164
            cont = True
            # src/a8/Streams.hx:165
            while cont:
                # src/a8/Streams.hx:166
                line = _gthis.input.readLine()
                # src/a8/Streams.hx:167
                if (_gthis.replaceOutput is not None):
                    # src/a8/Streams.hx:168
                    _gthis.output = _gthis.replaceOutput(_gthis.output)
                    # src/a8/Streams.hx:169
                    first = True
                # src/a8/Streams.hx:171
                if (line is None):
                    cont = False
                else:
                    # src/a8/Streams.hx:174
                    if first:
                        # src/a8/Streams.hx:175
                        _gthis.firstIO(_gthis.output)
                        # src/a8/Streams.hx:176
                        first = False
                    # src/a8/Streams.hx:178
                    _gthis.output.write(line)
                    # src/a8/Streams.hx:179
                    _gthis.output.write("\n")
                    # src/a8/Streams.hx:180
                    _gthis.output.flush()
                    # src/a8/Streams.hx:181
                    _gthis.byteCount = (_gthis.byteCount + ((len(line) + 1)))
            # src/a8/Streams.hx:184
            _gthis.output.close()
        impl = _hx_local_1
        # src/a8/Streams.hx:187
        a8_PlatformOps.instance.spawn("pipe",impl)

a8_Pipe._hx_class = a8_Pipe


class a8__Tuple2_Tuple2_Impl_:
    _hx_class_name = "a8._Tuple2.Tuple2_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "_1", "_2", "toString"]

    @staticmethod
    def _new(a,b):
        # src/a8/Tuple2.hx:6
        this1 = [a, b]
        return this1

    @staticmethod
    def _1(this1):
        # src/a8/Tuple2.hx:11
        return (this1[0] if 0 < len(this1) else None)

    @staticmethod
    def _2(this1):
        # src/a8/Tuple2.hx:15
        return (this1[1] if 1 < len(this1) else None)

    @staticmethod
    def toString(this1):
        # src/a8/Tuple2.hx:19
        return haxe_format_JsonPrinter.print(this1,None,None)
a8__Tuple2_Tuple2_Impl_._hx_class = a8__Tuple2_Tuple2_Impl_

class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, [v])
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, list())
haxe_ds_Option._hx_class = haxe_ds_Option


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent", "getBytes", "saveBytes"]

    @staticmethod
    def getContent(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:32
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:33
        content = f.read(-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:34
        f.close()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:35
        return content

    @staticmethod
    def saveContent(path,content):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:39
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:40
        f.write(content)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:41
        f.close()

    @staticmethod
    def getBytes(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:45
        f = python_lib_Builtins.open(path,"rb",-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:46
        size = f.read(-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:47
        b = haxe_io_Bytes.ofData(size)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:48
        f.close()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:49
        return b

    @staticmethod
    def saveBytes(path,_hx_bytes):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:53
        f = python_lib_Builtins.open(path,"wb",-1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:54
        f.write(_hx_bytes.b)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/File.hx:55
        f.close()
sys_io_File._hx_class = sys_io_File


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["isAbsolute"]

    def __init__(self,path):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:68
        self.backslash = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:63
        self.ext = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:53
        self.file = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:43
        self.dir = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:77
        path1 = path
        _hx_local_0 = len(path1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:78
        if (_hx_local_0 == 1):
            if (path1 == "."):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:79
                self.dir = path
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:80
                self.file = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:81
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:79
                self.dir = path
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:80
                self.file = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:81
                return
        else:
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:83
        c1 = path.rfind("/", 0, len(path))
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:84
        c2 = path.rfind("\\", 0, len(path))
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:85
        if (c1 < c2):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:86
            self.dir = HxString.substr(path,0,c2)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:87
            path = HxString.substr(path,(c2 + 1),None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:88
            self.backslash = True
        elif (c2 < c1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:90
            self.dir = HxString.substr(path,0,c1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:91
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:94
        cp = path.rfind(".", 0, len(path))
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:95
        if (cp != -1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:96
            self.ext = HxString.substr(path,(cp + 1),None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:97
            self.file = HxString.substr(path,0,cp)
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:99
            self.ext = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:100
            self.file = path

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:115
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def isAbsolute(path):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:302
        if StringTools.startsWith(path,"/"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:303
        if ((("" if ((1 >= len(path))) else path[1])) == ":"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:304
        if StringTools.startsWith(path,"\\\\"):
            return True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Path.hx:305
        return False

haxe_io_Path._hx_class = haxe_io_Path


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:31
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:37
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:43
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:48
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:52
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:53
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:54
            check = s.find(_hx_str, startLeft, len(s))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:55
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:66
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:70
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:74
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:81
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:97
        if (startIndex < 0):
            startIndex = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:98
        if (endIndex is None):
            return s[startIndex:]
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:101
            if (endIndex < 0):
                endIndex = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:102
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:113
        if (_hx_len is None):
            return s[startIndex:]
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:116
            if (_hx_len == 0):
                return ""
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/StringImpl.hx:117
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class a8_UserConfig:
    _hx_class_name = "a8.UserConfig"
    __slots__ = ()
    _hx_statics = ["sbtCredentials", "versions"]
a8_UserConfig._hx_class = a8_UserConfig


class a8_launcher_CommandLineProcessor:
    _hx_class_name = "a8.launcher.CommandLineProcessor"
    __slots__ = ("lazy_argDefs", "argDefs")
    _hx_fields = ["lazy_argDefs", "argDefs"]
    _hx_methods = ["apply", "get_argDefs"]

    def __init__(self):
        # src/a8/launcher/CommandLineProcessor.hx:9
        self.argDefs = None
        self.lazy_argDefs = None
        def _hx_local_4():
            def _hx_local_3():
                # src/a8/launcher/CommandLineProcessor.hx:14
                def _hx_local_0(config,args):
                    # src/a8/launcher/CommandLineProcessor.hx:14
                    Reflect.setField(config,"explicitVersion",args)
                # src/a8/launcher/CommandLineProcessor.hx:20
                def _hx_local_1(config1,args1):
                    # src/a8/launcher/CommandLineProcessor.hx:20
                    Reflect.setField(config1,"quiet",a8_OptionOps.isEmpty(args1))
                # src/a8/launcher/CommandLineProcessor.hx:26
                def _hx_local_2(config2,args2):
                    # src/a8/launcher/CommandLineProcessor.hx:26
                    Reflect.setField(config2,"resolveOnly",a8_OptionOps.nonEmpty(args2))
                # src/a8/launcher/CommandLineProcessor.hx:9
                return [_hx_AnonObject({'name': "--l-version", 'parmCount': 1, 'apply': _hx_local_0}), _hx_AnonObject({'name': "--l-verbose", 'parmCount': 0, 'apply': _hx_local_1}), _hx_AnonObject({'name': "--l-resolveOnly", 'parmCount': 0, 'apply': _hx_local_2})]
            return _hx_local_3()
        self.lazy_argDefs = tink_core__Lazy_LazyFunc(_hx_local_4)

    def apply(self,initialConfig):
        # src/a8/launcher/CommandLineProcessor.hx:35
        config = Reflect.copy(initialConfig)
        # src/a8/launcher/CommandLineProcessor.hx:37
        newArgs = []
        # src/a8/launcher/CommandLineProcessor.hx:38
        Reflect.setField(config,"resolvedCommandLineArgs",newArgs)
        # src/a8/launcher/CommandLineProcessor.hx:39
        temp = list(Reflect.field(initialConfig,"rawCommandLineArgs"))
        # src/a8/launcher/CommandLineProcessor.hx:42
        temp.reverse()
        # src/a8/launcher/CommandLineProcessor.hx:43
        if (len(temp) != 0):
            temp.pop()
        # src/a8/launcher/CommandLineProcessor.hx:45
        while (len(temp) > 0):
            # src/a8/launcher/CommandLineProcessor.hx:46
            a = [(None if ((len(temp) == 0)) else temp.pop())]
            # src/a8/launcher/CommandLineProcessor.hx:47
            def _hx_local_1(a1):
                # src/a8/launcher/CommandLineProcessor.hx:47
                def _hx_local_0(ad):
                    # src/a8/launcher/CommandLineProcessor.hx:47
                    return (ad.name == (a1[0] if 0 < len(a1) else None))
                return _hx_local_0
            argDef = Lambda.find(self.get_argDefs(),_hx_local_1(a))
            # src/a8/launcher/CommandLineProcessor.hx:48
            if (argDef is None):
                # src/a8/launcher/CommandLineProcessor.hx:49
                if StringTools.startsWith((a[0] if 0 < len(a) else None),"--l-"):
                    raise _HxException(a8_Exception(("don't know how to handle arg -- " + HxOverrides.stringOrNull((a[0] if 0 < len(a) else None))),None,_hx_AnonObject({'fileName': "CommandLineProcessor.hx", 'lineNumber': 50, 'className': "a8.launcher.CommandLineProcessor", 'methodName': "apply"})))
                # src/a8/launcher/CommandLineProcessor.hx:52
                newArgs.append((a[0] if 0 < len(a) else None))
            else:
                # src/a8/launcher/CommandLineProcessor.hx:54
                parms = None
                # src/a8/launcher/CommandLineProcessor.hx:55
                if (argDef.parmCount == 0):
                    parms = haxe_ds_Option.Some(argDef.name)
                elif (argDef.parmCount == 1):
                    parms = haxe_ds_Option.Some((None if ((len(temp) == 0)) else temp.pop()))
                else:
                    raise _HxException(a8_Exception("can only handle parmCount of 0 or 1",None,_hx_AnonObject({'fileName': "CommandLineProcessor.hx", 'lineNumber': 57, 'className': "a8.launcher.CommandLineProcessor", 'methodName': "apply"})))
                # src/a8/launcher/CommandLineProcessor.hx:58
                argDef.apply(config,parms)
                # src/a8/launcher/CommandLineProcessor.hx:59
                Reflect.setField(argDef,"processed",True)
        # src/a8/launcher/CommandLineProcessor.hx:65
        def _hx_local_2(ad1):
            # src/a8/launcher/CommandLineProcessor.hx:65
            if (not Reflect.field(ad1,"processed")):
                ad1.apply(config,haxe_ds_Option._hx_None)
        # src/a8/launcher/CommandLineProcessor.hx:64
        Lambda.iter(self.get_argDefs(),_hx_local_2)
        # src/a8/launcher/CommandLineProcessor.hx:72
        return config

    def get_argDefs(self):
        # src/a8/launcher/CommandLineProcessor.hx:9
        return self.lazy_argDefs.get()

a8_launcher_CommandLineProcessor._hx_class = a8_launcher_CommandLineProcessor


class a8_launcher_Launcher:
    _hx_class_name = "a8.launcher.Launcher"
    __slots__ = ("lazy_logArchivesDir", "lazy_logsDir", "lazy_installDir", "lazy_a8VersionsCache", "config", "appName", "initialArgs", "a8VersionsCache", "installDir", "logsDir", "logArchivesDir", "pipedStdout", "pipedStderr", "logRollers")
    _hx_fields = ["lazy_logArchivesDir", "lazy_logsDir", "lazy_installDir", "lazy_a8VersionsCache", "config", "appName", "initialArgs", "a8VersionsCache", "installDir", "logsDir", "logArchivesDir", "pipedStdout", "pipedStderr", "logRollers"]
    _hx_methods = ["logTrace", "logWarn", "_log", "archiveOldLogs", "archiveLogFiles", "resolveStandardArgs", "resolveJvmCliLaunchArgs", "resolveJvmLaunchArgs", "runAndWait", "initializeLogRollers", "get_a8VersionsCache", "get_installDir", "get_logsDir", "get_logArchivesDir"]
    _hx_statics = ["initDirectory"]

    def __init__(self,config,appName,initialArgs):
        # src/a8/launcher/Launcher.hx:34
        self.logRollers = None
        # src/a8/launcher/Launcher.hx:33
        self.pipedStderr = None
        # src/a8/launcher/Launcher.hx:32
        self.pipedStdout = None
        # src/a8/launcher/Launcher.hx:30
        self.logArchivesDir = None
        # src/a8/launcher/Launcher.hx:29
        self.logsDir = None
        # src/a8/launcher/Launcher.hx:28
        self.installDir = None
        # src/a8/launcher/Launcher.hx:25
        self.a8VersionsCache = None
        # src/a8/launcher/Launcher.hx:22
        self.initialArgs = None
        # src/a8/launcher/Launcher.hx:20
        self.appName = None
        # src/a8/launcher/Launcher.hx:19
        self.config = None
        # src/a8/launcher/Launcher.hx:25
        self.lazy_a8VersionsCache = None
        # src/a8/launcher/Launcher.hx:28
        self.lazy_installDir = None
        # src/a8/launcher/Launcher.hx:29
        self.lazy_logsDir = None
        # src/a8/launcher/Launcher.hx:30
        self.lazy_logArchivesDir = None
        # ?:1
        _gthis = self
        # src/a8/launcher/Launcher.hx:30
        def _hx_local_0():
            # src/a8/launcher/Launcher.hx:30
            return a8_launcher_Launcher.initDirectory("archives",None,_gthis.get_logsDir(),Reflect.field(_gthis.config,"logFiles"))
        self.lazy_logArchivesDir = tink_core__Lazy_LazyFunc(_hx_local_0)
        # src/a8/launcher/Launcher.hx:29
        def _hx_local_1():
            # src/a8/launcher/Launcher.hx:29
            return a8_launcher_Launcher.initDirectory(Reflect.field(config,"logsDir"),"logs",_gthis.get_installDir())
        self.lazy_logsDir = tink_core__Lazy_LazyFunc(_hx_local_1)
        # src/a8/launcher/Launcher.hx:28
        def _hx_local_2():
            # src/a8/launcher/Launcher.hx:28
            return a8_launcher_Launcher.initDirectory(Reflect.field(config,"installDir"),None,a8_PathOps.path(python_lib_Os.getcwd()))
        self.lazy_installDir = tink_core__Lazy_LazyFunc(_hx_local_2)
        # src/a8/launcher/Launcher.hx:25
        def _hx_local_3():
            # src/a8/launcher/Launcher.hx:25
            return a8_launcher_Launcher.initDirectory(".a8/versions/cache",None,a8_PathOps.userHome())
        self.lazy_a8VersionsCache = tink_core__Lazy_LazyFunc(_hx_local_3)
        # src/a8/launcher/Launcher.hx:19
        self.config = config
        # src/a8/launcher/Launcher.hx:20
        self.appName = appName
        # src/a8/launcher/Launcher.hx:22
        self.initialArgs = initialArgs

    def logTrace(self,msg,posInfo = None):
        # src/a8/launcher/Launcher.hx:58
        if (not Reflect.field(self.config,"quiet")):
            if (self.pipedStdout is not None):
                self.pipedStdout.log(("TRACE - " + ("null" if msg is None else msg)))
            else:
                a8_Logger.trace(msg,posInfo)

    def logWarn(self,msg,posInfo = None):
        # src/a8/launcher/Launcher.hx:68
        if (self.pipedStderr is not None):
            self.pipedStderr.log(("WARN - " + ("null" if msg is None else msg)))
        else:
            a8_Logger.warn(msg,posInfo)

    def _log(self,msg,pipe):
        pass

    def archiveOldLogs(self):
        # src/a8/launcher/Launcher.hx:80
        prefix = (HxOverrides.stringOrNull(self.appName) + ".")
        # src/a8/launcher/Launcher.hx:81
        suffix1 = ".details"
        # src/a8/launcher/Launcher.hx:82
        suffix2 = ".errors"
        # src/a8/launcher/Launcher.hx:87
        def _hx_local_0(f):
            # src/a8/launcher/Launcher.hx:88
            filename = a8_PathOps.basename(f)
            # src/a8/launcher/Launcher.hx:89
            if StringTools.startsWith(filename,prefix):
                if (not StringTools.endsWith(filename,suffix1)):
                    return StringTools.endsWith(filename,suffix2)
                else:
                    return True
            else:
                return False
        # src/a8/launcher/Launcher.hx:84
        filesToArchive = list(filter(_hx_local_0,a8_PathOps.files(self.get_logsDir())))
        # src/a8/launcher/Launcher.hx:94
        self.archiveLogFiles(filesToArchive)

    def archiveLogFiles(self,files):
        # src/a8/launcher/Launcher.hx:98
        _gthis = self
        # src/a8/launcher/Launcher.hx:102
        def _hx_local_0(f):
            # src/a8/launcher/Launcher.hx:103
            target = a8_PathOps.entry(_gthis.get_logArchivesDir(),a8_PathOps.basename(f))
            # src/a8/launcher/Launcher.hx:104
            a8_PathOps.deleteFile(target)
            # src/a8/launcher/Launcher.hx:105
            a8_PathOps.moveTo(f,target)
            # src/a8/launcher/Launcher.hx:106
            return target
        # src/a8/launcher/Launcher.hx:100
        archivedFiles = list(map(_hx_local_0,files))
        # src/a8/launcher/Launcher.hx:109
        self.logTrace(("archiving log files -- " + Std.string(archivedFiles)),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 109, 'className': "a8.launcher.Launcher", 'methodName': "archiveLogFiles"}))
        # src/a8/launcher/Launcher.hx:112
        def _hx_local_2():
            # src/a8/launcher/Launcher.hx:113
            def _hx_local_1(f1):
                # src/a8/launcher/Launcher.hx:113
                python_lib_Subprocess.call(["gzip", "-f", a8_PathOps.realPathStr(f1)])
            # src/a8/launcher/Launcher.hx:112
            Lambda.iter(archivedFiles,_hx_local_1)
        # src/a8/launcher/Launcher.hx:111
        gzipFiles = _hx_local_2
        # src/a8/launcher/Launcher.hx:117
        a8_PyOps.spawn(gzipFiles)

    def resolveStandardArgs(self,stdlauncher):
        # src/a8/launcher/Launcher.hx:122
        launchConfig = stdlauncher
        # src/a8/launcher/Launcher.hx:123
        return _hx_AnonObject({'kind': "popen", 'args': stdlauncher.args, 'env': None, 'cwd': None, 'executable': None})

    def resolveJvmCliLaunchArgs(self,jvmlauncher):
        # src/a8/launcher/Launcher.hx:133
        versionFile = None
        # src/a8/launcher/Launcher.hx:134
        if a8_OptionOps.nonEmpty(Reflect.field(self.config,"explicitVersion")):
            versionFile = (HxOverrides.stringOrNull(a8_OptionOps.getOrError(Reflect.field(self.config,"explicitVersion"),"")) + ".json")
        elif (Reflect.field(jvmlauncher,"branch") is not None):
            versionFile = (("latest_" + HxOverrides.stringOrNull(Reflect.field(jvmlauncher,"branch"))) + ".json")
        elif (Reflect.field(jvmlauncher,"version") is not None):
            versionFile = (HxOverrides.stringOrNull(Reflect.field(jvmlauncher,"version")) + ".json")
        else:
            raise _HxException(a8_Exception("must provide a config with branch or version",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 141, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmCliLaunchArgs"})))
        # src/a8/launcher/Launcher.hx:143
        inventoryFile = a8_PathOps.entry(self.get_a8VersionsCache(),((((HxOverrides.stringOrNull(jvmlauncher.organization) + "/") + HxOverrides.stringOrNull(jvmlauncher.artifact)) + "/") + ("null" if versionFile is None else versionFile)))
        # src/a8/launcher/Launcher.hx:144
        a8_Logger.trace(("using inventory file - " + HxOverrides.stringOrNull(inventoryFile.toString())),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 144, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmCliLaunchArgs"}))
        # src/a8/launcher/Launcher.hx:145
        if ((not a8_PathOps.exists(inventoryFile)) or Reflect.field(self.config,"resolveOnly")):
            # src/a8/launcher/Launcher.hx:146
            _hx_exec = a8_Exec()
            # src/a8/launcher/Launcher.hx:149
            user = a8_UserConfig.sbtCredentials.h.get("user",None)
            # src/a8/launcher/Launcher.hx:150
            password = a8_UserConfig.sbtCredentials.h.get("password",None)
            # src/a8/launcher/Launcher.hx:152
            version = a8_OptionOps.getOrElse(a8_OptionOps.toOption(a8_UserConfig.versions.h.get("versions_version",None)),"1.0.0-20180425_1229_master")
            # src/a8/launcher/Launcher.hx:154
            repoUrl = a8_OptionOps.getOrElse(a8_OptionOps.toOption(a8_UserConfig.versions.h.get("versions_repo_url",None)),(((("https://" + ("null" if user is None else user)) + ":") + ("null" if password is None else password)) + "@accur8.artifactoryonline.com/accur8/all"))
            # src/a8/launcher/Launcher.hx:156
            def _hx_local_0():
                # src/a8/launcher/Launcher.hx:156
                _hx_exec.args = [(Std.string(a8_PathOps.parent(a8_PathOps.programPath())) + "/coursier"), "launch", "--repository", repoUrl, ("a8:a8-versions_2.12:" + ("null" if version is None else version)), "-M", "a8.versions.apps.Main", "--", "resolve", "--organization", jvmlauncher.organization, "--artifact", jvmlauncher.artifact]
                return _hx_exec.args
            args = _hx_local_0()
            # src/a8/launcher/Launcher.hx:157
            if a8_OptionOps.nonEmpty(Reflect.field(self.config,"explicitVersion")):
                # src/a8/launcher/Launcher.hx:158
                args.append("--version")
                # src/a8/launcher/Launcher.hx:159
                # src/a8/launcher/Launcher.hx:159
                x = a8_OptionOps.get(Reflect.field(self.config,"explicitVersion"))
                args.append(x)
            elif (Reflect.field(jvmlauncher,"branch") is not None):
                # src/a8/launcher/Launcher.hx:161
                args.append("--branch")
                # src/a8/launcher/Launcher.hx:162
                # src/a8/launcher/Launcher.hx:162
                x1 = Reflect.field(jvmlauncher,"branch")
                args.append(x1)
            elif (Reflect.field(jvmlauncher,"version") is not None):
                # src/a8/launcher/Launcher.hx:164
                args.append("--version")
                # src/a8/launcher/Launcher.hx:165
                # src/a8/launcher/Launcher.hx:165
                x2 = Reflect.field(jvmlauncher,"version")
                args.append(x2)
            # src/a8/launcher/Launcher.hx:167
            _hx_exec.execInline()
        # src/a8/launcher/Launcher.hx:169
        la = self.resolveJvmLaunchArgs(jvmlauncher,inventoryFile,False)
        # src/a8/launcher/Launcher.hx:171
        la.kind = "exec"
        # src/a8/launcher/Launcher.hx:172
        la.cwd = None
        # src/a8/launcher/Launcher.hx:174
        return la

    def resolveJvmLaunchArgs(self,jvmlauncher,installInventoryFile,createAppNameSymlink):
        # src/a8/launcher/Launcher.hx:180
        if (not a8_PathOps.exists(installInventoryFile)):
            raise _HxException(a8_Exception(("inventory file does not exist " + HxOverrides.stringOrNull(installInventoryFile.toString())),None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 181, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmLaunchArgs"})))
        # src/a8/launcher/Launcher.hx:184
        launchConfig = jvmlauncher
        # src/a8/launcher/Launcher.hx:186
        config = python_lib_Json.loads(a8_PathOps.readText(installInventoryFile),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        # src/a8/launcher/Launcher.hx:188
        launcherD = jvmlauncher
        # src/a8/launcher/Launcher.hx:190
        def _hx_local_0(e):
            # src/a8/launcher/Launcher.hx:191
            p = a8_PathOps.realPathStr(e)
            # src/a8/launcher/Launcher.hx:192
            if (StringTools.endsWith(p,".jar") or a8_PathOps.isDir(e)):
                # src/a8/launcher/Launcher.hx:193
                _this = config.classpath
                _this.append(p)
        Lambda.iter(a8_PathOps.entries(a8_PathOps.entry(self.get_installDir(),"lib")),_hx_local_0)
        # src/a8/launcher/Launcher.hx:196
        _this1 = config.classpath
        classpath = ":".join([python_Boot.toString1(x1,'') for x1 in _this1])
        # src/a8/launcher/Launcher.hx:198
        args = list()
        # src/a8/launcher/Launcher.hx:200
        if createAppNameSymlink:
            # src/a8/launcher/Launcher.hx:201
            symlinkName = ("j_" + HxOverrides.stringOrNull(self.appName))
            # src/a8/launcher/Launcher.hx:202
            symlinkParent = self.get_installDir()
            # src/a8/launcher/Launcher.hx:203
            javaAppNameSymLink = ((HxOverrides.stringOrNull(a8_PathOps.realPathStr(symlinkParent)) + "/") + ("null" if symlinkName is None else symlinkName))
            # src/a8/launcher/Launcher.hx:204
            javaAppNameSymLinkPath = a8_PathOps.path(javaAppNameSymLink)
            # src/a8/launcher/Launcher.hx:205
            cmd = None
            # src/a8/launcher/Launcher.hx:206
            if (not a8_PathOps.isFile(javaAppNameSymLinkPath)):
                # src/a8/launcher/Launcher.hx:207
                javaExec = a8_PyShutil2.which("java")
                # src/a8/launcher/Launcher.hx:208
                a8_Logger.trace(((("creating symlink " + ("null" if javaExec is None else javaExec)) + " --> ") + ("null" if javaAppNameSymLink is None else javaAppNameSymLink)),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 208, 'className': "a8.launcher.Launcher", 'methodName': "resolveJvmLaunchArgs"}))
                # src/a8/launcher/Launcher.hx:209
                a8_PyOs2.symlink(javaExec,javaAppNameSymLink)
                # src/a8/launcher/Launcher.hx:210
                if a8_PathOps.isFile(javaAppNameSymLinkPath):
                    cmd = ("./" + ("null" if symlinkName is None else symlinkName))
                else:
                    cmd = "java"
            else:
                cmd = ("./" + ("null" if symlinkName is None else symlinkName))
            # src/a8/launcher/Launcher.hx:218
            args.append(cmd)
        else:
            args.append("java")
        # src/a8/launcher/Launcher.hx:223
        # src/a8/launcher/Launcher.hx:223
        x = ("-DappName=" + HxOverrides.stringOrNull(self.appName))
        args.append(x)
        # src/a8/launcher/Launcher.hx:225
        if (Reflect.field(launcherD,"jvmArgs") is not None):
            # src/a8/launcher/Launcher.hx:227
            def _hx_local_1(jvmArg):
                # src/a8/launcher/Launcher.hx:227
                args.append(jvmArg)
            # src/a8/launcher/Launcher.hx:226
            Lambda.iter(Reflect.field(jvmlauncher,"jvmArgs"),_hx_local_1)
        # src/a8/launcher/Launcher.hx:232
        # src/a8/launcher/Launcher.hx:232
        x1 = jvmlauncher.mainClass
        args.append(x1)
        # src/a8/launcher/Launcher.hx:234
        if (Reflect.field(launcherD,"args") is not None):
            # src/a8/launcher/Launcher.hx:236
            def _hx_local_2(arg):
                # src/a8/launcher/Launcher.hx:236
                args.append(arg)
            # src/a8/launcher/Launcher.hx:235
            Lambda.iter(Reflect.field(jvmlauncher,"args"),_hx_local_2)
        # src/a8/launcher/Launcher.hx:240
        def _hx_local_3(arg1):
            # src/a8/launcher/Launcher.hx:240
            args.append(arg1)
        # src/a8/launcher/Launcher.hx:239
        Lambda.iter(Reflect.field(self.config,"resolvedCommandLineArgs"),_hx_local_3)
        # src/a8/launcher/Launcher.hx:243
        env = python_lib_Os.environ
        # src/a8/launcher/Launcher.hx:245
        newEnv = env.copy()
        # src/a8/launcher/Launcher.hx:249
        newEnv["CLASSPATH"] = classpath
        # src/a8/launcher/Launcher.hx:250
        newEnv["LAUNCHER_INSTALL_DIR"] = a8_PathOps.realPathStr(self.get_installDir())
        # src/a8/launcher/Launcher.hx:251
        newEnv["LAUNCHER_WORKING_DIR"] = python_lib_Os.getcwd()
        # src/a8/launcher/Launcher.hx:252
        newEnv["LAUNCHER_EXEC_PATH"] = a8_PathOps.realPathStr(a8_PathOps.executablePath())
        # src/a8/launcher/Launcher.hx:258
        tmp = a8_PathOps.realPathStr(self.get_installDir())
        # src/a8/launcher/Launcher.hx:254
        return _hx_AnonObject({'kind': "popen", 'args': args, 'env': newEnv, 'cwd': tmp, 'executable': (args[0] if 0 < len(args) else None)})

    def runAndWait(self):
        # src/a8/launcher/Launcher.hx:267
        self.logTrace(("installDir = " + Std.string(self.get_installDir())),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 267, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:268
        self.logTrace(("logsDir = " + Std.string(self.get_logsDir())),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 268, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:269
        self.logTrace(("logArchivesDir = " + Std.string(self.get_logArchivesDir())),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 269, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
        # src/a8/launcher/Launcher.hx:271
        resolvedLaunch = None
        # src/a8/launcher/Launcher.hx:272
        if (self.config.kind == "jvm"):
            # src/a8/launcher/Launcher.hx:273
            installInventoryFile = a8_PathOps.entry(self.get_installDir(),"install-inventory.json")
            # src/a8/launcher/Launcher.hx:271
            resolvedLaunch = self.resolveJvmLaunchArgs(self.config,installInventoryFile,True)
        elif (self.config.kind == "jvm_cli"):
            resolvedLaunch = self.resolveJvmCliLaunchArgs(self.config)
        elif (self.config.kind == "args"):
            resolvedLaunch = self.resolveStandardArgs(self.config)
        else:
            raise _HxException(a8_Exception(("unable to resolve config kind " + HxOverrides.stringOrNull(self.config.kind)),None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 280, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
        # src/a8/launcher/Launcher.hx:282
        if (not Reflect.field(self.config,"resolveOnly")):
            # src/a8/launcher/Launcher.hx:284
            if Reflect.field(self.config,"logFiles"):
                self.archiveOldLogs()
            # src/a8/launcher/Launcher.hx:288
            # src/a8/launcher/Launcher.hx:288
            _g = resolvedLaunch.kind
            _g1 = _g
            _hx_local_0 = len(_g1)
            # src/a8/launcher/Launcher.hx:289
            if (_hx_local_0 == 4):
                if (_g1 == "exec"):
                    # src/a8/launcher/Launcher.hx:292
                    if (resolvedLaunch.cwd is not None):
                        python_lib_Os.chdir(resolvedLaunch.cwd)
                    # src/a8/launcher/Launcher.hx:294
                    a8_PyOs2.execvpe(resolvedLaunch.executable,resolvedLaunch.args,resolvedLaunch.env)
                else:
                    raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 327, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
            elif (_hx_local_0 == 5):
                if (_g1 == "popen"):
                    # src/a8/launcher/Launcher.hx:297
                    self.logTrace(("running -- " + Std.string(resolvedLaunch.args)),_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 297, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:299
                    popen = python_lib_subprocess_Popen(resolvedLaunch.args,None,resolvedLaunch.executable,None,python_lib_Subprocess.PIPE,python_lib_Subprocess.PIPE,None,False,False,resolvedLaunch.cwd,resolvedLaunch.env)
                    # src/a8/launcher/Launcher.hx:302
                    def _hx_local_1(out):
                        # src/a8/launcher/Launcher.hx:302
                        out.write((("first output at " + HxOverrides.stringOrNull(a8_PathOps.timestampStr())) + "\n"))
                    # src/a8/launcher/Launcher.hx:301
                    firstIO = _hx_local_1
                    # src/a8/launcher/Launcher.hx:305
                    timestampStr = a8_PathOps.timestampStr()
                    # src/a8/launcher/Launcher.hx:307
                    self.logTrace("setting up pipes",_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 307, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:308
                    self.pipedStdout = a8_launcher_PipedStream(self,a8_StreamOps.asInputStream(popen.stdout),python_lib_Sys.stdout,"details",firstIO,Reflect.field(self.config,"logFiles"),timestampStr)
                    # src/a8/launcher/Launcher.hx:309
                    self.pipedStderr = a8_launcher_PipedStream(self,a8_StreamOps.asInputStream(popen.stderr),python_lib_Sys.stderr,"errors",firstIO,Reflect.field(self.config,"logFiles"),timestampStr)
                    # src/a8/launcher/Launcher.hx:311
                    self.pipedStdout.start()
                    # src/a8/launcher/Launcher.hx:312
                    self.pipedStderr.start()
                    # src/a8/launcher/Launcher.hx:316
                    self.logTrace("initializeLogRollers",_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 316, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:317
                    self.initializeLogRollers()
                    # src/a8/launcher/Launcher.hx:318
                    self.logTrace("initializeLogRollers complete",_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 318, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"}))
                    # src/a8/launcher/Launcher.hx:321
                    popen.wait()
                    # src/a8/launcher/Launcher.hx:324
                    self.pipedStdout.close()
                    # src/a8/launcher/Launcher.hx:325
                    self.pipedStdout.close()
                else:
                    raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 327, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))
            else:
                raise _HxException(a8_Exception("don't know how to handle ResolvedLaunch.kind = ${resolvedLaunch.kind}",None,_hx_AnonObject({'fileName': "Launcher.hx", 'lineNumber': 327, 'className': "a8.launcher.Launcher", 'methodName': "runAndWait"})))

    def initializeLogRollers(self):
        # src/a8/launcher/Launcher.hx:333
        _gthis = self
        # src/a8/launcher/Launcher.hx:337
        def _hx_local_0(lr):
            # src/a8/launcher/Launcher.hx:337
            return a8_launcher_LogRollerOps.fromConfig(lr,_gthis)
        # src/a8/launcher/Launcher.hx:334
        self.logRollers = list(map(_hx_local_0,Reflect.field(self.config,"logRollers")))
        # src/a8/launcher/Launcher.hx:338
        def _hx_local_1(i):
            # src/a8/launcher/Launcher.hx:338
            i.init()
            return
        Lambda.iter(self.logRollers,_hx_local_1)

    def get_a8VersionsCache(self):
        # src/a8/launcher/Launcher.hx:25
        return self.lazy_a8VersionsCache.get()

    def get_installDir(self):
        # src/a8/launcher/Launcher.hx:28
        return self.lazy_installDir.get()

    def get_logsDir(self):
        # src/a8/launcher/Launcher.hx:29
        return self.lazy_logsDir.get()

    def get_logArchivesDir(self):
        # src/a8/launcher/Launcher.hx:30
        return self.lazy_logArchivesDir.get()

    @staticmethod
    def initDirectory(configEntry,secondEntry,basePath,makeDirectory = None):
        # src/a8/launcher/Launcher.hx:39
        entry = (configEntry if ((configEntry is not None)) else secondEntry)
        # src/a8/launcher/Launcher.hx:40
        d = None
        # src/a8/launcher/Launcher.hx:41
        if (entry is None):
            d = basePath
        else:
            # src/a8/launcher/Launcher.hx:44
            asPath = a8_PathOps.path(entry)
            # src/a8/launcher/Launcher.hx:45
            if a8_PathOps.isAbsolute(asPath):
                d = asPath
            else:
                d = a8_PathOps.entry(basePath,entry)
        # src/a8/launcher/Launcher.hx:51
        if (makeDirectory and (not a8_PathOps.exists(d))):
            a8_PathOps.makeDirectories(d)
        # src/a8/launcher/Launcher.hx:54
        return d

a8_launcher_Launcher._hx_class = a8_launcher_Launcher


class a8_launcher_LogRollerOps:
    _hx_class_name = "a8.launcher.LogRollerOps"
    __slots__ = ()
    _hx_statics = ["fromConfig", "scheduleAtMidnight"]

    @staticmethod
    def fromConfig(c,launcher):
        # src/a8/launcher/LogRoller.hx:11
        if (c == "midnight"):
            return a8_launcher_MidnightLogRoller(launcher)
        else:
            return a8_launcher_UnknownLogRoller(c)

    @staticmethod
    def scheduleAtMidnight(fn):
        # src/a8/launcher/LogRoller.hx:18
        now = Date.now()
        # src/a8/launcher/LogRoller.hx:19
        midnight = a8_DateOps.midnight()
        # src/a8/launcher/LogRoller.hx:20
        millisToMidnight = ((python_lib_Time.mktime(midnight.date.timetuple()) * 1000) - ((python_lib_Time.mktime(now.date.timetuple()) * 1000)))
        # src/a8/launcher/LogRoller.hx:21
        secondsToMidnight = (millisToMidnight / 1000)
        # src/a8/launcher/LogRoller.hx:22
        a8_GlobalScheduler.schedule(secondsToMidnight,fn)
a8_launcher_LogRollerOps._hx_class = a8_launcher_LogRollerOps


class a8_launcher_LogRoller:
    _hx_class_name = "a8.launcher.LogRoller"
    __slots__ = ()
    _hx_methods = ["init", "onArchiveLogChanges"]
a8_launcher_LogRoller._hx_class = a8_launcher_LogRoller


class a8_launcher_AbstractLogRoller:
    _hx_class_name = "a8.launcher.AbstractLogRoller"
    __slots__ = ()
    _hx_methods = ["init", "onArchiveLogChanges"]

    def init(self):
        pass

    def onArchiveLogChanges(self):
        pass

a8_launcher_AbstractLogRoller._hx_class = a8_launcher_AbstractLogRoller


class a8_launcher_MidnightLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.MidnightLogRoller"
    __slots__ = ("launcher",)
    _hx_fields = ["launcher"]
    _hx_methods = ["init", "schedule", "doMidnightRollover"]
    _hx_statics = []
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,launcher):
        # src/a8/launcher/LogRoller.hx:42
        self.launcher = None
        self.launcher = launcher

    def init(self):
        # src/a8/launcher/LogRoller.hx:45
        self.schedule()

    def schedule(self):
        # src/a8/launcher/LogRoller.hx:49
        a8_launcher_LogRollerOps.scheduleAtMidnight(self.doMidnightRollover)

    def doMidnightRollover(self):
        # src/a8/launcher/LogRoller.hx:53
        self.launcher.logTrace("running doMidnightRollover",_hx_AnonObject({'fileName': "LogRoller.hx", 'lineNumber': 53, 'className': "a8.launcher.MidnightLogRoller", 'methodName': "doMidnightRollover"}))
        # src/a8/launcher/LogRoller.hx:54
        timestampStr = a8_PathOps.timestampStr()
        # src/a8/launcher/LogRoller.hx:56
        self.launcher.pipedStderr.rollover(timestampStr)
        # src/a8/launcher/LogRoller.hx:57
        self.launcher.pipedStdout.rollover(timestampStr)
        # src/a8/launcher/LogRoller.hx:58
        self.schedule()
        # src/a8/launcher/LogRoller.hx:59
        self.launcher.logTrace("doMidnightRollover complete",_hx_AnonObject({'fileName': "LogRoller.hx", 'lineNumber': 59, 'className': "a8.launcher.MidnightLogRoller", 'methodName': "doMidnightRollover"}))

a8_launcher_MidnightLogRoller._hx_class = a8_launcher_MidnightLogRoller


class a8_launcher_UnknownLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.UnknownLogRoller"
    __slots__ = ("config",)
    _hx_fields = ["config"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,config):
        # src/a8/launcher/LogRoller.hx:67
        self.config = None
        self.config = config

a8_launcher_UnknownLogRoller._hx_class = a8_launcher_UnknownLogRoller


class a8_launcher_CullOldArchivesLogRoller(a8_launcher_AbstractLogRoller):
    _hx_class_name = "a8.launcher.CullOldArchivesLogRoller"
    __slots__ = ("config", "launcher")
    _hx_fields = ["config", "launcher"]
    _hx_methods = ["init", "cullOldLogs"]
    _hx_statics = []
    _hx_super = a8_launcher_AbstractLogRoller


    def __init__(self,config,launcher):
        # src/a8/launcher/LogRoller.hx:78
        self.launcher = None
        # src/a8/launcher/LogRoller.hx:77
        self.config = None
        self.config = config
        # src/a8/launcher/LogRoller.hx:78
        self.launcher = launcher

    def init(self):
        # src/a8/launcher/LogRoller.hx:84
        a8_GlobalScheduler.submit(self.cullOldLogs)

    def cullOldLogs(self):
        # src/a8/launcher/LogRoller.hx:89
        fiveMinutes = 300
        # src/a8/launcher/LogRoller.hx:90
        a8_GlobalScheduler.schedule(fiveMinutes,self.cullOldLogs)

a8_launcher_CullOldArchivesLogRoller._hx_class = a8_launcher_CullOldArchivesLogRoller


class a8_launcher_Main:
    _hx_class_name = "a8.launcher.Main"
    __slots__ = ()
    _hx_statics = ["loadConfig", "main"]

    @staticmethod
    def loadConfig():
        # src/a8/launcher/Main.hx:17
        execPath = a8_PathOps.executablePath()
        # src/a8/launcher/Main.hx:18
        appName = execPath.file
        # src/a8/launcher/Main.hx:20
        configExtensions = [".json", ".launcher.json"]
        # src/a8/launcher/Main.hx:25
        def _hx_local_2(l):
            # src/a8/launcher/Main.hx:25
            def _hx_local_1():
                # src/a8/launcher/Main.hx:25
                def _hx_local_0(e):
                    # src/a8/launcher/Main.hx:25
                    return a8_PathOps.entry(a8_PathOps.parent(l),(HxOverrides.stringOrNull(a8_PathOps.name(l)) + ("null" if e is None else e)))
                return list(map(_hx_local_0,configExtensions))
            return _hx_local_1()
        # src/a8/launcher/Main.hx:22
        possibleConfigFiles = Lambda.array(Lambda.flatMap(a8_PathOps.symlinkChain(execPath),_hx_local_2))
        # src/a8/launcher/Main.hx:33
        def _hx_local_3(f):
            # src/a8/launcher/Main.hx:33
            return a8_PathOps.exists(f)
        # src/a8/launcher/Main.hx:31
        configFile = Lambda.find(possibleConfigFiles,_hx_local_3)
        # src/a8/launcher/Main.hx:36
        config = python_lib_Json.loads(a8_PathOps.readText(configFile),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        # src/a8/launcher/Main.hx:38
        if (Reflect.field(config,"quiet") is None):
            Reflect.setField(config,"quiet",False)
        # src/a8/launcher/Main.hx:41
        if (Reflect.field(config,"logRollers") is None):
            Reflect.setField(config,"logRollers",[])
        # src/a8/launcher/Main.hx:44
        if (Reflect.field(config,"logFiles") is None):
            Reflect.setField(config,"logFiles",True)
        # src/a8/launcher/Main.hx:47
        if (config.kind == "jvm_cli"):
            # src/a8/launcher/Main.hx:48
            jvmLaunchConfig = config
            # src/a8/launcher/Main.hx:49
            Reflect.setField(config,"installDir",None)
            # src/a8/launcher/Main.hx:50
            Reflect.setField(config,"logFiles",False)
            # src/a8/launcher/Main.hx:51
            Reflect.setField(config,"logRollers",[])
        # src/a8/launcher/Main.hx:53
        if ((config.kind == "jvm") or ((config.kind == "jvm_cli"))):
            # src/a8/launcher/Main.hx:54
            jvmLaunchConfig1 = config
            # src/a8/launcher/Main.hx:55
            if (Reflect.field(jvmLaunchConfig1,"jvmArgs") is None):
                Reflect.setField(jvmLaunchConfig1,"jvmArgs",[])
            # src/a8/launcher/Main.hx:57
            if (Reflect.field(jvmLaunchConfig1,"args") is None):
                Reflect.setField(jvmLaunchConfig1,"args",[])
        # src/a8/launcher/Main.hx:62
        return config

    @staticmethod
    def main():
        # src/a8/launcher/Main.hx:68
        try:
            # src/a8/launcher/Main.hx:70
            execPath = a8_PathOps.executablePath()
            # src/a8/launcher/Main.hx:72
            appName = execPath.file
            # src/a8/launcher/Main.hx:74
            initialConfig = a8_launcher_Main.loadConfig()
            # src/a8/launcher/Main.hx:76
            args = list(python_lib_Sys.argv)
            # src/a8/launcher/Main.hx:77
            Reflect.setField(initialConfig,"rawCommandLineArgs",args)
            # src/a8/launcher/Main.hx:79
            clp = a8_launcher_CommandLineProcessor()
            # src/a8/launcher/Main.hx:80
            config = clp.apply(initialConfig)
            # src/a8/launcher/Main.hx:82
            a8_Logger.traceEnabled = (not Reflect.field(config,"quiet"))
            # src/a8/launcher/Main.hx:84
            launcher = a8_launcher_Launcher(config,appName,args)
            # src/a8/launcher/Main.hx:91
            launcher.runAndWait()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # src/a8/launcher/Main.hx:93
            stack = haxe_CallStack.exceptionStack()
            # src/a8/launcher/Main.hx:94
            a8_Logger.warn(((("" + Std.string(e)) + "\n") + HxOverrides.stringOrNull(a8_HaxeOps2.asString(stack,"    "))),_hx_AnonObject({'fileName': "Main.hx", 'lineNumber': 94, 'className': "a8.launcher.Main", 'methodName': "main"}))
            # src/a8/launcher/Main.hx:95
            Sys.exit(1)
        # src/a8/launcher/Main.hx:98
        Sys.exit(0)
a8_launcher_Main._hx_class = a8_launcher_Main


class a8_launcher_PipedStream:
    _hx_class_name = "a8.launcher.PipedStream"
    __slots__ = ("launcher", "processInput", "stdxxx", "fileExtension", "firstIO", "pipeToLogFiles", "initialTimestampStr", "pipe", "outputFile", "started")
    _hx_fields = ["launcher", "processInput", "stdxxx", "fileExtension", "firstIO", "pipeToLogFiles", "initialTimestampStr", "pipe", "outputFile", "started"]
    _hx_methods = ["start", "newOutputFile", "timestampedOutputFile", "log", "rollover", "close"]

    def __init__(self,launcher,processInput,stdxxx,fileExtension,firstIO,pipeToLogFiles,initialTimestampStr):
        # src/a8/launcher/PipedStream.hx:24
        self.outputFile = None
        # src/a8/launcher/PipedStream.hx:22
        self.pipe = None
        # src/a8/launcher/PipedStream.hx:20
        self.initialTimestampStr = None
        # src/a8/launcher/PipedStream.hx:19
        self.pipeToLogFiles = None
        # src/a8/launcher/PipedStream.hx:18
        self.firstIO = None
        # src/a8/launcher/PipedStream.hx:17
        self.fileExtension = None
        # src/a8/launcher/PipedStream.hx:16
        self.stdxxx = None
        # src/a8/launcher/PipedStream.hx:15
        self.processInput = None
        # src/a8/launcher/PipedStream.hx:14
        self.launcher = None
        # src/a8/launcher/PipedStream.hx:26
        self.started = False
        # src/a8/launcher/PipedStream.hx:14
        self.launcher = launcher
        # src/a8/launcher/PipedStream.hx:15
        self.processInput = processInput
        # src/a8/launcher/PipedStream.hx:16
        self.stdxxx = stdxxx
        # src/a8/launcher/PipedStream.hx:17
        self.fileExtension = fileExtension
        # src/a8/launcher/PipedStream.hx:18
        self.firstIO = firstIO
        # src/a8/launcher/PipedStream.hx:19
        self.pipeToLogFiles = pipeToLogFiles
        # src/a8/launcher/PipedStream.hx:20
        self.initialTimestampStr = initialTimestampStr
        # src/a8/launcher/PipedStream.hx:24
        self.outputFile = haxe_ds_Option._hx_None

    def start(self):
        # src/a8/launcher/PipedStream.hx:29
        if (not self.started):
            # src/a8/launcher/PipedStream.hx:30
            self.started = True
            # src/a8/launcher/PipedStream.hx:31
            if self.pipeToLogFiles:
                # src/a8/launcher/PipedStream.hx:32
                of = self.newOutputFile(self.initialTimestampStr)
                # src/a8/launcher/PipedStream.hx:33
                self.outputFile = haxe_ds_Option.Some(of)
                # src/a8/launcher/PipedStream.hx:34
                self.pipe = a8_Pipe(self.processInput,of.teedOut,self.firstIO)
                # src/a8/launcher/PipedStream.hx:35
                self.pipe.run()
            else:
                # src/a8/launcher/PipedStream.hx:37
                self.outputFile = haxe_ds_Option._hx_None
                # src/a8/launcher/PipedStream.hx:38
                self.pipe = a8_Pipe(self.processInput,a8_StreamOps.asOutputStream(self.stdxxx),self.firstIO)
                # src/a8/launcher/PipedStream.hx:39
                self.pipe.run()

    def newOutputFile(self,timesatmpStr):
        # src/a8/launcher/PipedStream.hx:45
        fileOutputPath = self.timestampedOutputFile(timesatmpStr)
        # src/a8/launcher/PipedStream.hx:46
        fileOut = a8_StreamOps.fileOutputStream(a8_PathOps.realPathStr(fileOutputPath))
        # src/a8/launcher/PipedStream.hx:47
        teeOut = a8_TeeOutputStream([fileOut, a8_StreamOps.asOutputStream(self.stdxxx)])
        # src/a8/launcher/PipedStream.hx:48
        return _hx_AnonObject({'path': fileOutputPath, 'outputStream': fileOut, 'teedOut': teeOut})

    def timestampedOutputFile(self,timestampStr):
        # src/a8/launcher/PipedStream.hx:56
        return a8_PathOps.entry(self.launcher.get_logsDir(),((((HxOverrides.stringOrNull(self.launcher.appName) + ".") + ("null" if timestampStr is None else timestampStr)) + ".") + HxOverrides.stringOrNull(self.fileExtension)))

    def log(self,msg):
        # src/a8/launcher/PipedStream.hx:60
        _g = self.outputFile
        if (_g.index == 0):
            # src/a8/launcher/PipedStream.hx:61
            of = _g.params[0]
            # src/a8/launcher/PipedStream.hx:62
            try:
                # src/a8/launcher/PipedStream.hx:63
                of.teedOut.write(msg)
                # src/a8/launcher/PipedStream.hx:64
                of.teedOut.write("\n")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                a8_Logger.warn(("error logging - " + Std.string(e)),_hx_AnonObject({'fileName': "PipedStream.hx", 'lineNumber': 66, 'className': "a8.launcher.PipedStream", 'methodName': "log"}))

    def rollover(self,timestampStr):
        # src/a8/launcher/PipedStream.hx:73
        _g = self.outputFile
        _g1 = _g.index
        # ?:1
        if (_g1 == 0):
            # src/a8/launcher/PipedStream.hx:74
            existingOutputFile = _g.params[0]
            # src/a8/launcher/PipedStream.hx:77
            newFileOutputPath = self.timestampedOutputFile(timestampStr)
            # src/a8/launcher/PipedStream.hx:78
            newfileOut = a8_PathOps.outputStream(newFileOutputPath)
            # src/a8/launcher/PipedStream.hx:79
            def _hx_local_0(oldOut):
                # src/a8/launcher/PipedStream.hx:80
                oldOut.close()
                # src/a8/launcher/PipedStream.hx:81
                return newfileOut
            self.pipe.replaceOutput = _hx_local_0
            # src/a8/launcher/PipedStream.hx:85
            oldFileoutputPath = existingOutputFile.path
            # src/a8/launcher/PipedStream.hx:86
            existingOutputFile.path = newFileOutputPath
            # src/a8/launcher/PipedStream.hx:87
            existingOutputFile.outputStream = newfileOut
            # src/a8/launcher/PipedStream.hx:88
            self.launcher.archiveLogFiles([oldFileoutputPath])
        elif (_g1 == 1):
            raise _HxException(a8_Exception("this should not happen since rollover should never get called when we don't have a Some for outputFile: Option<PipedStreamOutputFile>",None,_hx_AnonObject({'fileName': "PipedStream.hx", 'lineNumber': 92, 'className': "a8.launcher.PipedStream", 'methodName': "rollover"})))
        else:
            pass

    def close(self):
        # src/a8/launcher/PipedStream.hx:98
        def _hx_local_0(f):
            # src/a8/launcher/PipedStream.hx:98
            f.teedOut.close()
            return
        a8_OptionOps.iter(self.outputFile,_hx_local_0)

a8_launcher_PipedStream._hx_class = a8_launcher_PipedStream

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, [m])

    @staticmethod
    def FilePos(s,file,line):
        return haxe_StackItem("FilePos", 2, [s,file,line])

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, [classname,method])

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, [v])
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, list())
haxe_StackItem._hx_class = haxe_StackItem


class haxe_CallStack:
    _hx_class_name = "haxe.CallStack"
    __slots__ = ()
    _hx_statics = ["callStack", "exceptionStack"]

    @staticmethod
    def callStack():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:122
        stack = []
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:123
        infos = python_lib_Traceback.extract_stack()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:124
        if (len(infos) != 0):
            infos.pop()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:125
        infos.reverse()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:126
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:126
        _g = 0
        while (_g < len(infos)):
            elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
            _g = (_g + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:127
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:127
            x = haxe_StackItem.FilePos(None,elem[0],elem[1])
            stack.append(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:128
        return stack

    @staticmethod
    def exceptionStack():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:211
        stack = []
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:212
        exc = python_lib_Sys.exc_info()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:213
        if (exc[2] is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:215
            infos = python_lib_Traceback.extract_tb(exc[2])
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:216
            infos.reverse()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:217
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:217
            _g = 0
            while (_g < len(infos)):
                elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:218
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:218
                x = haxe_StackItem.FilePos(None,elem[0],elem[1])
                stack.append(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/CallStack.hx:220
        return stack
haxe_CallStack._hx_class = haxe_CallStack


class haxe__EntryPoint_Lock:
    _hx_class_name = "haxe._EntryPoint.Lock"
    __slots__ = ()

    def __init__(self):
        pass
haxe__EntryPoint_Lock._hx_class = haxe__EntryPoint_Lock


class haxe__EntryPoint_Mutex:
    _hx_class_name = "haxe._EntryPoint.Mutex"
    __slots__ = ()

    def __init__(self):
        pass
haxe__EntryPoint_Mutex._hx_class = haxe__EntryPoint_Mutex


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    __slots__ = ()
    _hx_statics = ["sleepLock", "mutex", "pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:93
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:95
            _this = haxe_EntryPoint.mutex
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:96
            _this1 = haxe_EntryPoint.pending
            f = (None if ((len(_this1) == 0)) else _this1.pop(0))
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:97
            _this2 = haxe_EntryPoint.mutex
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:101
            if (f is None):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:102
            f()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:104
        if ((haxe_MainLoop.pending is None) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:106
        return haxe_MainLoop.tick()

    @staticmethod
    def run():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:134
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:135
            nextTick = haxe_EntryPoint.processEvents()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:136
            if (nextTick < 0):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/EntryPoint.hx:138
            if (nextTick > 0):
                _this = haxe_EntryPoint.sleepLock
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["trace"]

    @staticmethod
    def trace(v,infos = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:105
        _hx_str = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:106
        if (infos is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:107
            _hx_str = ((((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber)) + ": ") + Std.string(v))
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:108
            if (Reflect.field(infos,"customParams") is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:109
                _this = Reflect.field(infos,"customParams")
                _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull((("," + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))))))
        else:
            _hx_str = v
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Log.hx:114
        python_Lib.println(_hx_str)
haxe_Log._hx_class = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    __slots__ = ("f", "prev", "next", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "nextRun", "priority"]
    _hx_methods = ["delay", "stop"]

    def __init__(self,f,p):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:8
        self.next = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:7
        self.prev = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:13
        self.f = f
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:14
        self.priority = p
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:15
        self.nextRun = -1

    def delay(self,t):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:23
        self.nextRun = (-1 if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def stop(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:37
        if (self.f is None):
            return
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:38
        self.f = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:39
        self.nextRun = -1
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:40
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:44
        if (self.next is not None):
            self.next.prev = self.prev

haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    __slots__ = ()
    _hx_statics = ["pending", "add", "sortEvents", "tick"]
    threadCount = None

    @staticmethod
    def add(f,priority = 0):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:74
        if (priority is None):
            priority = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:75
        if (f is None):
            raise _HxException("Event function is null")
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:77
        e = haxe_MainEvent(f,priority)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:78
        head = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:79
        if (head is not None):
            head.prev = e
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:80
        e.next = head
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:81
        haxe_MainLoop.pending = e
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:82
        return e

    @staticmethod
    def sortEvents():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:89
        _hx_list = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:91
        if (_hx_list is None):
            return
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:93
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:94
        p = None
        q = None
        e = None
        tail = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:96
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:97
            p = _hx_list
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:98
            _hx_list = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:99
            tail = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:100
            nmerges = 0
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:101
            while (p is not None):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:102
                nmerges = (nmerges + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:103
                q = p
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:104
                psize = 0
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:105
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:105
                _g1 = 0
                _g = insize
                while (_g1 < _g):
                    i = _g1
                    _g1 = (_g1 + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:106
                    psize = (psize + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:107
                    q = q.next
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:108
                    if (q is None):
                        break
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:110
                qsize = insize
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:111
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:112
                    if (psize == 0):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:113
                        e = q
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:114
                        q = q.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:115
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:117
                        e = p
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:118
                        p = p.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:119
                        psize = (psize - 1)
                    else:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:121
                        e = q
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:122
                        q = q.next
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:123
                        qsize = (qsize - 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:125
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:129
                    e.prev = tail
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:130
                    tail = e
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:132
                p = q
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:134
            tail.next = None
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:135
            if (nmerges <= 1):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:137
            insize = (insize * 2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:139
        _hx_list.prev = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:140
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:147
        haxe_MainLoop.sortEvents()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:148
        e = haxe_MainLoop.pending
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:149
        now = python_lib_Timeit.default_timer()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:150
        wait = 1e9
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:151
        while (e is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:152
            next = e.next
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:153
            wt = (e.nextRun - now)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:154
            if ((e.nextRun < 0) or ((wt <= 0))):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:155
                wait = 0
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:156
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:159
            e = next
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/MainLoop.hx:161
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:46
        self.event = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:60
        _gthis = self
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:71
        dt = (time_ms / 1000)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:72
        def _hx_local_2():
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:73
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:73
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:74
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:76
        self.event.delay(dt)

    def stop(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:105
        if (self.event is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:106
            self.event.stop()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:107
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:137
        t = haxe_Timer(time_ms)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:138
        def _hx_local_0():
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:139
            t.stop()
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:140
            f()
        t.run = _hx_local_0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/Timer.hx:142
        return t

haxe_Timer._hx_class = haxe_Timer

class haxe_ds_Either(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Either"

    @staticmethod
    def Left(v):
        return haxe_ds_Either("Left", 0, [v])

    @staticmethod
    def Right(v):
        return haxe_ds_Either("Right", 1, [v])
haxe_ds_Either._hx_class = haxe_ds_Either


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["get", "keys"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:32
        self.h = dict()

    def get(self,key):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:40
        return self.h.get(key,None)

    def keys(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/haxe/ds/ObjectMap.hx:55
        return python_HaxeIterator(iter(self.h.keys()))

haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:57
        self.replacer = replacer
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:58
        self.indent = space
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:59
        self.pretty = (space is not None)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:60
        self.nind = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:67
        self.buf = StringBuf()

    def write(self,k,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:80
        if (self.replacer is not None):
            v = self.replacer(k,v)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:81
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:81
        _g = Type.typeof(v)
        _g1 = _g.index
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:136
        if (_g1 == 0):
            self.buf.b.write("null")
        elif (_g1 == 1):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:87
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (_g1 == 2):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:89
            v1 = None
            f = v
            if (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f))):
                v1 = v
            else:
                v1 = "null"
            _this1 = self.buf
            s1 = Std.string(v1)
            _this1.b.write(s1)
        elif (_g1 == 3):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:134
            _this2 = self.buf
            s2 = Std.string(v)
            _this2.b.write(s2)
        elif (_g1 == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (_g1 == 5):
            self.buf.b.write("\"<fun>\"")
        elif (_g1 == 6):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:92
            c = _g.params[0]
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:93
            if (c == str):
                self.quote(v)
            elif (c == list):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:96
                v2 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:97
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:97
                _this3 = self.buf
                s3 = "".join(map(chr,[91]))
                _this3.b.write(s3)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:99
                _hx_len = len(v2)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:100
                last = (_hx_len - 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:101
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:101
                _g11 = 0
                _g2 = _hx_len
                while (_g11 < _g2):
                    i = _g11
                    _g11 = (_g11 + 1)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:103
                    if (i > 0):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:103
                        _this4 = self.buf
                        s4 = "".join(map(chr,[44]))
                        _this4.b.write(s4)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:104
                    if self.pretty:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:104
                        _this5 = self.buf
                        s5 = "".join(map(chr,[10]))
                        _this5.b.write(s5)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:105
                    if self.pretty:
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:105
                        v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this6 = self.buf
                        s6 = Std.string(v3)
                        _this6.b.write(s6)
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:106
                    self.write(i,(v2[i] if i >= 0 and i < len(v2) else None))
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:107
                    if (i == last):
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:109
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:109
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:110
                        if self.pretty:
                            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:110
                            _this7 = self.buf
                            s7 = "".join(map(chr,[10]))
                            _this7.b.write(s7)
                        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:111
                        if self.pretty:
                            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:111
                            v4 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this8 = self.buf
                            s8 = Std.string(v4)
                            _this8.b.write(s8)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:114
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:114
                _this9 = self.buf
                s9 = "".join(map(chr,[93]))
                _this9.b.write(s9)
            elif (c == haxe_ds_StringMap):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:116
                v5 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:117
                o = _hx_AnonObject({})
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:118
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:118
                k1 = v5.keys()
                while k1.hasNext():
                    k2 = k1.next()
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:119
                    value = v5.h.get(k2,None)
                    setattr(o,(("_hx_" + k2) if ((k2 in python_Boot.keywords)) else (("_hx_" + k2) if (((((len(k2) > 2) and ((ord(k2[0]) == 95))) and ((ord(k2[1]) == 95))) and ((ord(k2[(len(k2) - 1)]) != 95)))) else k2)),value)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:120
                self.fieldsString(o,python_Boot.fields(o))
            elif (c == Date):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:122
                v6 = v
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:123
                self.quote(v6.toString())
            else:
                self.fieldsString(v,python_Boot.fields(v))
        elif (_g1 == 7):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:131
            i1 = v.index
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:132
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:132
            _this10 = self.buf
            s10 = Std.string(i1)
            _this10.b.write(s10)
        elif (_g1 == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def fieldsString(self,v,fields):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:168
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:168
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:169
        _hx_len = len(fields)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:170
        last = (_hx_len - 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:171
        first = True
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:172
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:172
        _g1 = 0
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:173
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:174
            value = Reflect.field(v,f)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:175
            if Reflect.isFunction(value):
                continue
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:176
            if first:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:176
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:176
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this1 = self.buf
                s1 = "".join(map(chr,[44]))
                _this1.b.write(s1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:177
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:177
                _this2 = self.buf
                s2 = "".join(map(chr,[10]))
                _this2.b.write(s2)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:178
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:178
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this3 = self.buf
                s3 = Std.string(v1)
                _this3.b.write(s3)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:179
            self.quote(f)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:180
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:180
            _this4 = self.buf
            s4 = "".join(map(chr,[58]))
            _this4.b.write(s4)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:181
            if self.pretty:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:181
                _this5 = self.buf
                s5 = "".join(map(chr,[32]))
                _this5.b.write(s5)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:182
            self.write(f,value)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:183
            if (i == last):
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:185
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:185
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:186
                if self.pretty:
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:186
                    _this6 = self.buf
                    s6 = "".join(map(chr,[10]))
                    _this6.b.write(s6)
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:187
                if self.pretty:
                    # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:187
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this7 = self.buf
                    s7 = Std.string(v2)
                    _this7.b.write(s7)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:190
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:190
        _this8 = self.buf
        s8 = "".join(map(chr,[125]))
        _this8.b.write(s8)

    def quote(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:200
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:200
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:201
        i = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:202
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:203
            index = i
            i = (i + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:204
            if (c == -1):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:205
            c1 = c
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:211
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:217
                _this1 = self.buf
                s2 = "".join(map(chr,[c]))
                _this1.b.write(s2)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:221
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:221
        _this2 = self.buf
        s3 = "".join(map(chr,[34]))
        _this2.b.write(s3)

    @staticmethod
    def print(o,replacer = None,space = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:45
        printer = haxe_format_JsonPrinter(replacer,space)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:46
        printer.write("",o)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/format/JsonPrinter.hx:47
        return printer.buf.b.getvalue()

haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString"]
    _hx_statics = ["ofString", "ofData"]

    def __init__(self,length,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:34
        self.length = length
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:35
        self.b = b

    def getString(self,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:362
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:382
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    @staticmethod
    def ofString(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:516
        b = bytearray(s,"UTF-8")
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:517
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Bytes.hx:561
        return haxe_io_Bytes(len(b),b)

haxe_io_Bytes._hx_class = haxe_io_Bytes


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:60
        self.b = list()

    def getBytes(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:207
        buf = bytearray(self.b)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:208
        _hx_bytes = haxe_io_Bytes(len(buf),buf)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:214
        self.b = None
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesBuffer.hx:215
        return _hx_bytes

haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:96
        self.bigEndian = b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Input.hx:97
        return b

haxe_io_Input._hx_class = haxe_io_Input


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "close", "set_bigEndian", "writeFullBytes", "writeString"]

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:47
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:59
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:62
        b = s.b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:63
        k = _hx_len
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:64
        while (k > 0):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:74
            self.writeByte(b[pos])
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:76
            pos = (pos + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:77
            k = (k - 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:79
        return _hx_len

    def flush(self):
        pass

    def close(self):
        pass

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:97
        self.bigEndian = b
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:98
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:123
        while (_hx_len > 0):
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:124
            k = self.writeBytes(s,pos,_hx_len)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:125
            pos = (pos + k)
            # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:126
            _hx_len = (_hx_len - k)

    def writeString(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:282
        b = haxe_io_Bytes.ofString(s)
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Output.hx:284
        self.writeFullBytes(b,0,b.length)

haxe_io_Output._hx_class = haxe_io_Output


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:40
        self.b = haxe_io_BytesBuffer()
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:43
        self.set_bigEndian(False)

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:55
        _this = self.b.b
        _this.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:64
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:64
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b1 = _this.b
        b2 = buf.b
        _g1 = pos
        _g = (pos + _hx_len)
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            _this1 = _this.b
            _this1.append(b2[i])
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:66
        return _hx_len

    def getBytes(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/BytesOutput.hx:137
        return self.b.getBytes()

haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/haxe/io/Eof.hx:31
        return "Eof"

haxe_io_Eof._hx_class = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())
haxe_io_Error._hx_class = haxe_io_Error


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:94
        if (o is None):
            return "null"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:96
        if isinstance(o,str):
            return o
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:98
        if (s is None):
            s = ""
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:99
        if (len(s) >= 5):
            return "<...>"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:101
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:104
        if isinstance(o,int):
            return str(o)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:108
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:120
        if isinstance(o,list):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:122
            o1 = o
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:124
            l = len(o1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:126
            st = "["
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:127
            s = (("null" if s is None else s) + "\t")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:128
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:128
            _g1 = 0
            _g = l
            while (_g1 < _g):
                i = _g1
                _g1 = (_g1 + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:129
                prefix = ""
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:130
                if (i > 0):
                    prefix = ","
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:133
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:135
            st = (("null" if st is None else st) + "]")
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:136
            return st
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:139
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:145
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:147
        if hasattr(o,"__class__"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:150
            if isinstance(o,_hx_AnonObject):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:152
                toStr = None
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:153
                try:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:155
                    fields = python_Boot.fields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:156
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:157
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:163
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:173
            if isinstance(o,Enum):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:175
                o2 = o
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:177
                l1 = len(o2.params)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:178
                hasParams = (l1 > 0)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:179
                if hasParams:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:180
                    paramsStr = ""
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:181
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:181
                    _g12 = 0
                    _g3 = l1
                    while (_g12 < _g3):
                        i1 = _g12
                        _g12 = (_g12 + 1)
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:182
                        prefix1 = ""
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:183
                        if (i1 > 0):
                            prefix1 = ","
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:186
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:188
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:194
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:196
                    fields1 = python_Boot.getInstanceFields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:197
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:199
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:200
                    return toStr1
                else:
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:202
                    fields2 = python_Boot.getClassFields(o)
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:203
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:204
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:205
                    return toStr2
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:209
            if (o == str):
                return "#String"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:213
            if (o == list):
                return "#Array"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:217
            if callable(o):
                return "function"
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:220
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:226
            if hasattr(o,"__str__"):
                return o.__str__([])
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:230
            if hasattr(o,"__name__"):
                return o.__name__
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:233
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:245
        a = []
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:246
        if (o is not None):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:247
            if hasattr(o,"_hx_fields"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:248
                fields = o._hx_fields
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:249
                return list(fields)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:251
            if isinstance(o,_hx_AnonObject):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:253
                d = o.__dict__
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:254
                keys = d.keys()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:255
                handler = python_Boot.unhandleKeywords
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:257
                for k in keys:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:258
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:262
                d1 = o.__dict__
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:263
                keys1 = d1.keys()
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:264
                for k in keys1:
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:265
                    a.append(k)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:269
        return a

    @staticmethod
    def simpleField(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:281
        if (field is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:283
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:284
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:288
        if (field is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:290
        field1 = field
        _hx_local_0 = len(field1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:295
        if (_hx_local_0 == 10):
            if (field1 == "charCodeAt"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:295
                    s1 = o
                    def _hx_local_1(a11):
                        return HxString.charCodeAt(s1,a11)
                    return _hx_local_1
        elif (_hx_local_0 == 11):
            if (field1 == "lastIndexOf"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:297
                    s3 = o
                    def _hx_local_2(a15):
                        return HxString.lastIndexOf(s3,a15)
                    return _hx_local_2
                elif isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:315
                    a4 = o
                    def _hx_local_3(x4):
                        return python_internal_ArrayImpl.lastIndexOf(a4,x4)
                    return _hx_local_3
            elif (field1 == "toLowerCase"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:292
                    s7 = o
                    def _hx_local_4():
                        return HxString.toLowerCase(s7)
                    return _hx_local_4
            elif (field1 == "toUpperCase"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:293
                    s9 = o
                    def _hx_local_5():
                        return HxString.toUpperCase(s9)
                    return _hx_local_5
        elif (_hx_local_0 == 9):
            if (field1 == "substring"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:300
                    s6 = o
                    def _hx_local_6(a19):
                        return HxString.substring(s6,a19)
                    return _hx_local_6
        elif (_hx_local_0 == 4):
            if (field1 == "copy"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:306
                    def _hx_local_7():
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:306
                        return list(o)
                    return _hx_local_7
            elif (field1 == "join"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:309
                    def _hx_local_8(sep):
                        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:309
                        return sep.join([python_Boot.toString1(x1,'') for x1 in o])
                    return _hx_local_8
            elif (field1 == "push"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:312
                    x7 = o
                    def _hx_local_9(e):
                        return python_internal_ArrayImpl.push(x7,e)
                    return _hx_local_9
            elif (field1 == "sort"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:320
                    x11 = o
                    def _hx_local_10(f2):
                        python_internal_ArrayImpl.sort(x11,f2)
                    return _hx_local_10
        elif (_hx_local_0 == 5):
            if (field1 == "shift"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:318
                    x9 = o
                    def _hx_local_11():
                        return python_internal_ArrayImpl.shift(x9)
                    return _hx_local_11
            elif (field1 == "slice"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:319
                    x10 = o
                    def _hx_local_12(a16):
                        return python_internal_ArrayImpl.slice(x10,a16)
                    return _hx_local_12
            elif (field1 == "split"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:298
                    s4 = o
                    def _hx_local_13(d):
                        return HxString.split(s4,d)
                    return _hx_local_13
        elif (_hx_local_0 == 7):
            if (field1 == "indexOf"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:296
                    s2 = o
                    def _hx_local_14(a13):
                        return HxString.indexOf(s2,a13)
                    return _hx_local_14
                elif isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:314
                    a = o
                    def _hx_local_15(x1):
                        return python_internal_ArrayImpl.indexOf(a,x1)
                    return _hx_local_15
            elif (field1 == "reverse"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:317
                    a5 = o
                    def _hx_local_16():
                        python_internal_ArrayImpl.reverse(a5)
                    return _hx_local_16
            elif (field1 == "unshift"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:313
                    x14 = o
                    def _hx_local_17(e2):
                        python_internal_ArrayImpl.unshift(x14,e2)
                    return _hx_local_17
        elif (_hx_local_0 == 3):
            if (field1 == "map"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:303
                    x5 = o
                    def _hx_local_18(f1):
                        return python_internal_ArrayImpl.map(x5,f1)
                    return _hx_local_18
            elif (field1 == "pop"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:311
                    x6 = o
                    def _hx_local_19():
                        return python_internal_ArrayImpl.pop(x6)
                    return _hx_local_19
        elif (_hx_local_0 == 8):
            if (field1 == "iterator"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:307
                    x3 = o
                    def _hx_local_20():
                        return python_internal_ArrayImpl.iterator(x3)
                    return _hx_local_20
            elif (field1 == "toString"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:301
                    s8 = o
                    def _hx_local_21():
                        return HxString.toString(s8)
                    return _hx_local_21
                elif isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:310
                    x13 = o
                    def _hx_local_22():
                        return python_internal_ArrayImpl.toString(x13)
                    return _hx_local_22
        elif (_hx_local_0 == 6):
            if (field1 == "charAt"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:294
                    s = o
                    def _hx_local_23(a1):
                        return HxString.charAt(s,a1)
                    return _hx_local_23
            elif (field1 == "concat"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:305
                    a12 = o
                    def _hx_local_24(a2):
                        return python_internal_ArrayImpl.concat(a12,a2)
                    return _hx_local_24
            elif (field1 == "filter"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:304
                    x = o
                    def _hx_local_25(f):
                        return python_internal_ArrayImpl.filter(x,f)
                    return _hx_local_25
            elif (field1 == "insert"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:308
                    a3 = o
                    def _hx_local_26(a14,x2):
                        python_internal_ArrayImpl.insert(a3,a14,x2)
                    return _hx_local_26
            elif (field1 == "length"):
                if isinstance(o,str):
                    return len(o)
                elif isinstance(o,list):
                    return len(o)
            elif (field1 == "remove"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:316
                    x8 = o
                    def _hx_local_27(e1):
                        return python_internal_ArrayImpl.remove(x8,e1)
                    return _hx_local_27
            elif (field1 == "splice"):
                if isinstance(o,list):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:321
                    x12 = o
                    def _hx_local_28(a17,a21):
                        return python_internal_ArrayImpl.splice(x12,a17,a21)
                    return _hx_local_28
            elif (field1 == "substr"):
                if isinstance(o,str):
                    # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:299
                    s5 = o
                    def _hx_local_29(a18):
                        return HxString.substr(s5,a18)
                    return _hx_local_29
        else:
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:325
        field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:326
        if hasattr(o,field2):
            return getattr(o,field2)
        else:
            return None

    @staticmethod
    def getInstanceFields(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:331
        f = (c._hx_fields if (hasattr(c,"_hx_fields")) else [])
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:332
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:335
        sc = python_Boot.getSuperClass(c)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:337
        if (sc is None):
            return f
        else:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:341
            scArr = python_Boot.getInstanceFields(sc)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:342
            scMap = set(scArr)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:345
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:345
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:346
                if (not (f1 in scMap)):
                    scArr.append(f1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:351
            return scArr

    @staticmethod
    def getSuperClass(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:356
        if (c is None):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:359
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:360
            if hasattr(c,"_hx_super"):
                return c._hx_super
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:363
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:367
        return None

    @staticmethod
    def getClassFields(c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:372
        if hasattr(c,"_hx_statics"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:373
            x = c._hx_statics
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:374
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:398
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:399
            real = HxString.substr(name,python_Boot.prefixLength,None)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:400
            if (real in python_Boot.keywords):
                return real
        # /Users/glen/tools-a8/packages/haxe/current/std/python/Boot.hx:402
        return name
python_Boot._hx_class = python_Boot


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "iterator", "indexOf", "lastIndexOf", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:35
        return (a1 + a2)

    @staticmethod
    def iterator(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:45
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:50
        _hx_len = len(a)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:51
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:55
        if (l < 0):
            l = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:56
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:56
        _g1 = l
        _g = _hx_len
        while (_g1 < _g):
            i = _g1
            _g1 = (_g1 + 1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:57
            if (a[i] == x):
                return i
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:59
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:64
        _hx_len = len(a)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:65
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:69
        if (l > _hx_len):
            l = _hx_len
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:70
        while True:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:70
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:71
            if (a[l] == x):
                return l
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:73
        return -1

    @staticmethod
    def toString(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:84
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:89
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:94
        x.append(e)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:95
        return len(x)

    @staticmethod
    def unshift(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:100
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:105
        try:
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:106
            x.remove(e)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:107
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:115
        if (len(x) == 0):
            return None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:116
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:121
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:125
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:130
        if (pos < 0):
            pos = (len(x) + pos)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:131
        if (pos < 0):
            pos = 0
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:132
        res = x[pos:(pos + _hx_len)]
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:133
        del x[pos:(pos + _hx_len)]
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:134
        return res

    @staticmethod
    def map(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:139
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:144
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:149
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:153
        a.reverse()

    @staticmethod
    def _get(x,idx):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:158
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:163
        l = len(x)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:164
        while (l < idx):
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:165
            x.append(None)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:166
            l = (l + 1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:168
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/ArrayImpl.hx:173
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = Exception


    def __init__(self,val):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:28
        self.val = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:31
        message = str(val)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:32
        super().__init__(message)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxException.hx:33
        self.val = val

_HxException._hx_class = _HxException


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:39
        if isinstance(x,list):
            return python_HaxeIterator(x.__iter__())
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:42
        return x.iterator()

    @staticmethod
    def eq(a,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:46
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:49
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:53
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def mapKwArgs(a,v):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:156
        a1 = python_Lib.dictAsAnon(python_Lib.anonToDict(a))
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:157
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:157
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:158
            val = v.get(k1)
            # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:159
            if hasattr(a1,k1):
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:160
                x = getattr(a1,k1)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:161
                setattr(a1,val,x)
                # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:162
                delattr(a1,k1)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/internal/HxOverrides.hx:165
        return a1
HxOverrides._hx_class = HxOverrides


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = []
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:33
        self.wasEof = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:36
        self.stream = s
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:37
        self.set_bigEndian(False)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:38
        self.wasEof = False
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeInput.hx:39
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")

python_io_NativeInput._hx_class = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian"]
python_io_IInput._hx_class = python_io_IInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
python_io_IFileInput._hx_class = python_io_IFileInput


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close", "flush"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:31
        self.stream = None
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:37
        self.set_bigEndian(False)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:38
        self.stream = stream
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:39
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def close(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:44
        self.stream.close()

    def flush(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeOutput.hx:54
        self.stream.flush()

python_io_NativeOutput._hx_class = python_io_NativeOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]
python_io_IOutput._hx_class = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
python_io_IFileOutput._hx_class = python_io_IFileOutput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeTextInput.hx:39
        super().__init__(stream)
python_io_NativeTextInput._hx_class = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/FileTextInput.hx:32
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeTextOutput.hx:34
        super().__init__(stream)
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeTextOutput.hx:35
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/NativeTextOutput.hx:45
        self.stream.write("".join(map(chr,[c])))

python_io_NativeTextOutput._hx_class = python_io_NativeTextOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/FileTextOutput.hx:30
        super().__init__(stream)
python_io_FileTextOutput._hx_class = python_io_FileTextOutput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText"]

    @staticmethod
    def createFileInputFromText(t):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/IoTools.hx:39
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/io/IoTools.hx:47
        return sys_io_FileOutput(python_io_FileTextOutput(t))
python_io_IoTools._hx_class = python_io_IoTools


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian"]
    _hx_statics = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileInput.hx:37
        self.impl = impl

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileInput.hx:41
        return self.impl.set_bigEndian(b)

sys_io_FileInput._hx_class = sys_io_FileInput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]
    _hx_statics = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:34
        self.impl = impl

    def set_bigEndian(self,b):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:46
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:50
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:54
        return self.impl.writeBytes(s,pos,_hx_len)

    def flush(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:58
        self.impl.flush()

    def close(self):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:62
        self.impl.close()

    def writeFullBytes(self,s,pos,_hx_len):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:70
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeString(self,s):
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/sys/io/FileOutput.hx:114
        self.impl.writeString(s)

sys_io_FileOutput._hx_class = sys_io_FileOutput


class tink_core_Annex:
    _hx_class_name = "tink.core.Annex"
    __slots__ = ("target", "registry")
    _hx_fields = ["target", "registry"]

    def __init__(self,target):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Annex.hx:16
        self.target = target
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Annex.hx:17
        self.registry = haxe_ds_ObjectMap()

tink_core_Annex._hx_class = tink_core_Annex


class tink_core__Callback_Callback_Impl_:
    _hx_class_name = "tink.core._Callback.Callback_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "toFunction", "depth", "MAX_DEPTH", "invoke", "ignore", "fromNiladic", "fromMany", "defer"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:5
        this1 = f
        return this1

    @staticmethod
    def toFunction(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:9
        return this1

    @staticmethod
    def invoke(this1,data):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:14
        if (tink_core__Callback_Callback_Impl_.depth < 1000):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:15
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:15
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:16
            this1(data)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:17
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:17
            _hx_local_2 = tink_core__Callback_Callback_Impl_
            _hx_local_3 = _hx_local_2.depth
            _hx_local_2.depth = (_hx_local_3 - 1)
            _hx_local_3
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:19
            _e = this1
            def _hx_local_4(data1):
                tink_core__Callback_Callback_Impl_.invoke(_e,data1)
            f = _hx_local_4
            a1 = data
            def _hx_local_5():
                f(a1)
            tink_core__Callback_Callback_Impl_.defer(_hx_local_5)

    @staticmethod
    def ignore(cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:22
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:22
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:22
                tink_core__Callback_Callback_Impl_.invoke(cb,tink_core_Noise.Noise)
            return tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def fromNiladic(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:25
        def _hx_local_0(r):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:25
            f()
        this1 = _hx_local_0
        return this1

    @staticmethod
    def fromMany(callbacks):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:29
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:30
            _g = 0
            while (_g < len(callbacks)):
                callback = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                _g = (_g + 1)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:31
                tink_core__Callback_Callback_Impl_.invoke(callback,v)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:28
        return _hx_local_0

    @staticmethod
    def defer(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:47
        haxe_Timer.delay(f,0)
tink_core__Callback_Callback_Impl_._hx_class = tink_core__Callback_Callback_Impl_


class tink_core__Callback_LinkObject:
    _hx_class_name = "tink.core._Callback.LinkObject"
    __slots__ = ()
    _hx_methods = ["dissolve"]
tink_core__Callback_LinkObject._hx_class = tink_core__Callback_LinkObject


class tink_core__Callback_CallbackLink_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackLink_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "cancel", "dissolve", "toCallback", "fromFunction", "join", "fromMany"]

    @staticmethod
    def _new(link):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:59
        this1 = tink_core__Callback_SimpleLink(link)
        return this1

    @staticmethod
    def cancel(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:63
        if (this1 is not None):
            this1.dissolve()

    @staticmethod
    def dissolve(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:66
        if (this1 is not None):
            this1.dissolve()

    @staticmethod
    def toCallback(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:69
        def _hx_local_0(_):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:69
            this1.dissolve()
        return _hx_local_0

    @staticmethod
    def fromFunction(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:72
        this1 = tink_core__Callback_SimpleLink(f)
        return this1

    @staticmethod
    def join(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:75
        return tink_core__Callback_LinkPair(a,b)

    @staticmethod
    def fromMany(callbacks):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:78
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:78
            _g = 0
            while (_g < len(callbacks)):
                cb = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                _g = (_g + 1)
                if (cb is not None):
                    cb.dissolve()
        this1 = tink_core__Callback_SimpleLink(_hx_local_1)
        return this1
tink_core__Callback_CallbackLink_Impl_._hx_class = tink_core__Callback_CallbackLink_Impl_


class tink_core__Callback_SimpleLink:
    _hx_class_name = "tink.core._Callback.SimpleLink"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["dissolve"]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:85
        self.f = f

    def dissolve(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:88
        if (self.f is not None):
            self.f()

tink_core__Callback_SimpleLink._hx_class = tink_core__Callback_SimpleLink


class tink_core__Callback_LinkPair:
    _hx_class_name = "tink.core._Callback.LinkPair"
    __slots__ = ("a", "b", "dissolved")
    _hx_fields = ["a", "b", "dissolved"]
    _hx_methods = ["dissolve"]

    def __init__(self,a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:95
        self.dissolved = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:97
        self.a = a
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:98
        self.b = b

    def dissolve(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:102
        if (not self.dissolved):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:103
            self.dissolved = True
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:104
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:104
            this1 = self.a
            if (this1 is not None):
                this1.dissolve()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:105
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:105
            this2 = self.b
            if (this2 is not None):
                this2.dissolve()

tink_core__Callback_LinkPair._hx_class = tink_core__Callback_LinkPair


class tink_core__Callback_ListCell:
    _hx_class_name = "tink.core._Callback.ListCell"
    __slots__ = ("list", "cb")
    _hx_fields = ["list", "cb"]
    _hx_methods = ["invoke", "clear", "dissolve"]

    def __init__(self,cb,_hx_list):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:115
        if (cb is None):
            raise _HxException("callback expected but null received")
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:116
        self.cb = cb
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:117
        self.list = _hx_list

    def invoke(self,data):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:121
        if (self.cb is not None):
            tink_core__Callback_Callback_Impl_.invoke(self.cb,data)

    def clear(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:125
        self.list = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:126
        self.cb = None

    def dissolve(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:130
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:131
        if (_g is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:132
            v = _g
            self.clear()
            python_internal_ArrayImpl.remove(v,self)

tink_core__Callback_ListCell._hx_class = tink_core__Callback_ListCell


class tink_core__Callback_CallbackList_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackList_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_length", "add", "invoke", "clear"]
    length = None

    @staticmethod
    def _new():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:140
        this1 = []
        return this1

    @staticmethod
    def get_length(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:144
        return len(this1)

    @staticmethod
    def add(this1,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:147
        node = tink_core__Callback_ListCell(cb,this1)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:148
        this1.append(node)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:149
        return node

    @staticmethod
    def invoke(this1,data):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:153
        _g = 0
        _g1 = list(this1)
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:154
            if (cell.cb is not None):
                tink_core__Callback_Callback_Impl_.invoke(cell.cb,data)

    @staticmethod
    def clear(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:157
        _g = 0
        _hx_len = len(this1)
        pos = 0
        if (pos < 0):
            pos = (len(this1) + pos)
        if (pos < 0):
            pos = 0
        res = this1[pos:(pos + _hx_len)]
        del this1[pos:(pos + _hx_len)]
        _g1 = res
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Callback.hx:158
            cell.clear()
tink_core__Callback_CallbackList_Impl_._hx_class = tink_core__Callback_CallbackList_Impl_


class tink_core_TypedError:
    _hx_class_name = "tink.core.TypedError"
    __slots__ = ("message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError")
    _hx_fields = ["message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError"]
    _hx_methods = ["printPos", "toString", "throwSelf"]
    _hx_statics = ["withData", "typed", "asError", "catchExceptions", "reporter", "rethrow", "tryFinally"]

    def __init__(self,code = 500,message = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:44
        if (code is None):
            code = 500
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:47
        self.data = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:51
        self.isTinkError = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:54
        self.code = code
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:55
        self.message = message
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:56
        self.pos = pos
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:57
        self.exceptionStack = []
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:58
        self.callStack = []

    def printPos(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:61
        return ((((HxOverrides.stringOrNull(self.pos.className) + ".") + HxOverrides.stringOrNull(self.pos.methodName)) + ":") + Std.string(self.pos.lineNumber))

    def toString(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:71
        ret = ((("Error#" + Std.string(self.code)) + ": ") + HxOverrides.stringOrNull(self.message))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:73
        if (self.pos is not None):
            ret = (("null" if ret is None else ret) + HxOverrides.stringOrNull(((" @ " + HxOverrides.stringOrNull(self.printPos())))))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:76
        return ret

    def throwSelf(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:88
        raise _HxException(self)

    @staticmethod
    def withData(code = None,message = None,data = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:92
        return tink_core_TypedError.typed(code,message,data,pos)

    @staticmethod
    def typed(code = None,message = None,data = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:96
        ret = tink_core_TypedError(code,message,pos)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:97
        ret.data = data
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:98
        return ret

    @staticmethod
    def asError(v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:112
        value = v
        try:
            if isinstance(value,tink_core_TypedError):
                return value
            else:
                return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    @staticmethod
    def catchExceptions(f,report = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:117
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:121
            _g = tink_core_TypedError.asError(e)
            tmp = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:122
            if (_g is None):
                if (report is None):
                    tmp = tink_core_TypedError.withData(None,"Unexpected Error",e,pos)
                else:
                    tmp = report(e)
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:127
                e1 = _g
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:121
                tmp = e1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:120
            return tink_core_Outcome.Failure(tmp)

    @staticmethod
    def reporter(code = None,message = None,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:133
        def _hx_local_0(e):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:133
            return tink_core_TypedError.withData(code,message,e,pos)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:132
        return _hx_local_0

    @staticmethod
    def rethrow(any):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:143
        raise _HxException(any)

    @staticmethod
    def tryFinally(f,cleanup):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:153
        try:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:154
            ret = f()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:155
            cleanup()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:156
            return ret
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:159
            cleanup()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:160
            raise _HxException(e)

tink_core_TypedError._hx_class = tink_core_TypedError


class tink_core__Error_Stack_Impl_:
    _hx_class_name = "tink.core._Error.Stack_Impl_"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Error.hx:170
        return "Error stack not available. Compile with -D error_stack."
tink_core__Error_Stack_Impl_._hx_class = tink_core__Error_Stack_Impl_


class tink_core__Future_FutureObject:
    _hx_class_name = "tink.core._Future.FutureObject"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
tink_core__Future_FutureObject._hx_class = tink_core__Future_FutureObject


class tink_core__Future_NeverFuture:
    _hx_class_name = "tink.core._Future.NeverFuture"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
    _hx_statics = ["inst"]

    def __init__(self):
        pass

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:217
        return tink_core__Future_NeverFuture.inst

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:218
        return tink_core__Future_NeverFuture.inst

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:219
        return None

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:220
        return tink_core__Future_NeverFuture.inst

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:221
        return tink_core__Future_NeverFuture.inst

tink_core__Future_NeverFuture._hx_class = tink_core__Future_NeverFuture

class tink_core_Noise(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Noise"
tink_core_Noise.Noise = tink_core_Noise("Noise", 0, list())
tink_core_Noise._hx_class = tink_core_Noise


class tink_core__Lazy_LazyObject:
    _hx_class_name = "tink.core._Lazy.LazyObject"
    __slots__ = ()
    _hx_methods = ["get", "map", "flatMap"]
tink_core__Lazy_LazyObject._hx_class = tink_core__Lazy_LazyObject


class tink_core__Lazy_LazyConst:
    _hx_class_name = "tink.core._Lazy.LazyConst"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["get", "map", "flatMap"]

    def __init__(self,value):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:32
        self.value = value

    def get(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:35
        return self.value

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:38
        return tink_core__Lazy_LazyConst(f(self.value))

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:41
        return f(self.value)

tink_core__Lazy_LazyConst._hx_class = tink_core__Lazy_LazyConst


class tink_core__Future_SyncFuture:
    _hx_class_name = "tink.core._Future.SyncFuture"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["map", "flatMap", "handle", "eager", "gather"]

    def __init__(self,value):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:229
        self.value = value

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:232
        return tink_core__Future_SyncFuture(self.value.map(f))

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:236
        l = self.value.map(f)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:235
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:237
            def _hx_local_0(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:237
                return l.get().handle(cb)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:235
            return tink_core__Future_SimpleFuture(_hx_local_0)
        return _hx_local_1()

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:241
        tink_core__Callback_Callback_Impl_.invoke(cb,self.value.get())
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:242
        return None

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:246
        return self

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:249
        return self

tink_core__Future_SyncFuture._hx_class = tink_core__Future_SyncFuture


class tink_core__Future_Future_Impl_:
    _hx_class_name = "tink.core._Future.Future_Impl_"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "first", "map", "flatMap", "next", "merge", "flatten", "asPromise", "ofMany", "fromMany", "lazy", "sync", "async", "or", "either", "and", "_tryFailingFlatMap", "_tryFlatMap", "_tryFailingMap", "_tryMap", "_flatMap", "_map", "trigger"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:12
        this1 = tink_core__Future_SimpleFuture(f)
        return this1

    @staticmethod
    def first(this1,other):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:19
        ret = tink_core_FutureTrigger()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:20
        l1 = this1.handle(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:21
        l2 = other.handle(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:22
        ret1 = ret
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:23
        if (l1 is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:24
            this2 = l1
            def _hx_local_0(_):
                this2.dissolve()
            ret1.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:25
        if (l2 is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:26
            this3 = l2
            def _hx_local_1(_1):
                this3.dissolve()
            ret1.handle(_hx_local_1)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:27
        return ret1

    @staticmethod
    def map(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:34
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:35
        ret = this1.map(f)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:37
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatMap(this1,next,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:45
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:46
        ret = this1.flatMap(next)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:48
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def next(this1,n):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:57
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:57
            def _hx_local_0(v):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:57
                return n(v)
            return this1.flatMap(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:63
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:64
        def _hx_local_1(t):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:64
            def _hx_local_0(a):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:64
                return merger(t,a)
            ret1 = other.map(_hx_local_0)
            return ret1
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:63
        ret = this1.flatMap(_hx_local_1)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatten(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:71
        return tink_core__Future_NestedFuture(f)

    @staticmethod
    def asPromise(s):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:85
        return s

    @staticmethod
    def ofMany(futures,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:90
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:91
        ret = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst([]))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:92
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:92
        _g = 0
        while (_g < len(futures)):
            f = [(futures[_g] if _g >= 0 and _g < len(futures) else None)]
            _g = (_g + 1)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:94
            def _hx_local_4(f1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:94
                def _hx_local_1(results):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:96
                    def _hx_local_3():
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:96
                        def _hx_local_2(result):
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:97
                            return (results + [result])
                        return _hx_local_2
                    ret2 = _hx_local_3()
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:95
                    ret3 = (f1[0] if 0 < len(f1) else None).map(ret2)
                    return ret3
                return _hx_local_1
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:93
            ret1 = ret.flatMap(_hx_local_4(f))
            ret = ret1
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:103
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def fromMany(futures):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:108
        return tink_core__Future_Future_Impl_.ofMany(futures)

    @staticmethod
    def lazy(l):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:112
        return tink_core__Future_SyncFuture(l)

    @staticmethod
    def sync(v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:119
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def async(f,lazy = False):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:126
        if (lazy is None):
            lazy = False
        if lazy:
            return tink_core__Future_LazyTrigger(f)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:129
            op = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:130
            wrapped = f
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:131
            tink_core__Callback_Callback_Impl_.invoke(wrapped,op.trigger)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:132
            return op

    @staticmethod
    def _hx_or(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:139
        return tink_core__Future_Future_Impl_.first(a,b)

    @staticmethod
    def either(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:145
        ret = a.map(haxe_ds_Either.Left)
        ret1 = b.map(haxe_ds_Either.Right)
        return tink_core__Future_Future_Impl_.first(ret,ret1)

    @staticmethod
    def _hx_and(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:151
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:151
            def _hx_local_0(a1,b1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:151
                this1 = tink_core_MPair(a1,b1)
                return this1
            return tink_core__Future_Future_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFailingFlatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:154
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:154
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:155
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:155
                d = o.params[0]
                return _hx_map(d)
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:156
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFlatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:160
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:160
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:161
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:161
                d = o.params[0]
                ret1 = _hx_map(d).map(tink_core_Outcome.Success)
                return ret1.gather()
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:162
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFailingMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:166
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:166
            return tink_core_OutcomeTools.flatMap(o,tink_core__Outcome_OutcomeMapper_Impl_.withSameError(_hx_map))
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:169
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:169
            return tink_core_OutcomeTools.map(o,_hx_map)
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _flatMap(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:172
        ret = f.flatMap(_hx_map)
        return ret.gather()

    @staticmethod
    def _map(f,_hx_map):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:175
        ret = f.map(_hx_map)
        return ret.gather()

    @staticmethod
    def trigger():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:181
        return tink_core_FutureTrigger()
tink_core__Future_Future_Impl_._hx_class = tink_core__Future_Future_Impl_


class tink_core__Future_Futuristic_Impl_:
    _hx_class_name = "tink.core._Future.Futuristic_Impl_"
    __slots__ = ()
    _hx_statics = ["ofAny"]

    @staticmethod
    def ofAny(v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:188
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
tink_core__Future_Futuristic_Impl_._hx_class = tink_core__Future_Futuristic_Impl_


class tink_core__Future_SimpleFuture:
    _hx_class_name = "tink.core._Future.SimpleFuture"
    __slots__ = ("f", "gathered")
    _hx_fields = ["f", "gathered"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager"]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:255
        self.gathered = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:258
        self.f = f

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:261
        return self.f(callback)

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:263
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:264
        def _hx_local_3():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:265
            def _hx_local_2(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:265
                def _hx_local_1():
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:265
                    def _hx_local_0(v):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:265
                        tmp = f(v)
                        tink_core__Callback_Callback_Impl_.invoke(cb,tmp)
                    return _gthis.f(_hx_local_0)
                return _hx_local_1()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:264
            return tink_core__Future_SimpleFuture(_hx_local_2)
        return _hx_local_3()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:269
        f1 = f
        _gthis = self
        def _hx_local_3():
            def _hx_local_2(cb):
                def _hx_local_1():
                    def _hx_local_0(v):
                        tmp = f1(v)
                        tink_core__Callback_Callback_Impl_.invoke(cb,tmp)
                    return _gthis.f(_hx_local_0)
                return _hx_local_1()
            return tink_core__Future_Future_Impl_.flatten(tink_core__Future_SimpleFuture(_hx_local_2))
        return _hx_local_3()

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:272
        return tink_core_FutureTrigger.gatherFuture(self)

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:275
        ret = tink_core_FutureTrigger.gatherFuture(self)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:276
        def _hx_local_0():
            pass
        ret.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:277
        return ret

tink_core__Future_SimpleFuture._hx_class = tink_core__Future_SimpleFuture


class tink_core__Future_NestedFuture:
    _hx_class_name = "tink.core._Future.NestedFuture"
    __slots__ = ("outer",)
    _hx_fields = ["outer"]
    _hx_methods = ["map", "flatMap", "gather", "eager", "handle"]

    def __init__(self,outer):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:285
        self.outer = outer

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:288
        def _hx_local_0(inner):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:288
            ret1 = inner.map(f)
            return ret1.gather()
        ret = self.outer.flatMap(_hx_local_0)
        return ret.gather()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:291
        def _hx_local_0(inner):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:291
            ret1 = inner.flatMap(f)
            return ret1.gather()
        ret = self.outer.flatMap(_hx_local_0)
        return ret.gather()

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:294
        return tink_core_FutureTrigger.gatherFuture(self)

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:297
        ret = tink_core_FutureTrigger.gatherFuture(self)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:298
        def _hx_local_0():
            pass
        ret.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:299
        return ret

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:303
        ret = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:305
        def _hx_local_1(inner):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:305
            nonlocal ret
            def _hx_local_0(result):
                tink_core__Callback_Callback_Impl_.invoke(cb,result)
            ret = inner.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:304
        ret = self.outer.handle(_hx_local_1)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:307
        return ret

tink_core__Future_NestedFuture._hx_class = tink_core__Future_NestedFuture


class tink_core_FutureTrigger:
    _hx_class_name = "tink.core.FutureTrigger"
    __slots__ = ("result", "list")
    _hx_fields = ["result", "list"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager", "asFuture", "trigger"]
    _hx_statics = ["gatherFuture"]

    def __init__(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:312
        self.result = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:316
        this1 = []
        self.list = this1

    def handle(self,callback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:319
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:320
        if (_g is None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:321
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:322
            return None
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:323
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:324
            return tink_core__Callback_CallbackList_Impl_.add(v,callback)

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:328
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:329
        if (_g is None):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(self.result)))
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:330
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:331
            ret = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:332
            def _hx_local_0(v1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:332
                tmp = f(v1)
                ret.trigger(tmp)
            tink_core__Callback_CallbackList_Impl_.add(self.list,_hx_local_0)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:333
            return ret

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:337
        _g = self.list
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:338
        if (_g is None):
            return f(self.result)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:339
            v = _g
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:340
            ret = tink_core_FutureTrigger()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:341
            def _hx_local_0(v1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:341
                f(v1).handle(ret.trigger)
            tink_core__Callback_CallbackList_Impl_.add(self.list,_hx_local_0)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:342
            return ret

    def gather(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:346
        return self

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:349
        return self

    def asFuture(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:352
        return self

    def trigger(self,result):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:371
        if (self.list is None):
            return False
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:373
            _hx_list = self.list
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:374
            self.list = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:375
            self.result = result
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:376
            tink_core__Callback_CallbackList_Impl_.invoke(_hx_list,result)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:377
            tink_core__Callback_CallbackList_Impl_.clear(_hx_list)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:378
            return True

    @staticmethod
    def gatherFuture(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:355
        op = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:356
        def _hx_local_0(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:356
            nonlocal op
            nonlocal f
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:357
            if (op is None):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:358
                op = tink_core_FutureTrigger()
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:359
                f.handle(op.trigger)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:360
                f = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:362
            return op.handle(cb)
        this1 = tink_core__Future_SimpleFuture(_hx_local_0)
        return this1

tink_core_FutureTrigger._hx_class = tink_core_FutureTrigger


class tink_core__Future_LazyTrigger(tink_core_FutureTrigger):
    _hx_class_name = "tink.core._Future.LazyTrigger"
    __slots__ = ("op",)
    _hx_fields = ["op"]
    _hx_methods = ["eager", "map", "flatMap", "handle"]
    _hx_statics = []
    _hx_super = tink_core_FutureTrigger


    def __init__(self,op):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:387
        if (op is None):
            raise _HxException("invalid argument")
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:389
        self.op = op
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:390
        super().__init__()

    def eager(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:394
        if (self.op is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:395
            op = self.op
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:396
            self.op = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:397
            tink_core__Callback_Callback_Impl_.invoke(op,self.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:399
        return self

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:402
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:404
        if (self.op is None):
            return super().map(f)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:405
            def _hx_local_2():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:406
                def _hx_local_1(cb):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:406
                    def _hx_local_0(v):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:406
                        tmp = f(v)
                        cb(tmp)
                    _gthis.handle(_hx_local_0)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:405
                return tink_core__Future_Future_Impl_.async(_hx_local_1,True)
            return _hx_local_2()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:409
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:411
        if (self.op is None):
            return super().flatMap(f)
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:412
            def _hx_local_2():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:413
                def _hx_local_1(cb):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:413
                    def _hx_local_0(v):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:413
                        f(v).handle(cb)
                    _gthis.handle(_hx_local_0)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:412
                return tink_core__Future_Future_Impl_.async(_hx_local_1,True)
            return _hx_local_2()

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:417
        self.eager()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Future.hx:418
        return super().handle(cb)

tink_core__Future_LazyTrigger._hx_class = tink_core__Future_LazyTrigger


class tink_core__Lazy_Lazy_Impl_:
    _hx_class_name = "tink.core._Lazy.Lazy_Impl_"
    __slots__ = ()
    _hx_statics = ["get", "ofFunc", "map", "flatMap", "ofConst"]

    @staticmethod
    def get(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:6
        return this1.get()

    @staticmethod
    def ofFunc(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:9
        return tink_core__Lazy_LazyFunc(f)

    @staticmethod
    def map(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:12
        return this1.map(f)

    @staticmethod
    def flatMap(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:15
        return this1.flatMap(f)

    @staticmethod
    def ofConst(c):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:18
        return tink_core__Lazy_LazyConst(c)
tink_core__Lazy_Lazy_Impl_._hx_class = tink_core__Lazy_Lazy_Impl_


class tink_core__Lazy_LazyFunc:
    _hx_class_name = "tink.core._Lazy.LazyFunc"
    __slots__ = ("f", "result", "busy")
    _hx_fields = ["f", "result", "busy"]
    _hx_methods = ["get", "map", "flatMap"]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:46
        self.result = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:47
        self.busy = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:49
        self.f = f

    def get(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:52
        if self.busy:
            raise _HxException(tink_core_TypedError(None,"circular lazyness",_hx_AnonObject({'fileName': "Lazy.hx", 'lineNumber': 52, 'className': "tink.core._Lazy.LazyFunc", 'methodName': "get"})))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:53
        if (self.f is not None):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:54
            self.busy = True
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:55
            self.result = self.f()
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:56
            self.f = None
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:57
            self.busy = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:59
        return self.result

    def map(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:62
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:63
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:63
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:63
                tmp = _gthis.get()
                return f(tmp)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:65
        _gthis = self
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:66
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:66
            def _hx_local_0():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Lazy.hx:66
                this1 = _gthis.get()
                return f(this1).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

tink_core__Lazy_LazyFunc._hx_class = tink_core__Lazy_LazyFunc


class tink_core_NamedWith:
    _hx_class_name = "tink.core.NamedWith"
    __slots__ = ("name", "value")
    _hx_fields = ["name", "value"]

    def __init__(self,name,value):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Named.hx:11
        self.name = name
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Named.hx:12
        self.value = value

tink_core_NamedWith._hx_class = tink_core_NamedWith


class tink_core_OptionTools:
    _hx_class_name = "tink.core.OptionTools"
    __slots__ = ()
    _hx_statics = ["force", "or", "orNull", "filter", "satisfies", "equals", "map", "flatMap", "iterator", "toArray"]

    @staticmethod
    def force(o,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:11
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:12
            v = o.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:13
            return v
        else:
            raise _HxException(tink_core_TypedError(404,"Some value expected but none found",pos))

    @staticmethod
    def _hx_or(o,l):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:22
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:23
            v = o.params[0]
            return v
        else:
            return l.get()

    @staticmethod
    def orNull(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:31
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:32
            v = o.params[0]
            return v
        else:
            return None

    @staticmethod
    def filter(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:40
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:41
            _hx_tmp = f(o.params[0])
            if (_hx_tmp == False):
                return haxe_ds_Option._hx_None
            else:
                return o
        else:
            return o

    @staticmethod
    def satisfies(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:49
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:50
            v = o.params[0]
            return f(v)
        else:
            return False

    @staticmethod
    def equals(o,v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:58
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:58
            v1 = o.params[0]
            return (v1 == v)
        else:
            return False

    @staticmethod
    def map(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:65
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:66
            v = o.params[0]
            return haxe_ds_Option.Some(f(v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def flatMap(o,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:75
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:76
            v = o.params[0]
            return f(v)
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def iterator(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:85
        return tink_core_OptionIter(o)

    @staticmethod
    def toArray(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:92
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:93
            v = o.params[0]
            return [v]
        else:
            return []
tink_core_OptionTools._hx_class = tink_core_OptionTools


class tink_core_OptionIter:
    _hx_class_name = "tink.core.OptionIter"
    __slots__ = ("value", "alive")
    _hx_fields = ["value", "alive"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:100
        self.value = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:101
        self.alive = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:104
        if (o.index == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:105
            v = o.params[0]
            self.value = v
        else:
            self.alive = False

    def hasNext(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:110
        return self.alive

    def next(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:113
        self.alive = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Option.hx:115
        return self.value

tink_core_OptionIter._hx_class = tink_core_OptionIter

class tink_core_Outcome(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Outcome"

    @staticmethod
    def Success(data):
        return tink_core_Outcome("Success", 0, [data])

    @staticmethod
    def Failure(failure):
        return tink_core_Outcome("Failure", 1, [failure])
tink_core_Outcome._hx_class = tink_core_Outcome


class tink_core_OutcomeTools:
    _hx_class_name = "tink.core.OutcomeTools"
    __slots__ = ()
    _hx_statics = ["sure", "toOption", "toOutcome", "orNull", "orUse", "orTry", "equals", "map", "isSuccess", "flatMap", "swap", "attempt", "flatten"]

    @staticmethod
    def sure(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:18
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:19
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:19
            data = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:20
            return data
        elif (outcome1 == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:21
            failure = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:22
            _g = tink_core_TypedError.asError(failure)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:23
            if (_g is None):
                raise _HxException(failure)
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:24
                e = _g
                return e.throwSelf()
        else:
            pass

    @staticmethod
    def toOption(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:33
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:34
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:34
            data = outcome.params[0]
            return haxe_ds_Option.Some(data)
        elif (outcome1 == 1):
            return haxe_ds_Option._hx_None
        else:
            pass

    @staticmethod
    def toOutcome(option,pos = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:43
        option1 = option.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:44
        if (option1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:44
            value = option.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:45
            return tink_core_Outcome.Success(value)
        elif (option1 == 1):
            return tink_core_Outcome.Failure(tink_core_TypedError(404,((("Some value expected but none found in " + HxOverrides.stringOrNull(pos.fileName)) + "@line ") + Std.string(pos.lineNumber)),_hx_AnonObject({'fileName': "Outcome.hx", 'lineNumber': 47, 'className': "tink.core.OutcomeTools", 'methodName': "toOutcome"})))
        else:
            pass

    @staticmethod
    def orNull(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:55
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:56
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:56
            data = outcome.params[0]
            return data
        elif (outcome1 == 1):
            return None
        else:
            pass

    @staticmethod
    def orUse(outcome,fallback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:65
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:66
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:66
            data = outcome.params[0]
            return data
        elif (outcome1 == 1):
            return fallback.get()
        else:
            pass

    @staticmethod
    def orTry(outcome,fallback):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:75
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:76
        if (outcome1 == 0):
            return outcome
        elif (outcome1 == 1):
            return fallback.get()
        else:
            pass

    @staticmethod
    def equals(outcome,to):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:84
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:85
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:85
            data = outcome.params[0]
            return (data == to)
        elif (outcome1 == 1):
            return False
        else:
            pass

    @staticmethod
    def map(outcome,transform):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:94
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:95
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:95
            a = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:96
            return tink_core_Outcome.Success(transform(a))
        elif (outcome1 == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:97
            f = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:98
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def isSuccess(outcome):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:106
        if (outcome.index == 0):
            return True
        else:
            return False

    @staticmethod
    def flatMap(o,mapper):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:117
        return tink_core__Outcome_OutcomeMapper_Impl_.apply(mapper,o)

    @staticmethod
    def swap(outcome,v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:125
        outcome1 = outcome.index
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:126
        if (outcome1 == 0):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:126
            a = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:127
            return tink_core_Outcome.Success(v)
        elif (outcome1 == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:128
            f = outcome.params[0]
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:129
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def attempt(f,report):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:138
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return tink_core_Outcome.Failure(report(e))

    @staticmethod
    def flatten(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:143
        o1 = o.index
        if (o1 == 0):
            tmp = o.params[0].index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:144
            if (tmp == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:144
                d = o.params[0].params[0]
                return tink_core_Outcome.Success(d)
            elif (tmp == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:145
                f = o.params[0].params[0]
                return tink_core_Outcome.Failure(f)
            else:
                pass
        elif (o1 == 1):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:145
            f1 = o.params[0]
            return tink_core_Outcome.Failure(f1)
        else:
            pass
tink_core_OutcomeTools._hx_class = tink_core_OutcomeTools


class tink_core__Outcome_OutcomeMapper_Impl_:
    _hx_class_name = "tink.core._Outcome.OutcomeMapper_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "withSameError", "withEitherError"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:150
        this1 = _hx_AnonObject({'f': f})
        return this1

    @staticmethod
    def apply(this1,o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:152
        return this1.f(o)

    @staticmethod
    def withSameError(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:155
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:156
            def _hx_local_0(o):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:156
                o1 = o.index
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:157
                if (o1 == 0):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:157
                    d = o.params[0]
                    return f(d)
                elif (o1 == 1):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:158
                    f1 = o.params[0]
                    return tink_core_Outcome.Failure(f1)
                else:
                    pass
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:155
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def withEitherError(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:164
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:165
            def _hx_local_0(o):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:165
                o1 = o.index
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:166
                if (o1 == 0):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:166
                    d = o.params[0]
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:167
                    _g = f(d)
                    _g1 = _g.index
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:168
                    if (_g1 == 0):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:168
                        d1 = _g.params[0]
                        return tink_core_Outcome.Success(d1)
                    elif (_g1 == 1):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:169
                        f1 = _g.params[0]
                        return tink_core_Outcome.Failure(haxe_ds_Either.Right(f1))
                    else:
                        pass
                elif (o1 == 1):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:171
                    f2 = o.params[0]
                    return tink_core_Outcome.Failure(haxe_ds_Either.Left(f2))
                else:
                    pass
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Outcome.hx:164
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()
tink_core__Outcome_OutcomeMapper_Impl_._hx_class = tink_core__Outcome_OutcomeMapper_Impl_


class tink_core__Pair_Pair_Impl_:
    _hx_class_name = "tink.core._Pair.Pair_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_a", "get_b", "toBool", "isNil", "nil"]
    a = None
    b = None

    @staticmethod
    def _new(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:8
        this1 = tink_core_MPair(a,b)
        return this1

    @staticmethod
    def get_a(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:10
        return this1.a

    @staticmethod
    def get_b(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:11
        return this1.b

    @staticmethod
    def toBool(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:14
        return (this1 is not None)

    @staticmethod
    def isNil(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:17
        return (this1 is None)

    @staticmethod
    def nil():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:20
        return None
tink_core__Pair_Pair_Impl_._hx_class = tink_core__Pair_Pair_Impl_


class tink_core_MPair:
    _hx_class_name = "tink.core.MPair"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]

    def __init__(self,a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:27
        self.a = a
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Pair.hx:28
        self.b = b

tink_core_MPair._hx_class = tink_core_MPair


class tink_core__Promise_Promise_Impl_:
    _hx_class_name = "tink.core._Promise.Promise_Impl_"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "eager", "map", "flatMap", "tryRecover", "recover", "mapError", "handle", "noise", "isSuccess", "next", "swap", "swapError", "merge", "and", "iterate", "ofSpecific", "ofFuture", "ofOutcome", "ofError", "ofData", "lazy", "inParallel", "inSequence", "cache", "lift"]

    @staticmethod
    def eager(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:12
        return this1.eager()

    @staticmethod
    def map(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:15
        ret = this1.map(f)
        return ret.gather()

    @staticmethod
    def flatMap(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:18
        ret = this1.flatMap(f)
        return ret.gather()

    @staticmethod
    def tryRecover(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:21
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:21
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:22
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:22
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:23
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def recover(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:27
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:27
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:28
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:28
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(d))
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:29
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def mapError(this1,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:33
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:33
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:34
            if (o1 == 0):
                return o
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:35
                e = o.params[0]
                return tink_core_Outcome.Failure(f(e))
            else:
                pass
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def handle(this1,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:39
        return this1.handle(cb)

    @staticmethod
    def noise(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:42
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:42
            def _hx_local_0(v):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:42
                return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(tink_core_Noise.Noise))
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def isSuccess(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:45
        def _hx_local_0(o):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:45
            return tink_core_OutcomeTools.isSuccess(o)
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def next(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:48
        if (gather is None):
            gather = True
        def _hx_local_0(o):
            o1 = o.index
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:49
            if (o1 == 0):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:49
                d = o.params[0]
                return f(d)
            elif (o1 == 1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:50
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def swap(this1,v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:54
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:54
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:54
                return v
            return tink_core__Future_Future_Impl_._tryMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def swapError(this1,e):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:57
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:57
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:57
                return e
            return tink_core__Promise_Promise_Impl_.mapError(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:60
        if (gather is None):
            gather = True
        def _hx_local_3():
            def _hx_local_2(t):
                def _hx_local_1():
                    def _hx_local_0(a):
                        return merger(t,a)
                    return tink_core__Promise_Promise_Impl_.next(other,_hx_local_0,False)
                return _hx_local_1()
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_2,gather)
        return _hx_local_3()

    @staticmethod
    def _hx_and(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:63
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:63
            def _hx_local_0(a1,b1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:63
                this1 = tink_core_MPair(a1,b1)
                return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(this1))
            return tink_core__Promise_Promise_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def iterate(promises,_hx_yield,_hx_finally,lazy = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:67
        def _hx_local_4():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:67
            def _hx_local_3(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:68
                _hx_iter = HxOverrides.iterator(promises)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:69
                next = None
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:70
                def _hx_local_2():
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:70
                    if _hx_iter.hasNext():
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:71
                        def _hx_local_1(o):
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:71
                            o1 = o.index
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:72
                            if (o1 == 0):
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:72
                                v = o.params[0]
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:73
                                def _hx_local_0(o2):
                                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:73
                                    o3 = o2.index
                                    if (o3 == 0):
                                        next1 = o2.params[0].index
                                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:74
                                        if (next1 == 0):
                                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:74
                                            ret = o2.params[0].params[0]
                                            cb(tink_core_Outcome.Success(ret))
                                        elif (next1 == 1):
                                            next()
                                        else:
                                            pass
                                    elif (o3 == 1):
                                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:76
                                        e = o2.params[0]
                                        cb(tink_core_Outcome.Failure(e))
                                    else:
                                        pass
                                _hx_yield(v).handle(_hx_local_0)
                            elif (o1 == 1):
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:78
                                e1 = o.params[0]
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:79
                                cb(tink_core_Outcome.Failure(e1))
                            else:
                                pass
                        _hx_iter.next().handle(_hx_local_1)
                    else:
                        _hx_finally.handle(cb)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:69
                next = _hx_local_2
                next2 = next
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:84
                next2()
            return tink_core__Future_Future_Impl_.async(_hx_local_3,lazy)
        return _hx_local_4()

    @staticmethod
    def ofSpecific(s):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:94
        return s

    @staticmethod
    def ofFuture(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:97
        ret = f.map(tink_core_Outcome.Success)
        return ret.gather()

    @staticmethod
    def ofOutcome(o):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:100
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))

    @staticmethod
    def ofError(e):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:103
        return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Failure(e))

    @staticmethod
    def ofData(d):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:106
        return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(d))

    @staticmethod
    def lazy(p):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:109
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:109
            def _hx_local_0(cb):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:109
                p.get().handle(cb)
            return tink_core__Future_Future_Impl_.async(_hx_local_0,True)
        return _hx_local_1()

    @staticmethod
    def inParallel(a,lazy = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:113
        if (len(a) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
        else:
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:114
            def _hx_local_8():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:114
                def _hx_local_7(cb):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:115
                    result = []
                    pending = len(a)
                    links = None
                    sync = False
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:120
                    def _hx_local_0(o):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:120
                        nonlocal sync
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:121
                        if (links is None):
                            sync = True
                        elif (links is not None):
                            links.dissolve()
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:123
                        cb(o)
                    done = _hx_local_0
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:127
                    def _hx_local_1(e):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:127
                        done(tink_core_Outcome.Failure(e))
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:126
                    fail = _hx_local_1
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:129
                    def _hx_local_4(index,value):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:130
                        python_internal_ArrayImpl._set(result, index, value)
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:131
                        def _hx_local_3():
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:131
                            nonlocal pending
                            pending = (pending - 1)
                            return pending
                        if ((_hx_local_3()) == 0):
                            done(tink_core_Outcome.Success(result))
                    _hx_set = _hx_local_4
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:135
                    linkArray = []
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:137
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:137
                    _g1 = 0
                    _g = len(a)
                    while (_g1 < _g):
                        i = _g1
                        _g1 = (_g1 + 1)
                        i1 = [i]
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:138
                        if sync:
                            break
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:139
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:139
                        i2 = (i1[0] if 0 < len(i1) else None)
                        def _hx_local_6(i3):
                            def _hx_local_5(o1):
                                o2 = o1.index
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:140
                                if (o2 == 0):
                                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:140
                                    v = o1.params[0]
                                    _hx_set((i3[0] if 0 < len(i3) else None),v)
                                elif (o2 == 1):
                                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:141
                                    e1 = o1.params[0]
                                    fail(e1)
                                else:
                                    pass
                            return _hx_local_5
                        x = _hx_local_6(i1)
                        x1 = (a[i2] if i2 >= 0 and i2 < len(a) else None).handle(x)
                        linkArray.append(x1)
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:145
                    links = tink_core__Callback_CallbackLink_Impl_.fromMany(linkArray)
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:147
                    if sync:
                        if (links is not None):
                            links.dissolve()
                return tink_core__Future_Future_Impl_.async(_hx_local_7,lazy)
            return _hx_local_8()

    @staticmethod
    def inSequence(a):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:153
        loop = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:155
        def _hx_local_4(index):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:155
            if (index == len(a)):
                return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success([]))
            else:
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:157
                def _hx_local_3():
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:158
                    def _hx_local_2(head):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:158
                        def _hx_local_1():
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:159
                            def _hx_local_0(tail):
                                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:159
                                return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(([head] + tail)))
                            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:158
                            return tink_core__Promise_Promise_Impl_.next(loop((index + 1)),_hx_local_0)
                        return _hx_local_1()
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:157
                    return tink_core__Promise_Promise_Impl_.next((a[index] if index >= 0 and index < len(a) else None),_hx_local_2)
                return _hx_local_3()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:153
        loop = _hx_local_4
        loop1 = loop
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:163
        return loop1(0)

    @staticmethod
    def cache(gen):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:167
        p = None
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:168
        def _hx_local_0():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:168
            nonlocal p
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:169
            ret = p
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:170
            if (ret is None):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:171
                sync = False
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:172
                def _hx_local_2(o):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:173
                    def _hx_local_1(_):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:173
                        nonlocal sync
                        nonlocal p
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:174
                        sync = True
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:175
                        p = None
                    o.b.handle(_hx_local_1)
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:177
                    return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(o.a))
                ret = tink_core__Promise_Promise_Impl_.next(gen(),_hx_local_2)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:179
                if (not sync):
                    p = ret
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:181
            def _hx_local_3(o1):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:181
                nonlocal p
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:182
                if (not tink_core_OutcomeTools.isSuccess(o1)):
                    p = None
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:183
                return o1
            ret1 = ret.map(_hx_local_3)
            return ret1.gather()
        return _hx_local_0

    @staticmethod
    def lift(p):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:190
        return p
tink_core__Promise_Promise_Impl_._hx_class = tink_core__Promise_Promise_Impl_


class tink_core__Promise_Next_Impl_:
    _hx_class_name = "tink.core._Promise.Next_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync", "_chain"]

    @staticmethod
    def ofSafe(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:197
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:197
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:200
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:200
            ret = f(x).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:203
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:203
            return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(f(x)))
        return _hx_local_0

    @staticmethod
    def _chain(a,b):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:206
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:206
            return tink_core__Promise_Promise_Impl_.next(a(v),b)
        return _hx_local_0
tink_core__Promise_Next_Impl_._hx_class = tink_core__Promise_Next_Impl_


class tink_core__Promise_Recover_Impl_:
    _hx_class_name = "tink.core._Promise.Recover_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSync"]

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:213
        def _hx_local_0(e):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:213
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(e)))
        return _hx_local_0
tink_core__Promise_Recover_Impl_._hx_class = tink_core__Promise_Recover_Impl_


class tink_core__Promise_Combiner_Impl_:
    _hx_class_name = "tink.core._Promise.Combiner_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync"]

    @staticmethod
    def ofSafe(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:220
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:220
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x1,x2)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:223
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:223
            ret = f(x1,x2).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:226
        def _hx_local_0(x1,x2):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:226
            return tink_core__Promise_Promise_Impl_.ofOutcome(tink_core_Outcome.Success(f(x1,x2)))
        return _hx_local_0
tink_core__Promise_Combiner_Impl_._hx_class = tink_core__Promise_Combiner_Impl_


class tink_core__Ref_Ref_Impl_:
    _hx_class_name = "tink.core._Ref.Ref_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "set_value", "toString", "to"]
    value = None

    @staticmethod
    def _new():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:6
        this1 = None
        this2 = [None]*1
        this1 = this2
        return this1

    @staticmethod
    def get_value(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:8
        return this1[0]

    @staticmethod
    def set_value(this1,param):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:9
        this1[0] = param
        return param

    @staticmethod
    def toString(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:11
        return (("@[" + Std.string(this1[0])) + "]")

    @staticmethod
    def to(v):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:14
        this1 = None
        this2 = [None]*1
        this1 = this2
        ret = this1
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:15
        ret[0] = v
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Ref.hx:16
        return ret
tink_core__Ref_Ref_Impl_._hx_class = tink_core__Ref_Ref_Impl_


class tink_core__Signal_Signal_Impl_:
    _hx_class_name = "tink.core._Signal.Signal_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "map", "flatMap", "filter", "select", "join", "nextTime", "next", "noise", "gather", "generate", "trigger", "ofClassical"]

    @staticmethod
    def _new(f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:9
        this1 = tink_core__Signal_SimpleSignal(f)
        return this1

    @staticmethod
    def map(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:15
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:16
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:16
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:16
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:16
                    this3 = f(result)
                    tink_core__Callback_Callback_Impl_.invoke(cb,this3)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:18
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def flatMap(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:26
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:27
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:27
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:27
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:27
                    f(result).handle(cb)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:29
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def filter(this1,f,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:36
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:37
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:37
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:37
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:37
                    if f(result):
                        tink_core__Callback_Callback_Impl_.invoke(cb,result)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:39
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def select(this1,selector,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:43
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:44
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:44
            def _hx_local_1():
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:44
                def _hx_local_0(result):
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:44
                    _g = selector(result)
                    _g1 = _g.index
                    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:45
                    if (_g1 == 0):
                        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:45
                        v = _g.params[0]
                        tink_core__Callback_Callback_Impl_.invoke(cb,v)
                    elif (_g1 == 1):
                        pass
                    else:
                        pass
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:49
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def join(this1,other,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:57
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:60
        def _hx_local_0(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:60
            return tink_core__Callback_LinkPair(this1.handle(cb),other.handle(cb))
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:58
        this2 = tink_core__Signal_SimpleSignal(_hx_local_0)
        ret = this2
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:63
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def nextTime(this1,condition = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:71
        ret = tink_core_FutureTrigger()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:72
        link = None
        immediate = False
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:75
        def _hx_local_0(v):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:75
            nonlocal immediate
            if ((condition is None) or condition(v)):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:76
                ret.trigger(v)
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:77
                if (link is None):
                    immediate = True
                elif (link is not None):
                    link.dissolve()
        link = this1.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:81
        if immediate:
            if (link is not None):
                link.dissolve()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:84
        return ret

    @staticmethod
    def next(this1,condition = None):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:91
        return tink_core__Signal_Signal_Impl_.nextTime(this1,condition)

    @staticmethod
    def noise(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:97
        def _hx_local_1():
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:97
            def _hx_local_0(_):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:97
                return tink_core_Noise.Noise
            return tink_core__Signal_Signal_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def gather(this1):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:105
        ret = tink_core__Signal_Signal_Impl_.trigger()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:106
        def _hx_local_0(x):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:106
            tink_core__Callback_CallbackList_Impl_.invoke(ret.handlers,x)
        this1.handle(_hx_local_0)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:107
        return ret

    @staticmethod
    def generate(generator):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:111
        ret = tink_core__Signal_Signal_Impl_.trigger()
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:112
        generator(ret.trigger)
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:113
        return ret

    @staticmethod
    def trigger():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:120
        return tink_core_SignalTrigger()

    @staticmethod
    def ofClassical(add,remove,gather = True):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:126
        if (gather is None):
            gather = True
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:127
        def _hx_local_2(cb):
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:128
            def _hx_local_0(a):
                # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:128
                tink_core__Callback_Callback_Impl_.invoke(cb,a)
            f = _hx_local_0
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:129
            add(f)
            # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:130
            this2 = None
            f1 = remove
            a1 = f
            def _hx_local_1():
                f1(a1)
            this2 = tink_core__Callback_SimpleLink(_hx_local_1)
            return this2
        this1 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this1
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:134
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret
tink_core__Signal_Signal_Impl_._hx_class = tink_core__Signal_Signal_Impl_


class tink_core_SignalObject:
    _hx_class_name = "tink.core.SignalObject"
    __slots__ = ()
    _hx_methods = ["handle"]
tink_core_SignalObject._hx_class = tink_core_SignalObject


class tink_core__Signal_SimpleSignal:
    _hx_class_name = "tink.core._Signal.SimpleSignal"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["handle"]

    def __init__(self,f):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:141
        self.f = f

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:142
        return self.f(cb)

tink_core__Signal_SimpleSignal._hx_class = tink_core__Signal_SimpleSignal


class tink_core_SignalTrigger:
    _hx_class_name = "tink.core.SignalTrigger"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["trigger", "getLength", "handle", "clear", "asSignal"]

    def __init__(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:146
        this1 = []
        self.handlers = this1

    def trigger(self,event):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:153
        tink_core__Callback_CallbackList_Impl_.invoke(self.handlers,event)

    def getLength(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:159
        return len(self.handlers)

    def handle(self,cb):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:162
        return tink_core__Callback_CallbackList_Impl_.add(self.handlers,cb)

    def clear(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:168
        tink_core__Callback_CallbackList_Impl_.clear(self.handlers)

    def asSignal(self):
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Signal.hx:171
        return self

tink_core_SignalTrigger._hx_class = tink_core_SignalTrigger

# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:135
Math.NEGATIVE_INFINITY = float("-inf")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:136
Math.POSITIVE_INFINITY = float("inf")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:137
Math.NaN = float("nan")
# /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Math.hx:138
Math.PI = python_lib_Math.pi

Date.EPOCH_UTC = python_lib_datetime_Datetime.fromtimestamp(0,python_lib_datetime_Timezone.utc)
def _hx_init_Sys_environ():
    # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:30
    def _hx_local_0():
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:31
        Sys.environ = haxe_ds_StringMap()
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:33
        env = python_lib_Os.environ
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:35
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:35
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:36
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        # /Users/glen/tools-a8/packages/haxe/current/std/python/_std/Sys.hx:38
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
def _hx_init_a8_GlobalScheduler_scheduler():
    # src/a8/GlobalScheduler.hx:9
    def _hx_local_0():
        # src/a8/GlobalScheduler.hx:10
        s = a8_PySched.scheduler()
        # src/a8/GlobalScheduler.hx:12
        def _hx_local_1():
            # src/a8/GlobalScheduler.hx:12
            while True:
                # src/a8/GlobalScheduler.hx:13
                s.run()
                # src/a8/GlobalScheduler.hx:14
                python_lib_Time.sleep(1)
        # src/a8/GlobalScheduler.hx:11
        a8_PyOps.spawn(_hx_local_1)
        # src/a8/GlobalScheduler.hx:17
        return s
    return _hx_local_0()
a8_GlobalScheduler.scheduler = _hx_init_a8_GlobalScheduler_scheduler()
a8_Logger.traceEnabled = False
a8_PlatformOps.instance = a8_PythonPlatform()
a8_UserConfig.sbtCredentials = a8_PathOps.readProperties(a8_PathOps.entry(a8_PathOps.userHome(),".sbt/credentials"))
a8_UserConfig.versions = a8_PathOps.readProperties(a8_PathOps.entry(a8_PathOps.userHome(),".a8/versions/config.properties"))
haxe_EntryPoint.sleepLock = haxe__EntryPoint_Lock()
haxe_EntryPoint.mutex = haxe__EntryPoint_Mutex()
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
haxe_MainLoop.pending = None
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
tink_core__Callback_Callback_Impl_.depth = 0
tink_core__Callback_Callback_Impl_.MAX_DEPTH = 1000
tink_core__Future_NeverFuture.inst = tink_core__Future_NeverFuture()
tink_core__Future_Future_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(None))
tink_core__Future_Future_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
tink_core__Future_Future_Impl_.NEVER = tink_core__Future_NeverFuture.inst
tink_core__Promise_Promise_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(None)))
tink_core__Promise_Promise_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
def _hx_init_tink_core__Promise_Promise_Impl__NEVER():
    # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:9
    def _hx_local_0():
        # /usr/local/lib/haxe/lib/tink_core/1,17,0/src/tink/core/Promise.hx:9
        ret = tink_core__Future_Future_Impl_.NEVER.map(tink_core_Outcome.Success)
        return ret.gather()
    return _hx_local_0()
tink_core__Promise_Promise_Impl_.NEVER = _hx_init_tink_core__Promise_Promise_Impl__NEVER()

a8_launcher_Main.main()
haxe_EntryPoint.run()
